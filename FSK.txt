--[[

 _   _    _   _   _____     _       ___     _   _   _   _   ____   
| | | |  | | | | |_   _|   / \     / _ \   | | | | | | | | | __ )  
| |_| |  | | | |   | |    / _ \   | | | |  | |_| | | | | | |  _ \  
|  _  |  | | | |   | |   / ___ \  | |_| |  |  _  | | |_| | | |_) | 
\_| |_/   \___/    \_/  /_/   \_\  \___/   \_| |_/  \___/  |____/

                        Hutao Hub
]]

---------------------------------------------------------------------------------

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/SaveManager.lua.txt"))()

local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/InterfaceManager.lua.txt"))()

local minimizeUI = Enum.KeyCode.RightAlt

-- üü¢ Create Main UI
local Window = Fluent:CreateWindow({
    Title = "Hutao Hub [Free] | Forsaken",
    SubTitle = "Version 2.6.2",
    TabWidth = 160,
    Size = UDim2.fromOffset(480, 360),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = minimizeUI
})

-- Tabs
local Tabs = {
    Dev = Window:AddTab({ Title = "About", Icon = "rbxassetid://121302760641013"}),
    Main = Window:AddTab({ Title = "Main", Icon = "rbxassetid://121302760641013" }),
    Player = Window:AddTab({ Title = "Player", Icon = "rbxassetid://121302760641013" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "rbxassetid://121302760641013" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "rbxassetid://121302760641013" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "rbxassetid://121302760641013" }),
}         

-- Tab.Dev

local Options = Fluent.Options


    Tabs.Dev:AddParagraph({
        Title = "Note",
        Content = "Thank you for using the script!"
    })

    Tabs.Dev:AddSection("‚Ü≥ Links")

    Tabs.Dev:AddButton({
        Title = "Discord",
        Description = "Copy the link to join the discord!",
        Callback = function()
            setclipboard("https://discord.gg/WEGT92yv")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })



    Tabs.Dev:AddButton({
        Title = "Youtube",
        Description = "Copy link to Subscribe to Youtube channel!",
        Callback = function()
            setclipboard("https://www.youtube.com/@SLKgamingSSR")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })


    Tabs.Dev:AddButton({
        Title = "Facebook",
        Description = "Copy link to join facebook group!",
        Callback = function()
            setclipboard("https://www.facebook.com/groups/1180845463307087/?ref=share&mibextid=NSMWBT")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })

-- Tabs.Main

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RemoteEvent = ReplicatedStorage.Modules.Network.RemoteEvent

local ActiveAutoUseCoinFlip = false
local coinFlipLoop

Tabs.Main:AddToggle("AutoUseCoinFlip", {
    Title = "Auto Flip Coin",
    Default = false,
}):OnChanged(function(value)
    ActiveAutoUseCoinFlip = value

    if value then
        -- N·∫øu ƒë√£ c√≥ loop c≈© th√¨ h·ªßy ƒë·ªÉ tr√°nh tr√πng l·∫∑p
        if coinFlipLoop then
            task.cancel(coinFlipLoop)
            coinFlipLoop = nil
        end

        -- B·∫Øt ƒë·∫ßu loop g·ª≠i s·ª± ki·ªán m·ªói 1 gi√¢y
        coinFlipLoop = task.spawn(function()
            while ActiveAutoUseCoinFlip do
                pcall(function()
                    RemoteEvent:FireServer("UseActorAbility", "CoinFlip")
                end)
                task.wait(1)
            end
        end)
    else
        -- Khi t·∫Øt toggle th√¨ h·ªßy loop
        if coinFlipLoop then
            task.cancel(coinFlipLoop)
            coinFlipLoop = nil
        end
    end
end)

    Tabs.Main:AddSection("‚Ü≥ Generator")

local solveGeneratorCooldown = false
local AutoFinishGen = false
local autoLoop

-- H√†m t√¨m generator g·∫ßn nh·∫•t (d√πng chung)
local function getClosestGenerator()
    local char = game.Players.LocalPlayer.Character
    if not char or not char.PrimaryPart then return nil end

    local root = char.PrimaryPart
    local closest, shortestDist = nil, math.huge

    local mapContainer = workspace:FindFirstChild("Map")
    if mapContainer then
        local ingame = mapContainer:FindFirstChild("Ingame")
        if ingame then
            local map = ingame:FindFirstChild("Map")
            if map then
                for _, obj in ipairs(map:GetChildren()) do
                    if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                        local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                        if dist < shortestDist then
                            closest = obj
                            shortestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closest
end

-- N√∫t Finish generator th·ªß c√¥ng
Tabs.Main:AddButton({
    Title = "Finish Generator",
    Callback = function()
        if solveGeneratorCooldown then 
            print("Please wait before trying again!") -- ho·∫∑c fu.notification()
            return
        end
        if AutoFinishGen then
            print("Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(1.5, function()
                solveGeneratorCooldown = false
            end)
        end
    end
})

-- Toggle Auto Finish Generator
Tabs.Main:AddToggle("AutoFinishGen", {
    Title = "Auto Finish Generator",
    Default = false
}):OnChanged(function(state)
    AutoFinishGen = state

    if state then
        if solveGeneratorCooldown then
            print("Please wait cooldown to finish before enabling Auto Finish!") -- ho·∫∑c fu.notification()
            AutoFinishGen = false
            Tabs.Main:Set("AutoFinishGen", false) -- t·∫Øt toggle UI
            return
        end

        autoLoop = task.spawn(function()
            while AutoFinishGen do
                local gen = getClosestGenerator()
                if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                    gen.Remotes.RE:FireServer()
                end
                solveGeneratorCooldown = true
                task.wait(1.5)
                solveGeneratorCooldown = false
            end
        end)
    else
        if autoLoop then
            task.cancel(autoLoop)
            autoLoop = nil
        end
        solveGeneratorCooldown = false
    end
end)




local Players = game:GetService("Players")
local PFS = game:GetService("PathfindingService")
local VIM = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = Players.LocalPlayer
local Spectators = {}
local currentCharacter
local isInGame, busy, isSprinting = false, false, false
local stamina, counter = 100, 0
local Killer, Survivor = false, false

-- Danh s√°ch killer nguy hi·ªÉm
local DangerousKillers = {
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- H√†m ki·ªÉm tra c√≥ killer nguy hi·ªÉm g·∫ßn generator kh√¥ng
local function isKillerNearGenerator(generatorPos, distance)
    local killersFolder = workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return false end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            if DangerousKillers[killer.Name] then
                local dist = (killer.HumanoidRootPart.Position - generatorPos).Magnitude
                if dist <= distance then
                    return true
                end
            end
        end
    end
    return false
end

-- H√†m ki·ªÉm tra m·∫∑t ƒë·∫•t
local function safe(pos)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {workspace.Map.Ingame.Map}
    rayParams.FilterType = Enum.RaycastFilterType.Include
    local rayResult = workspace:Raycast(pos + Vector3.new(0, 5, 0), Vector3.new(0, -10, 0), rayParams)
    if rayResult then
        local yDiff = math.abs(rayResult.Position.Y - pos.Y)
        return yDiff < 5
    end
    return false
end

-- N√∫t Toggle Fluent UI
Tabs.Main:AddToggle("AutoExpMoney", {
    Title = "Auto Farm Exp / Money",
    Default = false
})
:OnChanged(function(Value)
    _G.AutoFarm = Value

    -- C·∫≠p nh·∫≠t Spectators / InGame
    task.spawn(function()
        while _G.AutoFarm do
            Spectators = {}
            for _, v in ipairs(workspace:WaitForChild("Players"):WaitForChild("Spectating"):GetChildren()) do
                table.insert(Spectators, v.Name)
            end
            isInGame = not table.find(Spectators, LP.Name)
            task.wait(0.5)
        end
    end)

    -- ‚ö†Ô∏è ƒê√É XO√Å CH·ª®C NƒÇNG AUTO SPRINT

    -- X√°c ƒë·ªãnh m√¨nh l√† Killer hay Survivor
    task.spawn(function()
        while _G.AutoFarm do
            if workspace:FindFirstChild("Players") then
                local killersFolder = workspace.Players:FindFirstChild("Killers")
                local survivorsFolder = workspace.Players:FindFirstChild("Survivors")
                if killersFolder and survivorsFolder then
                    Killer = killersFolder:FindFirstChild(LP.Name) or table.find(killersFolder:GetChildren(), LP.Character)
                    Survivor = survivorsFolder:FindFirstChild(LP.Name) or table.find(survivorsFolder:GetChildren(), LP.Character)
                end
            end
            task.wait(0.5)
        end
    end)

    -- H√†nh ƒë·ªông ch√≠nh
    task.spawn(function()
        task.wait(0.5)
        local killersFolder = workspace.Players:WaitForChild("Killers")
        local survivorsFolder = workspace.Players:WaitForChild("Survivors")

        while _G.AutoFarm do
            if Killer then
                -- Theo d√µi & t·∫•n c√¥ng Survivor
                local target = nil
                for _, survivor in ipairs(survivorsFolder:GetChildren()) do
                    if survivor:IsA("Model")
                    and survivor:FindFirstChild("HumanoidRootPart")
                    and survivor:FindFirstChild("Humanoid")
                    and survivor.Humanoid.Health > 0 then
                        target = survivor
                        break
                    end
                end

                if target then
                    -- D·ªãch chuy·ªÉn theo target
                    task.spawn(function()
                        while _G.AutoFarm
                        and target
                        and target:IsDescendantOf(survivorsFolder)
                        and target:FindFirstChild("Humanoid")
                        and target.Humanoid.Health > 0 do

                            local character = LP.Character
                            if character and character:FindFirstChild("HumanoidRootPart") and target:FindFirstChild("HumanoidRootPart") then
                                character:PivotTo(target.HumanoidRootPart.CFrame)
                            end
                            task.wait(0.1)
                        end
                    end)

                    -- T·∫•n c√¥ng target
                    task.spawn(function()
                        while _G.AutoFarm
                        and target
                        and target:IsDescendantOf(survivorsFolder)
                        and target:FindFirstChild("Humanoid")
                        and target.Humanoid.Health > 0
                        and target:FindFirstChild("HumanoidRootPart") do

                            for _, key in ipairs({Enum.KeyCode.Q, Enum.KeyCode.E, Enum.KeyCode.R}) do
                                if not _G.AutoFarm then break end
                                VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                                task.wait(0.05)
                                VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                                VIM:SendKeyEvent(true, key, false, game)
                                task.wait(0.05)
                                VIM:SendKeyEvent(false, key, false, game)
                                task.wait(0.1)
                            end
                            task.wait(0.8)
                        end
                    end)
                else
                    task.wait(0.5)
                end

            elseif Survivor then
                if isInGame then
                    -- L·∫•y character
                    for _, surv in ipairs(survivorsFolder:GetChildren()) do
                        if surv:GetAttribute("Username") == LP.Name then
                            currentCharacter = surv
                            break
                        end
                    end

                    -- Check ch·∫øt th√¨ reset
                    task.spawn(function()
                        while _G.AutoFarm do
                            if currentCharacter and currentCharacter:FindFirstChild("Humanoid") and currentCharacter.Humanoid.Health <= 0 then
                                isInGame = false
                                isSprinting = false
                                busy = false
                                break
                            end
                            task.wait(0.5)
                        end
                    end)

                    -- L√†m generator
                    for _, gen in ipairs(workspace.Map.Ingame:WaitForChild("Map"):GetChildren()) do
                        if not _G.AutoFarm then break end
                        if gen.Name == "Generator" and gen:FindFirstChild("Progress") and gen.Progress.Value ~= 100 then

                            -- L·∫•y v·ªã tr√≠ ph√≠a tr∆∞·ªõc generator
                            local genCFrame = gen:GetPivot()
                            local goalPos = (genCFrame * CFrame.new(0, 0, -3)).Position

                            -- Anti-Killer check
                            if isKillerNearGenerator(goalPos, 50) then
                                print("‚ö†Ô∏è B·ªè qua generator v√¨ killer nguy hi·ªÉm ·ªü g·∫ßn!")
                                continue
                            end

                            if currentCharacter and currentCharacter:FindFirstChild("HumanoidRootPart") then
                                currentCharacter:PivotTo(CFrame.new(goalPos + Vector3.new(0, 2, 0)))
                                task.wait(0.25)

                                local prompt = gen:FindFirstChild("Main") and gen.Main:FindFirstChild("Prompt")
                                if prompt then
                                    prompt.HoldDuration = 0
                                    prompt.RequiresLineOfSight = false
                                    prompt.MaxActivationDistance = 99999
                                    task.wait(0.1)

                                    pcall(function()
                                        prompt:InputHoldBegin()
                                        prompt:InputHoldEnd()
                                    end)

                                    busy = true
                                    counter = 0
                                    while _G.AutoFarm and gen.Progress.Value ~= 100 do
                                        pcall(function()
                                            prompt:InputHoldBegin()
                                            prompt:InputHoldEnd()
                                            if _G.AutoGeneral == false then
                                                gen.Remotes.RE:FireServer()
                                            end
                                        end)
                                        task.wait(1.5)
                                        counter += 1
                                        if counter >= 10 or not isInGame then break end
                                    end
                                    busy = false
                                    if not isInGame then break end
                                end
                            end
                        end
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end)



    Tabs.Main:AddSection("‚Ü≥ Killers")


Tabs.Main:AddButton({
    Title = "Kill Survivors",
    Callback = function()
        local localChar = game.Players.LocalPlayer.Character
        if not localChar or not localChar:FindFirstChild("HumanoidRootPart") then
            return
        end

        for _, survivor in pairs(workspace.Players.Survivors:GetChildren()) do
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                -- D·ªãch chuy·ªÉn t·ªõi Survivor
                localChar.HumanoidRootPart.CFrame = survivor.HumanoidRootPart.CFrame

                -- G·ª≠i s·ª± ki·ªán t·∫•n c√¥ng Slash + Stab + Punch
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RemoteEvent = ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
                if RemoteEvent then
                    RemoteEvent:FireServer("UseActorAbility", "Slash")
                    task.wait(0.05)
                    RemoteEvent:FireServer("UseActorAbility", "Stab")
                    task.wait(0.05)
                    RemoteEvent:FireServer("UseActorAbility", "Punch")
                end
            end
        end
    end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local Active = false
local loopRunning = false
local CurrentTarget = nil
local lastAttack = 0

local function GetClosestSurvivor()
    local localChar = LocalPlayer.Character
    if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
    local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
    if not survivorsFolder then return nil end

    local closest, minDist = nil, math.huge
    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
        local humanoid = survivor:FindFirstChildOfClass("Humanoid")
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
            local dist = (localChar.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).Magnitude
            if dist < minDist then
                minDist = dist
                closest = survivor
            end
        end
    end
    return closest
end

local function KillTarget(target)
    pcall(function()
        if not target then return end
        local localChar = LocalPlayer.Character
        if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end

        -- D·ªãch chuy·ªÉn t·ªõi m·ª•c ti√™u
        localChar.HumanoidRootPart.CFrame = target.HumanoidRootPart.CFrame

        -- Ch·ªâ ƒë√°nh n·∫øu ƒë√£ qua 0.5 gi√¢y t·ª´ l·∫ßn ƒë√°nh tr∆∞·ªõc
        if tick() - lastAttack >= 0.5 then
            lastAttack = tick()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local remote = ReplicatedStorage:FindFirstChild("Modules")
                          and ReplicatedStorage.Modules:FindFirstChild("Network")
                          and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
            if remote and typeof(remote.FireServer) == "function" then
                remote:FireServer("UseActorAbility", "Slash")
                task.wait(0.05)
                remote:FireServer("UseActorAbility", "Stab")
                task.wait(0.05)
                remote:FireServer("UseActorAbility", "Punch")
            end
        end
    end)
end

local function StartLoop()
    if loopRunning then return end
    loopRunning = true
    task.spawn(function()
        while Active do
            if not CurrentTarget or not CurrentTarget.Parent or not CurrentTarget:FindFirstChildOfClass("Humanoid") or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
                CurrentTarget = GetClosestSurvivor()
            end
            if CurrentTarget then
                KillTarget(CurrentTarget)
            end
            task.wait(0.01)
        end
        loopRunning = false
    end)
end

Tabs.Main:AddToggle("AutoKillSurvivors", {
    Title = "Auto Kill Survivors",
    Default = false,
    Callback = function(Value)
        Active = Value
        if Active then
            StartLoop()
        end
    end
})


    Tabs.Main:AddSection("‚Ü≥ Survivors")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- C·∫•u h√¨nh skill cho t·ª´ng model
local skillConfig = {
    ["Shedletsky"] = {skillName = "Slash", cooldown = 40, castTime = 1},
    ["TwoTime"]    = {skillName = "Dagger", cooldown = 30, castTime = 1},
    ["Chance"]     = {skillName = "Shoot", cooldown = 40, castTime = 2},
    ["Dusekkar"]   = {skillName = "PlasmaBeam", cooldown = 30, castTime = 2}
}

-- Bi·∫øn ƒëi·ªÅu khi·ªÉn
local Active = false
local loopRunning = false
local CurrentTarget = nil
local lastAttack = 0
local currentModelName = nil

-- T√¨m Killer g·∫ßn nh·∫•t
local function GetClosestKiller()
    local localChar = LocalPlayer.Character
    if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return nil end

    local closest, minDist = nil, math.huge
    for _, killer in ipairs(killersFolder:GetChildren()) do
        local humanoid = killer:FindFirstChildOfClass("Humanoid")
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
            local dist = (localChar.HumanoidRootPart.Position - killer.HumanoidRootPart.Position).Magnitude
            if dist < minDist then
                minDist = dist
                closest = killer
            end
        end
    end
    return closest
end

-- H√†m t·∫•n c√¥ng m·ª•c ti√™u (spam skill + teleport)
local function AttackTarget(target, skillName)
    if not target then return end
    local localChar = LocalPlayer.Character
    if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end

    local config = skillConfig[currentModelName]
    if not config then return end

    -- Ki·ªÉm tra cooldown
    if tick() - lastAttack >= config.cooldown then
        lastAttack = tick()

        -- L∆∞u v·ªã tr√≠ ban ƒë·∫ßu
        local savedPosition = localChar.HumanoidRootPart.CFrame

        -- L·∫•y remote skill
        local remote = ReplicatedStorage:FindFirstChild("Modules")
            and ReplicatedStorage.Modules:FindFirstChild("Network")
            and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")

        -- Spam teleport + skill trong castTime
        local startTime = tick()
        while tick() - startTime < config.castTime and Active do
            if target and target:FindFirstChild("HumanoidRootPart") then
                -- Teleport ƒë·∫øn m·ª•c ti√™u
                localChar.HumanoidRootPart.CFrame = target.HumanoidRootPart.CFrame

                -- Spam skill
                if remote and typeof(remote.FireServer) == "function" then
                    remote:FireServer("UseActorAbility", skillName)
                end
            else
                break
            end
            task.wait(0.05)
        end

        -- Quay l·∫°i ch·ªó c≈©
        if localChar and localChar:FindFirstChild("HumanoidRootPart") then
            localChar.HumanoidRootPart.CFrame = savedPosition
        end
    end
end

-- V√≤ng l·∫∑p Auto Attack
local function StartLoop()
    if loopRunning then return end
    loopRunning = true
    task.spawn(function()
        while Active do
            local char = LocalPlayer.Character
            if char and skillConfig[char.Name] then
                currentModelName = char.Name
                local skillName = skillConfig[char.Name].skillName

                -- L·∫•y m·ª•c ti√™u m·ªõi n·∫øu m·ª•c ti√™u c≈© ch·∫øt/m·∫•t
                if not CurrentTarget or not CurrentTarget.Parent
                    or not CurrentTarget:FindFirstChildOfClass("Humanoid")
                    or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
                    CurrentTarget = GetClosestKiller()
                end

                if CurrentTarget then
                    AttackTarget(CurrentTarget, skillName)
                end
            end
            task.wait(0.05)
        end
        loopRunning = false
    end)
end

-- N√∫t b·∫•m t·∫•n c√¥ng 1 l·∫ßn
Tabs.Main:AddButton({
    Title = "Attack Killers",
    Callback = function()
        local char = LocalPlayer.Character
        if char and skillConfig[char.Name] then
            currentModelName = char.Name
            local target = GetClosestKiller()
            if target then
                AttackTarget(target, skillConfig[char.Name].skillName)
            end
        end
    end
})

-- Toggle auto t·∫•n c√¥ng
Tabs.Main:AddToggle("AutoAttackKillers", {
    Title = "Auto Attack Killers",
    Default = false,
    Callback = function(Value)
        Active = Value
        if Active then
            lastAttack = -999 -- reset ƒë·ªÉ t·∫•n c√¥ng ngay l·∫≠p t·ª©c
            StartLoop()
        else
            CurrentTarget = nil
        end
    end
})

    Tabs.Main:AddSection("‚Ü≥ Items")

local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- H√†m nh·∫∑t item g·∫ßn nh·∫•t
local function pickUpNearest()
    local map = workspace:FindFirstChild("Map") 
                and workspace.Map:FindFirstChild("Ingame") 
                and workspace.Map.Ingame:FindFirstChild("Map")
    if not map or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then return end

    local oldCFrame = LP.Character.HumanoidRootPart.CFrame
    for _, item in ipairs(map:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("ItemRoot") 
           and item.ItemRoot:FindFirstChild("ProximityPrompt") then
            LP.Character.HumanoidRootPart.CFrame = item.ItemRoot.CFrame
            task.wait(0.3)
            fireproximityprompt(item.ItemRoot.ProximityPrompt)
            task.wait(0.4)
            LP.Character.HumanoidRootPart.CFrame = oldCFrame
            break
        end
    end
end

-- Button: Pick Up Item (1 l·∫ßn)
Tabs.Main:AddButton({
    Title = "Pick Up Item",
    Callback = pickUpNearest
})

-- Toggle: Auto PickUp Item (l·∫∑p)
Tabs.Main:AddToggle("ItemPick", {
    Title = "Auto PickUp Item",
    Default = false
}):OnChanged(function(Value)
    _G.PickupItem = Value
    if not Value then return end

    task.spawn(function()
        while _G.PickupItem do
            pickUpNearest()
            task.wait(0.2) -- delay gi·ªØa m·ªói l·∫ßn nh·∫∑t
        end
    end)
end)


-- Tabs.Player

-- Forsaken Player Aimlock with Fluent GUI Toggle (Fix: Switch to nearest, skip dead)
if not game:IsLoaded() then game.Loaded:Wait() end

-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ======= WHITELIST MODEL =======
local AllowedModels = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local AimlockEnabled = false

-- ======= H√ÄM KI·ªÇM TRA MODEL =======
local function IsAllowedModel(model)
    return AllowedModels[model.Name] == true
end

-- ======= L·∫§Y MODEL FORSAKEN =======
local function GetPlayerModel(plr)
    if not plr.Character then return nil end
    if IsAllowedModel(plr.Character) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
        return plr.Character
    end
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
            if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                if IsAllowedModel(model) then
                    return model
                end
            end
        end
    end
    return nil
end

-- ======= L·∫§Y M·ª§C TI√äU G·∫¶N NH·∫§T =======
local function GetClosestTarget()
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local model = GetPlayerModel(plr)
            if model and model.PrimaryPart then
                local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health > 0 then -- b·ªè qua model ch·∫øt
                    local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                    if distance < dist then
                        dist = distance
                        closest = model
                    end
                end
            end
        end
    end
    return closest
end

-- ======= AIMLOCK LOOP =======
RunService.RenderStepped:Connect(function()
    if AimlockEnabled then
        local newTarget = GetClosestTarget()
        if newTarget then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, newTarget.PrimaryPart.Position)
        end
    end
end)

-- ======= FLUENT GUI TOGGLE =======
Tabs.Player:AddToggle("ForsakenAimlock", {
    Title = "Aimlock Player",
    Default = false
}):OnChanged(function(Value)
    AimlockEnabled = Value
end)





-- Auto Aim Killer To Shoot 
if not game:IsLoaded() then game.Loaded:Wait() end

-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ======= WHITELIST MODEL =======
local AllowedModels = {
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local AimlockEnabled = false

-- ======= H√ÄM KI·ªÇM TRA MODEL =======
local function IsAllowedModel(model)
    return AllowedModels[model.Name] == true
end

-- ======= L·∫§Y MODEL FORSAKEN =======
local function GetPlayerModel(plr)
    if not plr.Character then return nil end
    if IsAllowedModel(plr.Character) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
        return plr.Character
    end
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
            if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                if IsAllowedModel(model) then
                    return model
                end
            end
        end
    end
    return nil
end

-- ======= L·∫§Y M·ª§C TI√äU G·∫¶N NH·∫§T =======
local function GetClosestTarget()
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local model = GetPlayerModel(plr)
            if model and model.PrimaryPart then
                local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health > 0 then -- b·ªè qua model ch·∫øt
                    local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                    if distance < dist then
                        dist = distance
                        closest = model
                    end
                end
            end
        end
    end
    return closest
end

-- ======= AIMLOCK LOOP =======
RunService.RenderStepped:Connect(function()
    if AimlockEnabled then
        local newTarget = GetClosestTarget()
        if newTarget then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, newTarget.PrimaryPart.Position)
        end
    end
end)

-- ======= FLUENT GUI TOGGLE =======
Tabs.Player:AddToggle("ForsakenAimlock1", {
    Title = "Aimlock Killer",
    Default = false
}):OnChanged(function(Value)
    AimlockEnabled = Value
end)




    Tabs.Player:AddSection("‚Ü≥ Cheats")


local ActiveNoStun = false
local noStunLoop

Tabs.Player:AddToggle("NoStunToggle", {
    Title = "No Stun",
    Default = false,
}):OnChanged(function(value)
    ActiveNoStun = value

    if value then
        -- N·∫øu c√≥ loop c≈© th√¨ d·ª´ng
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end

        -- T·∫°o loop m·ªõi li√™n t·ª•c ƒë·∫£m b·∫£o HumanoidRootPart kh√¥ng b·ªã anchore
        noStunLoop = task.spawn(function()
            while ActiveNoStun do
                local character = game.Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
                task.wait(0.1) -- Kh√¥ng c·∫ßn qu√° nhanh, tr√°nh lag
            end
        end)
    else
        -- T·∫Øt loop khi toggle off
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end
    end
end)


local StaminaModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
local InfStaminaEnabled = false
local staminaLoop

pcall(function() -- Ch·∫∑n l·ªói t·ª´ Fluent UI
    Tabs.Player:AddToggle("InfStamina", {
        Title = "Infinite Stamina",
        Default = false
    })
    :OnChanged(function(value)
        pcall(function() -- Ch·∫∑n l·ªói khi ch·∫°y
            InfStaminaEnabled = value
            StaminaModule.StaminaLossDisabled = value

            if value then
                -- H·ªìi ngay khi b·∫≠t
                StaminaModule.Stamina = StaminaModule.MaxStamina
                StaminaModule.StaminaChanged:Fire()

                -- N·∫øu ch∆∞a c√≥ loop th√¨ m·ªõi t·∫°o
                if not staminaLoop then
                    staminaLoop = task.spawn(function()
                        while InfStaminaEnabled do
                            task.wait(0.5) -- h·ªìi m·ªói 0.5s
                            StaminaModule.Stamina = StaminaModule.MaxStamina
                            StaminaModule.StaminaChanged:Fire()
                        end
                        staminaLoop = nil -- khi t·∫Øt xong th√¨ gi·∫£i ph√≥ng
                    end)
                end
            else
                -- Khi t·∫Øt th√¨ ch·ªâ c·∫ßn ƒë·∫∑t flag false, loop s·∫Ω t·ª± d·ª´ng
                InfStaminaEnabled = false
            end
        end)
    end)
end)



local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

local FakeDieEnabled = false
local FakeDieLoop
local MovementBlocked = false

-- H√†m n·∫±m xu·ªëng
local function LieDown()
    local Character = LocalPlayer.Character
    if not Character then return end
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    
    if Humanoid then
        Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    end

    if HRP then
        HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(math.rad(90), 0, 0)
        HRP.Velocity = Vector3.zero
        HRP.AssemblyLinearVelocity = Vector3.zero
        HRP.AssemblyAngularVelocity = Vector3.zero
    end

    -- Ch·∫∑n di chuy·ªÉn
    MovementBlocked = true
end

-- H√†m ƒë·ª©ng d·∫≠y
local function StandUp()
    local Character = LocalPlayer.Character
    if not Character then return end
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local HRP = Character:FindFirstChild("HumanoidRootPart")

    if Humanoid then
        Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end

    if HRP then
        HRP.CFrame = CFrame.new(HRP.Position + Vector3.new(0, 3, 0))
    end

    MovementBlocked = false
end

-- Ch·∫∑n input di chuy·ªÉn khi ƒëang n·∫±m
UserInputService.InputBegan:Connect(function(input, gp)
    if MovementBlocked and input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.W
        or input.KeyCode == Enum.KeyCode.A
        or input.KeyCode == Enum.KeyCode.S
        or input.KeyCode == Enum.KeyCode.D
        or input.KeyCode == Enum.KeyCode.Space then
            input:Capture() -- NgƒÉn thao t√°c
        end
    end
end)

-- Toggle trong Tabs.Player
Tabs.Player:AddToggle("FakeDie", {
    Title = "Fake Die [Beta]",
    Default = false
}):OnChanged(function(state)
    FakeDieEnabled = state

    if state then
        -- B·∫Øt ƒë·∫ßu loop gi·ªØ n·∫±m
        FakeDieLoop = task.spawn(function()
            while FakeDieEnabled do
                LieDown()
                task.wait(0.2) -- C·∫≠p nh·∫≠t li√™n t·ª•c ƒë·ªÉ ƒë·∫£m b·∫£o lu√¥n n·∫±m
            end
        end)
    else
        if FakeDieLoop then
            task.cancel(FakeDieLoop)
            FakeDieLoop = nil
        end
        StandUp()
    end
end)

-- ƒê·∫£m b·∫£o khi respawn v·∫´n gi·ªØ tr·∫°ng th√°i
LocalPlayer.CharacterAdded:Connect(function(char)
    if FakeDieEnabled then
        task.wait(1) -- ch·ªù load xong
        LieDown()
    end
end)



-- File: Toggle.lua
-- ƒê√¢y l√† toggle trong Fluent GUI, g·ªçi script ch√≠nh t·ª´ Github

-- Gi·∫£ s·ª≠ b·∫°n ƒë√£ load module Hutao t·ª´ GitHub:
local Hutao = loadstring(game:HttpGet("https://raw.githubusercontent.com/HocSinhLop10/Skid/refs/heads/main/SFSK.lua"))()

Tabs.Player:AddToggle("ToggleCoolButton", {
    Title = "Use Hutao Skill",
    Default = true,
    Callback = function(Value)
        if Value then
            Hutao.Enable()
        else
            Hutao.Disable()
        end
    end
})


    Tabs.Player:AddSection("‚Ü≥ Hitbox")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch model c·∫ßn tƒÉng hitbox
local targetModels = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

local HitboxEnabled = false
local HitboxScale = 2 -- m·∫∑c ƒë·ªãnh
local originalSizes = {}

-- H√†m √°p d·ª•ng hitbox
local function applyHitboxToCharacter(char, owner)
    if not HitboxEnabled then return end
    if not targetModels[char.Name] then return end
    if owner == LocalPlayer then return end -- Kh√¥ng √°p d·ª•ng cho b·∫£n th√¢n

    local part = char:FindFirstChild("HumanoidRootPart")
    if part and part:IsA("BasePart") then
        if not originalSizes[part] then
            originalSizes[part] = part.Size
        end

        part.Size = originalSizes[part] * HitboxScale
        part.Transparency = 0.8 -- Trong su·ªët
        part.Color = Color3.fromRGB(255, 0, 0) -- ƒê·ªè
        part.Material = Enum.Material.Neon
        part.CanCollide = false
    end
end

-- H√†m reset hitbox
local function resetHitbox(char)
    local part = char:FindFirstChild("HumanoidRootPart")
    if part and part:IsA("BasePart") and originalSizes[part] then
        part.Size = originalSizes[part]
        part.Transparency = 1
        part.Material = Enum.Material.Plastic
    end
end

-- Slider ch·ªânh scale
Tabs.Player:AddSlider("HitboxScale", {
    Title = "Hitbox Scale",
    Default = 2,
    Min = 1,
    Max = 10,
    Rounding = 1
}):OnChanged(function(value)
    HitboxScale = value
    if HitboxEnabled then
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr.Character then
                applyHitboxToCharacter(plr.Character, plr)
            end
        end
    end
end)

-- Toggle b·∫≠t/t·∫Øt (n·∫±m d∆∞·ªõi slider)
Tabs.Player:AddToggle("HitboxToggle", {
    Title = "Hitbox Target Players",
    Default = false
}):OnChanged(function(state)
    HitboxEnabled = state

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            if state then
                applyHitboxToCharacter(player.Character, player)
            else
                resetHitbox(player.Character)
            end
        end
    end
end)

-- Theo d√µi player m·ªõi v√†o
Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        applyHitboxToCharacter(char, plr)
    end)
end)

-- √Åp d·ª•ng cho player hi·ªán t·∫°i
for _, plr in ipairs(Players:GetPlayers()) do
    plr.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        applyHitboxToCharacter(char, plr)
    end)
    if plr.Character then
        applyHitboxToCharacter(plr.Character, plr)
    end
end




    Tabs.Player:AddSection("‚Ü≥ Walk Speed")


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ValueSpeed = 16
local ActiveSpeedBoost = false
local speedLoop

local function setSpeed(speed)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = speed
        humanoid:SetAttribute("BaseSpeed", speed)
    end
end

-- Khi respawn √°p d·ª•ng l·∫°i t·ªëc ƒë·ªô n·∫øu b·∫≠t
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    if ActiveSpeedBoost then
        setSpeed(ValueSpeed)
    end
end)

-- Slider ch·ªânh t·ªëc ƒë·ªô
Tabs.Player:AddSlider("PlayerSpeedSlider", {
    Title = "Set Speed",
    Min = 0,
    Max = 40,
    Default = ValueSpeed,
    Rounding = 1,
}):OnChanged(function(value)
    ValueSpeed = value
    if ActiveSpeedBoost then
        setSpeed(ValueSpeed)
    end
end)

-- Toggle b·∫≠t/t·∫Øt t·ªëc ƒë·ªô v√† loop tƒÉng t·ªëc li√™n t·ª•c
Tabs.Player:AddToggle("PlayerSpeedToggle", {
    Title = "Walk Speed",
    Default = false,
}):OnChanged(function(value)
    ActiveSpeedBoost = value
    if value then
        setSpeed(ValueSpeed)
        -- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p li√™n t·ª•c set t·ªëc ƒë·ªô m·ªói 0.5 gi√¢y
        speedLoop = task.spawn(function()
            while ActiveSpeedBoost do
                setSpeed(ValueSpeed)
                task.wait(0.5)
            end
        end)
    else
        -- T·∫Øt v√≤ng l·∫∑p v√† reset t·ªëc ƒë·ªô v·ªÅ m·∫∑c ƒë·ªãnh 16
        if speedLoop then
            speedLoop = nil
        end
        setSpeed(16)
    end
end)


-- Tabs.Visual

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- üìå Danh s√°ch model cho ESP tr·∫Øng
local allowedModelsWhite = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
}

-- üìå Danh s√°ch model cho ESP ƒë·ªè
local allowedModelsRed = {
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- Internal containers
local drawingsWhite = {}
local drawingsRed = {}
local espConnectionWhite, espConnectionRed
local addedConnWhite, removedConnWhite
local addedConnRed, removedConnRed

-- T·∫°o ESP (m√†u tu·ª≥ ch·ªçn)
local function createESP(model, drawings, color)
    if not model or drawings[model] then return end
    local hrp = model:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Visible = false
    text.Color = color

    drawings[model] = text
end

-- Xo√° ESP
local function removeESP(model, drawings)
    if drawings[model] then
        pcall(function() drawings[model]:Remove() end)
        drawings[model] = nil
    end
end

-- Qu√©t workspace v√† t·∫°o ESP
local function scanWorkspaceForAllowed(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
            createESP(obj, drawings, color)
        end
    end
end

-- B·∫Øt ƒë·∫ßu ESP (m√†u tu·ª≥ ch·ªçn)
local function startESP(allowedList, drawings, espConnectionVar, addedConnVar, removedConnVar, color)
    if espConnectionVar then return end
    scanWorkspaceForAllowed(allowedList, drawings, color)

    espConnectionVar = RunService.RenderStepped:Connect(function()
        for model, text in pairs(drawings) do
            if not model or not model.Parent or not model:FindFirstChild("HumanoidRootPart") then
                text.Visible = false
            else
                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude
                text.Text = string.format("%s [%.0fm]", model.Name, dist)
                text.Position = Vector2.new(pos.X, pos.Y)
                text.Visible = onScreen
            end
        end
    end)

    addedConnVar = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedList[model.Name] and model:FindFirstChild("HumanoidRootPart") then
            createESP(model, drawings, color)
        end
    end)

    removedConnVar = workspace.DescendantRemoving:Connect(function(obj)
        if obj:IsA("Model") and drawings[obj] then
            removeESP(obj, drawings)
        end
    end)

    return espConnectionVar, addedConnVar, removedConnVar
end

-- D·ª´ng ESP
local function stopESP(drawings, espConnectionVar, addedConnVar, removedConnVar)
    if espConnectionVar then espConnectionVar:Disconnect() end
    if addedConnVar then addedConnVar:Disconnect() end
    if removedConnVar then removedConnVar:Disconnect() end
    for _, text in pairs(drawings) do
        pcall(function() text:Remove() end)
    end
    table.clear(drawings)
    return nil, nil, nil
end

Tabs.Visual:AddToggle("ESPModelWhiteToggle", {
    Title = "ESP Survivors",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        espConnectionWhite, addedConnWhite, removedConnWhite =
            startESP(allowedModelsWhite, drawingsWhite, espConnectionWhite, addedConnWhite, removedConnWhite, Color3.fromRGB(255, 255, 255))
    else
        espConnectionWhite, addedConnWhite, removedConnWhite =
            stopESP(drawingsWhite, espConnectionWhite, addedConnWhite, removedConnWhite)
    end
end)

Tabs.Visual:AddToggle("ESPModelRedToggle", {
    Title = "ESP Killer",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        espConnectionRed, addedConnRed, removedConnRed =
            startESP(allowedModelsRed, drawingsRed, espConnectionRed, addedConnRed, removedConnRed, Color3.fromRGB(255, 0, 0))
    else
        espConnectionRed, addedConnRed, removedConnRed =
            stopESP(drawingsRed, espConnectionRed, addedConnRed, removedConnRed)
    end
end)



-- === ESP Generator (·∫©n khi s·ª≠a xong) ===
local EspTab = EspTab or Tabs.Visual or Tabs.Main -- tu·ª≥ lib; n·∫øu ƒë√£ c√≥ EspTab th√¨ gi·ªØ nguy√™n
local highlights = {}        -- [Model] = Highlight
local progressConns = {}     -- [Model] = RBXScriptConnection
local espLoop = nil
local espEnabled = false

-- Tr·ª£ gi√∫p: tr·∫£ v·ªÅ list generator trong map
local function getGenerators()
    local list = {}
    local mapRoot = workspace:FindFirstChild("Map")
    local ingame = mapRoot and mapRoot:FindFirstChild("Ingame")
    local mapFolder = ingame and ingame:FindFirstChild("Map")

    local function scan(root)
        if not root then return end
        for _, obj in ipairs(root:GetDescendants()) do
            if obj:IsA("Model") and obj.Name == "Generator" and obj:FindFirstChild("PrimaryPart") or (obj:IsA("Model") and obj.Name == "Generator" and obj.PrimaryPart) then
                table.insert(list, obj)
            elseif obj:IsA("Model") and obj.Name == "Generator" and obj.PrimaryPart == nil then
                -- c·ªë g·∫Øng ch·ªçn m·ªôt part l√†m PrimaryPart n·∫øu thi·∫øu
                local hrp = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
                if hrp then
                    pcall(function() obj.PrimaryPart = hrp end)
                    table.insert(list, obj)
                end
            end
        end
    end

    scan(mapFolder or ingame or mapRoot or workspace)
    return list
end

local function isCompleted(gen)
    local p = gen:FindFirstChild("Progress")
    return p and tonumber(p.Value) and p.Value >= 100
end

local function hideHighlight(gen)
    local h = highlights[gen]
    if h then h.Enabled = false end
end

local function ensureHighlight(gen)
    -- t·∫°o n·∫øu ch∆∞a c√≥, ƒë·∫∑t Adornee ƒë·ªÉ nhi·ªÅu model v·∫´n hi·ªÉn th·ªã ƒë√∫ng
    local h = highlights[gen]
    if not h then
        h = Instance.new("Highlight")
        h.Adornee = gen
        h.FillColor = Color3.fromRGB(255, 255, 255)
        h.OutlineColor = Color3.fromRGB(255, 255, 255)
        h.FillTransparency = 0.5
        h.OutlineTransparency = 0
        h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        h.Enabled = true
        h.Parent = gen -- Parent v·ªÅ ch√≠nh model ƒë·ªÉ an to√†n ph·∫°m vi
        highlights[gen] = h
    else
        h.Enabled = true
    end
end

local function disconnectProgress(gen)
    if progressConns[gen] then
        progressConns[gen]:Disconnect()
        progressConns[gen] = nil
    end
end

local function watchProgress(gen)
    if progressConns[gen] then return end
    local p = gen:FindFirstChild("Progress")
    if not p then return end
    progressConns[gen] = p.Changed:Connect(function()
        if not espEnabled then return end
        if isCompleted(gen) then
            hideHighlight(gen)
        else
            ensureHighlight(gen)
        end
    end)
end

local function cleanupModel(gen)
    disconnectProgress(gen)
    if highlights[gen] then
        highlights[gen]:Destroy()
        highlights[gen] = nil
    end
end

local function startESP()
    if espLoop then return end
    espEnabled = true

    -- v√≤ng qu√©t d·ª± ph√≤ng: ƒë·ªìng b·ªô tr·∫°ng th√°i m·ªói 0.5s (fix ch·ªâ hi·ªán 1 model)
    espLoop = task.spawn(function()
        while espEnabled do
            for _, gen in ipairs(getGenerators()) do
                if isCompleted(gen) then
                    hideHighlight(gen)
                else
                    ensureHighlight(gen)
                end
                watchProgress(gen)
            end

            -- d·ªçn r√°c: n·∫øu generator bi·∫øn m·∫•t
            for gen,_ in pairs(highlights) do
                if not gen:IsDescendantOf(workspace) then
                    cleanupModel(gen)
                end
            end
            task.wait(0.5)
        end
    end)

    -- Theo d√µi spawn/remove generator ƒë·ªÉ ph·∫£n ·ª©ng nhanh
    workspace.DescendantAdded:Connect(function(obj)
        if not espEnabled then return end
        if obj:IsA("Model") and obj.Name == "Generator" then
            task.defer(function()
                if isCompleted(obj) then
                    hideHighlight(obj)
                else
                    ensureHighlight(obj)
                end
                watchProgress(obj)
            end)
        end
    end)

    workspace.DescendantRemoving:Connect(function(obj)
        if highlights[obj] or progressConns[obj] then
            cleanupModel(obj)
        end
    end)
end

local function stopESP()
    espEnabled = false
    if espLoop then
        task.cancel(espLoop)
        espLoop = nil
    end
    -- hu·ª∑ s·∫°ch ƒë·ªÉ toggle l·∫°i kh√¥ng l·ªói
    for gen,_ in pairs(progressConns) do
        disconnectProgress(gen)
    end
    for gen,_ in pairs(highlights) do
        cleanupModel(gen)
    end
end

-- ===== Toggle Fluent =====
Tabs.Visual:AddToggle("ESPGeneratorToggle", {
    Title = "ESP Generator",
    Default = false,
    Callback = function(enabled)
        local ok, err = pcall(function()
            if enabled then
                startESP()
            else
                stopESP()
            end
        end)
        if not ok then
            warn("[ESP Generator] Callback error: ", err)
        end
    end
})




local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- ESP Container cho c√°c model
local drawings = {}
local espConnection

-- Danh s√°ch model c·∫ßn theo d√µi v√† m√†u s·∫Øc
local trackedModels = {
    ["Bloxycola"] = Color3.fromRGB(139, 69, 19), -- Brown
    ["Medkit"] = Color3.fromRGB(0, 255, 0),      -- Green
}

-- T·∫°o ESP cho model v·ªõi vi·ªÅn v√† ph√°t s√°ng
local function createESP(model)
    if drawings[model] then return end

    -- Text ch√≠nh
    local text = Drawing.new("Text")
    text.Size = 16
    text.Center = true
    text.Outline = false -- T·∫Øt outline cho text ch√≠nh
    text.Color = trackedModels[model.Name] or Color3.new(1, 1, 1)
    text.Visible = false

    -- Vi·ªÅn (Outline) b·∫±ng nhi·ªÅu text nh·ªè h∆°n, offset
    local outlineTexts = {}

    local offsets = {
        Vector2.new(-1, 0),
        Vector2.new(1, 0),
        Vector2.new(0, -1),
        Vector2.new(0, 1),
        Vector2.new(-1, -1),
        Vector2.new(1, -1),
        Vector2.new(-1, 1),
        Vector2.new(1, 1),
    }

    for _, offset in ipairs(offsets) do
        local outline = Drawing.new("Text")
        outline.Size = 16
        outline.Center = true
        outline.Color = trackedModels[model.Name] or Color3.new(1, 1, 1)
        outline.Position = Vector2.new(0, 0)
        outline.Visible = false
        outline.Text = ""
        table.insert(outlineTexts, {obj = outline, offset = offset})
    end

    drawings[model] = {
        main = text,
        outlines = outlineTexts
    }
end

-- Xo√° ESP
local function removeESP(model)
    if drawings[model] then
        drawings[model].main:Remove()
        for _, outline in ipairs(drawings[model].outlines) do
            outline.obj:Remove()
        end
        drawings[model] = nil
    end
end

-- B·∫Øt ƒë·∫ßu ESP
local function startESP()
    -- T·∫°o ESP cho c√°c model ƒëang c√≥ trong workspace
    for _, model in ipairs(workspace:GetChildren()) do
        if trackedModels[model.Name] then
            createESP(model)
        end
    end

    -- L·∫Øng nghe model m·ªõi th√™m v√†o workspace
    workspace.ChildAdded:Connect(function(model)
        if trackedModels[model.Name] then
            createESP(model)
        end
    end)

    -- L·∫Øng nghe model b·ªã xo√° kh·ªèi workspace
    workspace.ChildRemoved:Connect(function(model)
        if trackedModels[model.Name] then
            removeESP(model)
        end
    end)

    -- C·∫≠p nh·∫≠t v·ªã tr√≠ v√† hi·ªÉn th·ªã ESP m·ªói frame
    espConnection = RunService.RenderStepped:Connect(function()
        for model, esp in pairs(drawings) do
            local primaryPart = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
            if primaryPart then
                local pos, visible = Camera:WorldToViewportPoint(primaryPart.Position + Vector3.new(0, 2.5, 0))
                local distance = (primaryPart.Position - Camera.CFrame.Position).Magnitude

                esp.main.Text = string.format("%s [%.0fm]", model.Name, distance)
                esp.main.Position = Vector2.new(pos.X, pos.Y)
                esp.main.Visible = visible

                for _, outline in ipairs(esp.outlines) do
                    outline.obj.Text = esp.main.Text
                    outline.obj.Position = esp.main.Position + outline.offset
                    outline.obj.Color = Color3.new(0, 0, 0) -- vi·ªÅn ƒëen r√µ h∆°n
                    outline.obj.Visible = visible
                end
            else
                esp.main.Visible = false
                for _, outline in ipairs(esp.outlines) do
                    outline.obj.Visible = false
                end
            end
        end
    end)
end

-- D·ª´ng ESP
local function stopESP()
    if espConnection then
        espConnection:Disconnect()
        espConnection = nil
    end

    for model, esp in pairs(drawings) do
        esp.main:Remove()
        for _, outline in ipairs(esp.outlines) do
            outline.obj:Remove()
        end
    end
    drawings = {}
end

-- T√≠ch h·ª£p Fluent GUI Toggle trong Tabs.Visual (ho·∫∑c Tabs.Player t√πy b·∫°n)
Tabs.Visual:AddToggle("ESPModelsToggle", {
    Title = "ESP Item Drop",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESP()
    else
        stopESP()
    end
end)



-- Tabs.Misc

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- ‚úÖ FullBright Settings
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end

    Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- s√°ng nh·∫π
    Lighting.Brightness = 4 -- gi·∫£m ƒë·ªô s√°ng t·ª´ 10 ‚Üí 4
    Lighting.GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then
        fullBrightLoop:Disconnect()
        fullBrightLoop = nil
    end

    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

-- ‚úÖ Toggle: FullBright
local FbToggle = Tabs.Misc:AddToggle("FbToggle", {
    Title = "Auto Full Bright",
    Default = false
})
FbToggle:OnChanged(function(Value)
    fullBrightEnabled = Value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

-- ‚úÖ Remove Fog Settings
local fogEnabled = false
local fogLoop

local function removeFog()
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1, 1, 1)
    end
end

local function restoreFog()
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200, 200, 200)
    end
end

-- ‚úÖ Toggle: Remove Fog
local FogToggle = Tabs.Misc:AddToggle("FogToggle", {
    Title = "Remove Fog",
    Default = false
})
FogToggle:OnChanged(function(Value)
    fogEnabled = Value
    if fogEnabled then
        removeFog()
        fogLoop = RunService.Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop = nil end
        restoreFog()
    end
end)




    Tabs.Misc:AddSection("‚Ü≥ Bypass")

-- Anti-AFK (Kh√¥ng c·∫ßn HHG n·ªØa)
local hhgThread

Tabs.Misc:AddToggle("AntiAFK", {
    Title = "Anti-AFK",
    Default = true
})
:OnChanged(function(Value)
    -- X·ª≠ l√Ω Anti-AFK Roblox
    for _, c in pairs(getconnections(game.Players.LocalPlayer.Idled)) do
        if Value then
            c:Disable()
        else
            c:Enable()
        end
    end
    
    -- HHG animation script ƒë√£ b·ªã b·ªè
    if Value then
        print("[AntiAFK] ƒê√£ b·∫≠t, HHG script b·ªã b·ªè qua.")
    else
        print("[AntiAFK] ƒê√£ t·∫Øt.")
    end
end)





Tabs.Misc:AddToggle("AntiReportScreenshot", {
    Title = "Anti-Ban [100%]",
    Default = true,
    Callback = function(state)
        -- D√πng bi·∫øn chung ƒë·ªÉ qu·∫£n l√Ω v√≤ng l·∫∑p
        if not shared.AntiBanLoop then
            shared.AntiBanLoop = {running = false, hooked = false}
        end
        local loopData = shared.AntiBanLoop

        local function hookOnce()
            -- Hook FindFirstChild
            if not loopData.hookedFind then
                local oldFind = workspace.FindFirstChild
                if typeof(oldFind) == "function" and hookfunction then
                    hookfunction(oldFind, function(self, ...)
                        local args = {...}
                        if tostring(args[1]):lower():find("screenshot") then
                            return nil
                        end
                        return oldFind(self, unpack(args))
                    end)
                    loopData.hookedFind = true
                end
            end

            -- Hook HTTP request
            if not loopData.hookedRequest then
                local oldRequest = (syn and syn.request) or request or http_request
                if hookfunction and typeof(oldRequest) == "function" then
                    hookfunction(oldRequest, function(req)
                        if req and req.Url and tostring(req.Url):lower():find("abuse") then
                            return {StatusCode = 200, Body = "Blocked"}
                        end
                        return oldRequest(req)
                    end)
                    loopData.hookedRequest = true
                end
            end
        end

        local function setFlagsOff()
            local flags = {
                "AbuseReportScreenshot",
                "AbuseReportScreenshotPercentage",
                "AbuseReportEnabled",
                "ReportAbuseMenu",
                "EnableAbuseReportScreenshot"
            }
            for _, flag in ipairs(flags) do
                if typeof(setfflag) == "function" then
                    pcall(function()
                        setfflag(flag, "False")
                    end)
                end
            end
            if typeof(setfflag) == "function" then
                setfflag("AbuseReportScreenshotPercentage", "0")
            end
        end

        local function setFlagsOn()
            if typeof(setfflag) == "function" then
                setfflag("AbuseReportScreenshot", "True")
                setfflag("AbuseReportScreenshotPercentage", "100")
            end
        end

        if state then
            hookOnce()
            setFlagsOff()
            loopData.running = true
            task.spawn(function()
                while loopData.running do
                    setFlagsOff()
                    task.wait(0.01) -- t·ªëc ƒë·ªô si√™u nhanh
                end
            end)
            print("[Anti-Ban] üõ°Ô∏è FAST protection ENABLED!")
        else
            loopData.running = false
            setFlagsOn()
            print("[Anti-Ban] ‚ö†Ô∏è Protection DISABLED.")
        end
    end
})





local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

local ActiveRemoveEffects = false

-- Danh s√°ch t√™n hi·ªáu ·ª©ng th∆∞·ªùng g·∫∑p
local effectNames = {
    "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
    "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
    "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
    "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
}

-- Danh s√°ch class hi·ªáu ·ª©ng trong Lighting
local effectClasses = {
    "BlurEffect",
    "BloomEffect",
    "SunRaysEffect",
    "DepthOfFieldEffect",
    "ColorCorrectionEffect"
}

-- H√†m xo√° hi·ªáu ·ª©ng
local function removeEffects()
    -- Xo√° hi·ªáu ·ª©ng trong Lighting
    for _, obj in pairs(Lighting:GetDescendants()) do
        if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
            obj:Destroy()
        end
    end

    -- Xo√° GUI overlay
    for _, obj in pairs(PlayerGui:GetDescendants()) do
        if table.find(effectNames, obj.Name) then
            obj:Destroy()
        elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
                if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
                    obj:Destroy()
                end
            end
        end
    end
end

-- Toggle Fluent
Tabs.Misc:AddToggle("RemoveScreenEffects", {
    Title = "Remove Effects",
    Default = true,
    Callback = function(state)
        ActiveRemoveEffects = state
        if state then
            task.spawn(function()
                while ActiveRemoveEffects do
                    removeEffects()
                    task.wait(0.5)
                end
            end)
        end
    end
})



local codeThread

Tabs.Misc:AddToggle("SafeGenTeleport", {
    Title = "Anti Killers V2",
    Default = true
})
:OnChanged(function(Value)
    if Value then
        -- B·∫≠t: t·∫£i v√† ch·∫°y code g·ªôp (Auto detect V1/V2)
        codeThread = task.spawn(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/HocSinhLop10/Fuck-LoL-Skid/refs/heads/main/TP-N.lua"))()
        end)
    else
        -- T·∫Øt: d·ª´ng loop
        _G.SafeGenTeleport = false
        if codeThread then
            task.cancel(codeThread)
            codeThread = nil
        end
    end
end)





    Tabs.Misc:AddSection("‚Ü≥ graphics")

local Lighting = game:GetService("Lighting")
local Terrain = workspace:FindFirstChildOfClass("Terrain")

local ultraEnabled = false
local lowEnabled = false

-- L∆∞u Lighting g·ªëc
local originalSettings = {}
for _, prop in ipairs({"GlobalShadows", "ShadowSoftness", "Brightness", "Ambient",
    "EnvironmentSpecularScale", "EnvironmentDiffuseScale"}) do
    originalSettings[prop] = Lighting[prop]
end

-- Skybox HDR ƒë·∫πp
local function applySkybox()
    local sky = Instance.new("Sky", Lighting)
    sky.SkyboxBk = "http://www.roblox.com/asset/?id=169210149"
    sky.SkyboxDn = "http://www.roblox.com/asset/?id=169210133"
    sky.SkyboxFt = "http://www.roblox.com/asset/?id=169210152"
    sky.SkyboxLf = "http://www.roblox.com/asset/?id=169210143"
    sky.SkyboxRt = "http://www.roblox.com/asset/?id=169210147"
    sky.SkyboxUp = "http://www.roblox.com/asset/?id=169210155"
    sky.SunAngularSize = 11
    sky.MoonAngularSize = 0
end

-- B·∫≠t Ultra 4K
local function enableUltra4K()
    Lighting.GlobalShadows = true
    Lighting.ShadowSoftness = 1
    Lighting.Brightness = 3
    Lighting.EnvironmentSpecularScale = 1
    Lighting.EnvironmentDiffuseScale = 1
    Lighting.Ambient = Color3.fromRGB(128, 128, 128)

    if Terrain then
        Terrain.WaterWaveSize = 0.2
        Terrain.WaterWaveSpeed = 15
        Terrain.WaterReflectance = 1
        Terrain.WaterTransparency = 0
    end

    applySkybox()

    local bloom = Instance.new("BloomEffect", Lighting)
    bloom.Intensity = 0.7
    bloom.Size = 56
    bloom.Threshold = 0.8

    local cc = Instance.new("ColorCorrectionEffect", Lighting)
    cc.Saturation = 0.3
    cc.Contrast = 0.2
    cc.Brightness = 0.1

    local sun = Instance.new("SunRaysEffect", Lighting)
    sun.Intensity = 0.25
    sun.Spread = 0.7

    local dof = Instance.new("DepthOfFieldEffect", Lighting)
    dof.FarIntensity = 0.2
    dof.FocusDistance = 50
    dof.InFocusRadius = 20
    dof.NearIntensity = 0.05
end

-- B·∫≠t Low Graphics
local function enableLow()
    Lighting.GlobalShadows = false
    Lighting.ShadowSoftness = 0
    Lighting.Brightness = 1
    Lighting.EnvironmentSpecularScale = 0
    Lighting.EnvironmentDiffuseScale = 0
    Lighting.Ambient = Color3.fromRGB(255, 255, 255)

    if Terrain then
        Terrain.WaterWaveSize = 0
        Terrain.WaterWaveSpeed = 0
        Terrain.WaterReflectance = 0
        Terrain.WaterTransparency = 1
    end

    for _, obj in ipairs(Lighting:GetChildren()) do
        if obj:IsA("PostEffect") or obj:IsA("Sky") then
            obj:Destroy()
        end
    end
end

-- Restore m·∫∑c ƒë·ªãnh
local function restoreDefaults()
    for k, v in pairs(originalSettings) do
        Lighting[k] = v
    end
    if Terrain then
        Terrain.WaterWaveSize = 0.1
        Terrain.WaterWaveSpeed = 10
        Terrain.WaterReflectance = 0.5
        Terrain.WaterTransparency = 0.3
    end
    for _, obj in ipairs(Lighting:GetChildren()) do
        if obj:IsA("PostEffect") or obj:IsA("Sky") then
            obj:Destroy()
        end
    end
end

-- Toggle Fluent
Tabs.Misc:AddToggle("Ultra4KToggle", {
    Title = "Ultra Graphics",
    Default = false,
    Callback = function(state)
        if state then
            ultraEnabled = true
            if lowEnabled then
                lowEnabled = false
                restoreDefaults()
            end
            enableUltra4K()
        else
            ultraEnabled = false
            restoreDefaults()
        end
    end
})

Tabs.Misc:AddToggle("LowGraphicsToggle", {
    Title = "Low Graphics",
    Default = false,
    Callback = function(state)
        if state then
            lowEnabled = true
            if ultraEnabled then
                ultraEnabled = false
                restoreDefaults()
            end
            enableLow()
        else
            lowEnabled = false
            restoreDefaults()
        end
    end
})



    Tabs.Misc:AddSection("‚Ü≥ Show")

-- FPS + Ping Drawing Setup
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- Update FPS
        if showFPS then
            fpsText.Text = "FPS: " .. tostring(fpsCounter)
            fpsText.Visible = true
        else
            fpsText.Visible = false
        end

        -- Update Ping
        if showPing then
            local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
            local ping = pingStat and math.floor(pingStat:GetValue()) or 0
            msText.Text = "Ping: " .. ping .. " ms"

            if ping <= 60 then
                msText.Color = Color3.fromRGB(0, 255, 0)
            elseif ping <= 120 then
                msText.Color = Color3.fromRGB(255, 165, 0)
            else
                msText.Color = Color3.fromRGB(255, 0, 0)
            end

            msText.Visible = true
        else
            msText.Visible = false
        end

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ‚úÖ Fluent GUI Toggles chu·∫©n
local fpsToggle = Tabs.Misc:AddToggle("ShowFPSToggle", {
    Title = "Show FPS",
    Default = true
})
fpsToggle:OnChanged(function(val)
    showFPS = val
    fpsText.Visible = val
end)

local pingToggle = Tabs.Misc:AddToggle("ShowPingToggle", {
    Title = "Show Ping",
    Default = true
})
pingToggle:OnChanged(function(val)
    showPing = val
    msText.Visible = val
end)

-- Tabs.Settings


local AexecToggle = Tabs.Settings:AddToggle("AexecToggle", {Title = "Auto Execute", Default = false })
AexecToggle:OnChanged(function(Value)
    if Value then
        task.spawn(function()
            pcall(function()
                if queue_on_teleport then
                    local HutaoHubScript1 = [[
task.wait(3)
loadstring(game:HttpGet('https://raw.githubusercontent.com/SLK-gaming/Hutao-Hub/refs/heads/main/Forsaken-v2.txt'))()
]]
                    queue_on_teleport(HutaoHubScript1)
                end
            end)
        end)
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is enabled!",
            Duration = 5
        })
    else
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is disabled!",
            Duration = 5
        })
    end
end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("Hutao HUB")
SaveManager:SetFolder("Hutao HUB/Forsaken")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Select First Tab By Default
Window:SelectTab(1)

Fluent:Notify({ Title = "Hutao HUB", Content = "forsaken script loaded successfully!", Duration = 5 })
SaveManager:LoadAutoloadConfig()


-- üü¢ DRAGGABLE UI BUTTON WITH ENHANCED CLICK AND HOVER ANIMATIONS
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local ExistingUI = CoreGui:FindFirstChild("HutaoHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

-- Create Floating UI
local DragUI = Instance.new("ScreenGui")
DragUI.Name = "HutaoHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Ensures highest rendering priority
DragUI.Parent = CoreGui -- Overrides all other UI elements

-- Create Circular Button (Draggable + Clickable)
local Button = Instance.new("ImageButton")
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50) -- Adjust size if needed
Button.Position = UDim2.new(0, 10, 1, -85) -- Initial position
Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Windows 11 Style
Button.BackgroundTransparency = 0.3 -- Semi-transparent
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Image = "rbxassetid://90508203972003" -- Replace with your custom image ID
Button.ScaleType = Enum.ScaleType.Fit
Button.Active = true -- Allows drag functionality
Button.ZIndex = 1000 -- Ensure it stays on top

-- Make UI Circular
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0) -- Full circle
UICorner.Parent = Button

-- Tween Info for Animations
local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

-- Function to simulate RightShift key press
local function SimulateKeyPress()
    VirtualInputManager:SendKeyEvent(true, minimizeUI, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, minimizeUI, false, game)
end

-- Click Animation & UI Toggle (Only if NOT dragged too much)
local isDragging = false
local dragThreshold = 10 -- Allow small movement without canceling click

Button.MouseButton1Click:Connect(function()
    if isDragging then return end -- Prevent click after large dragging

    -- Enhanced Click Animation
    local tween = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.5,
        Size = UDim2.new(0, 45, 0, 45),
        Rotation = 5
    })
    tween:Play()
    task.wait(0.1)
    local tweenBack = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.3,
        Size = UDim2.new(0, 50, 0, 50),
        Rotation = 0
    })
    tweenBack:Play()

    -- Simulate RightShift to Toggle UI
    SimulateKeyPress()
end)

-- Hover Animation
Button.MouseEnter:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
end)

Button.MouseLeave:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
end)

-- Dragging Logic for PC & Mobile
local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false -- Reset dragging state
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then -- Only mark as dragged if movement exceeds threshold
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

-- Dragging Support for PC & Mobile (on the same button)
Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)