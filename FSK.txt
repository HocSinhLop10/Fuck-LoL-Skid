--[[

 _   _    _   _   _____     _       ___     _   _   _   _   ____   
| | | |  | | | | |_   _|   / \     / _ \   | | | | | | | | | __ )  
| |_| |  | | | |   | |    / _ \   | | | |  | |_| | | | | | |  _ \  
|  _  |  | | | |   | |   / ___ \  | |_| |  |  _  | | |_| | | |_) | 
\_| |_/   \___/    \_/  /_/   \_\  \___/   \_| |_/  \___/  |____/

                        Hutao Hub
]]

---------------------------------------------------------------------------------

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/SaveManager.lua.txt"))()

local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/InterfaceManager.lua.txt"))()

local minimizeUI = Enum.KeyCode.RightAlt

-- 🟢 Create Main UI
local Window = Fluent:CreateWindow({
    Title = "Hutao Hub [Free] | Forsaken",
    SubTitle = "Version 2.0.0",
    TabWidth = 160,
    Size = UDim2.fromOffset(480, 360),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = minimizeUI
})

-- Tabs
local Tabs = {
    Dev = Window:AddTab({ Title = "About", Icon = "rbxassetid://121302760641013"}),
    Main = Window:AddTab({ Title = "Main", Icon = "rbxassetid://121302760641013" }),
    Player = Window:AddTab({ Title = "Player", Icon = "rbxassetid://121302760641013" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "rbxassetid://121302760641013" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "rbxassetid://121302760641013" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "rbxassetid://121302760641013" }),
}  

-- Tab.Dev

local Options = Fluent.Options


    Tabs.Dev:AddParagraph({
        Title = "Note",
        Content = "Thank you for using the script!"
    })

    Tabs.Dev:AddSection("↳ Links")

    Tabs.Dev:AddButton({
        Title = "Discord",
        Description = "Copy the link to join the discord!",
        Callback = function()
            setclipboard("https://discord.gg/REdfuQTw")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })



    Tabs.Dev:AddButton({
        Title = "Youtube",
        Description = "Copy link to Subscribe to Youtube channel!",
        Callback = function()
            setclipboard("https://www.youtube.com/@SLKgamingSSR")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })


    Tabs.Dev:AddButton({
        Title = "Facebook",
        Description = "Copy link to join facebook group!",
        Callback = function()
            setclipboard("https://www.facebook.com/groups/1180845463307087/?ref=share&mibextid=NSMWBT")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })

-- Tabs.Main

-- Giả sử Tabs đã khai báo sẵn
-- local Tabs = ...

local solveGeneratorCooldown = false
local AutoFinishGen = false
local autoLoop

-- Hàm tìm generator gần nhất (dùng chung)
local function getClosestGenerator()
    local char = game.Players.LocalPlayer.Character
    if not char or not char.PrimaryPart then return nil end

    local root = char.PrimaryPart
    local closest, shortestDist = nil, math.huge

    local mapContainer = workspace:FindFirstChild("Map")
    if mapContainer then
        local ingame = mapContainer:FindFirstChild("Ingame")
        if ingame then
            local map = ingame:FindFirstChild("Map")
            if map then
                for _, obj in ipairs(map:GetChildren()) do
                    if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                        local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                        if dist < shortestDist then
                            closest = obj
                            shortestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closest
end

-- Nút Finish generator thủ công
Tabs.Main:AddButton({
    Title = "Finish Generator",
    Callback = function()
        if solveGeneratorCooldown then 
            print("Please wait before trying again!") -- hoặc fu.notification()
            return
        end
        if AutoFinishGen then
            print("Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(10, function()
                solveGeneratorCooldown = false
            end)
        end
    end
})

-- Toggle Auto Finish Generator
Tabs.Main:AddToggle("AutoFinishGen", {
    Title = "Auto Finish Generator",
    Default = false
}):OnChanged(function(state)
    AutoFinishGen = state

    if state then
        if solveGeneratorCooldown then
            print("Please wait cooldown to finish before enabling Auto Finish!") -- hoặc fu.notification()
            AutoFinishGen = false
            Tabs.Main:Set("AutoFinishGen", false) -- tắt toggle UI
            return
        end

        autoLoop = task.spawn(function()
            while AutoFinishGen do
                local gen = getClosestGenerator()
                if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                    gen.Remotes.RE:FireServer()
                end
                solveGeneratorCooldown = true
                task.wait(5)
                solveGeneratorCooldown = false
            end
        end)
    else
        if autoLoop then
            task.cancel(autoLoop)
            autoLoop = nil
        end
        solveGeneratorCooldown = false
    end
end)


-- Tabs.Player

-- Forsaken Player Aimlock with Fluent GUI Toggle
-- Open Source by ChatGPT
if not game:IsLoaded() then game.Loaded:Wait() end

-- ======= DỊCH VỤ =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ======= WHITELIST MODEL =======
local AllowedModels = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
}

-- ======= BIẾN TRẠNG THÁI =======
local AimlockEnabled = false
local Target = nil

-- ======= HÀM KIỂM TRA MODEL =======
local function IsAllowedModel(model)
    return AllowedModels[model.Name] == true
end

-- ======= LẤY MODEL FORSAKEN =======
local function GetPlayerModel(plr)
    if not plr.Character then return nil end
    if IsAllowedModel(plr.Character) then
        return plr.Character
    end
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
            if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                if IsAllowedModel(model) then
                    return model
                end
            end
        end
    end
    return nil
end

-- ======= LẤY MỤC TIÊU GẦN NHẤT =======
local function GetClosestTarget()
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local model = GetPlayerModel(plr)
            if model and model.PrimaryPart then
                local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                if distance < dist then
                    dist = distance
                    closest = model
                end
            end
        end
    end
    return closest
end

-- ======= AIMLOCK LOOP =======
RunService.RenderStepped:Connect(function()
    if AimlockEnabled then
        if not Target or not Target.Parent then
            Target = GetClosestTarget()
        end
        if Target and Target.PrimaryPart then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Target.PrimaryPart.Position)
        end
    end
end)

-- ======= FLUENT GUI TOGGLE =======
-- Giả sử bạn đã có biến Tabs.Player trong Fluent UI
Tabs.Player:AddToggle("ForsakenAimlock", {
    Title = "Aimlock Player",
    Default = false
}):OnChanged(function(Value)
    AimlockEnabled = Value
    if not Value then
        Target = nil
    end
end)

local StaminaModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
local InfStaminaEnabled = false
local staminaLoop

pcall(function() -- Chặn lỗi từ Fluent UI
    Tabs.Player:AddToggle("InfStamina", {
        Title = "Infinite Stamina",
        Default = false
    })
    :OnChanged(function(value)
        pcall(function() -- Chặn lỗi khi chạy
            InfStaminaEnabled = value
            StaminaModule.StaminaLossDisabled = value

            if value then
                -- Hồi ngay khi bật
                StaminaModule.Stamina = StaminaModule.MaxStamina
                StaminaModule.StaminaChanged:Fire()

                -- Nếu chưa có loop thì mới tạo
                if not staminaLoop then
                    staminaLoop = task.spawn(function()
                        while InfStaminaEnabled do
                            task.wait(0.5) -- hồi mỗi 0.5s
                            StaminaModule.Stamina = StaminaModule.MaxStamina
                            StaminaModule.StaminaChanged:Fire()
                        end
                        staminaLoop = nil -- khi tắt xong thì giải phóng
                    end)
                end
            else
                -- Khi tắt thì chỉ cần đặt flag false, loop sẽ tự dừng
                InfStaminaEnabled = false
            end
        end)
    end)
end)

-- Tabs.Visual

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- 📌 Danh sách model cho ESP trắng
local allowedModelsWhite = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
}

-- 📌 Danh sách model cho ESP đỏ
local allowedModelsRed = {
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- Internal containers
local drawingsWhite = {}
local drawingsRed = {}
local espConnectionWhite, espConnectionRed
local addedConnWhite, removedConnWhite
local addedConnRed, removedConnRed

-- Tạo ESP (màu tuỳ chọn)
local function createESP(model, drawings, color)
    if not model or drawings[model] then return end
    local hrp = model:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Visible = false
    text.Color = color

    drawings[model] = text
end

-- Xoá ESP
local function removeESP(model, drawings)
    if drawings[model] then
        pcall(function() drawings[model]:Remove() end)
        drawings[model] = nil
    end
end

-- Quét workspace và tạo ESP
local function scanWorkspaceForAllowed(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
            createESP(obj, drawings, color)
        end
    end
end

-- Bắt đầu ESP (màu tuỳ chọn)
local function startESP(allowedList, drawings, espConnectionVar, addedConnVar, removedConnVar, color)
    if espConnectionVar then return end
    scanWorkspaceForAllowed(allowedList, drawings, color)

    espConnectionVar = RunService.RenderStepped:Connect(function()
        for model, text in pairs(drawings) do
            if not model or not model.Parent or not model:FindFirstChild("HumanoidRootPart") then
                text.Visible = false
            else
                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude
                text.Text = string.format("%s [%.0fm]", model.Name, dist)
                text.Position = Vector2.new(pos.X, pos.Y)
                text.Visible = onScreen
            end
        end
    end)

    addedConnVar = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedList[model.Name] and model:FindFirstChild("HumanoidRootPart") then
            createESP(model, drawings, color)
        end
    end)

    removedConnVar = workspace.DescendantRemoving:Connect(function(obj)
        if obj:IsA("Model") and drawings[obj] then
            removeESP(obj, drawings)
        end
    end)

    return espConnectionVar, addedConnVar, removedConnVar
end

-- Dừng ESP
local function stopESP(drawings, espConnectionVar, addedConnVar, removedConnVar)
    if espConnectionVar then espConnectionVar:Disconnect() end
    if addedConnVar then addedConnVar:Disconnect() end
    if removedConnVar then removedConnVar:Disconnect() end
    for _, text in pairs(drawings) do
        pcall(function() text:Remove() end)
    end
    table.clear(drawings)
    return nil, nil, nil
end

Tabs.Visual:AddToggle("ESPModelWhiteToggle", {
    Title = "ESP Player",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        espConnectionWhite, addedConnWhite, removedConnWhite =
            startESP(allowedModelsWhite, drawingsWhite, espConnectionWhite, addedConnWhite, removedConnWhite, Color3.fromRGB(255, 255, 255))
    else
        espConnectionWhite, addedConnWhite, removedConnWhite =
            stopESP(drawingsWhite, espConnectionWhite, addedConnWhite, removedConnWhite)
    end
end)

Tabs.Visual:AddToggle("ESPModelRedToggle", {
    Title = "ESP Killer",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        espConnectionRed, addedConnRed, removedConnRed =
            startESP(allowedModelsRed, drawingsRed, espConnectionRed, addedConnRed, removedConnRed, Color3.fromRGB(255, 0, 0))
    else
        espConnectionRed, addedConnRed, removedConnRed =
            stopESP(drawingsRed, espConnectionRed, addedConnRed, removedConnRed)
    end
end)



-- ESP Highlight cho model "Generator"
local RunService = game:GetService("RunService")
local allowedName = "Generator"
local highlights = {}
local espConnection, addedConn, removedConn

-- Tạo highlight cho model
local function createHighlight(model)
    if not model or highlights[model] then return end
    if not model:IsA("Model") then return end

    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 255, 255)    -- Màu trắng
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255) -- Viền trắng
    highlight.FillTransparency = 0.5                       -- Độ trong suốt bên trong
    highlight.OutlineTransparency = 0                      -- Viền rõ nét
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model

    highlights[model] = highlight
end

-- Xoá highlight
local function removeHighlight(model)
    if highlights[model] then
        highlights[model]:Destroy()
        highlights[model] = nil
    end
end

-- Quét tất cả model hiện tại
local function scanWorkspace()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj.Name == allowedName then
            createHighlight(obj)
        end
    end
end

-- Bắt đầu ESP
local function startESP()
    scanWorkspace()

    addedConn = workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Model") and obj.Name == allowedName then
            createHighlight(obj)
        end
    end)

    removedConn = workspace.DescendantRemoving:Connect(function(obj)
        if highlights[obj] then
            removeHighlight(obj)
        end
    end)
end

-- Dừng ESP
local function stopESP()
    if addedConn then addedConn:Disconnect() addedConn = nil end
    if removedConn then removedConn:Disconnect() removedConn = nil end

    for model, hl in pairs(highlights) do
        hl:Destroy()
    end
    table.clear(highlights)
end

-- ==========================
-- TÍCH HỢP FLUENT GUI Toggle
-- ==========================
Tabs.Visual:AddToggle("ESPGeneratorToggle", {
    Title = "ESP Generator",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESP()
    else
        stopESP()
    end
end)



local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Danh sách model được phép ESP
local allowedModels = {
    ["Medkit"] = true,
    ["Bloxy Cola"] = true,
    ["BloxyCola"] = true
}

-- Internal
local drawings = {}
local espConnection, addedConn, removedConn
local defaultColor = Color3.fromRGB(0, 255, 0) -- Xanh lá mặc định

-- Tạo ESP cho model
local function createESP(model)
    if not model or drawings[model] then return end
    if not model:IsA("Model") or not model:FindFirstChild("HumanoidRootPart") then return end

    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Visible = false
    text.Color = defaultColor

    drawings[model] = text
end

-- Xoá ESP
local function removeESP(model)
    if drawings[model] then
        drawings[model]:Remove()
        drawings[model] = nil
    end
end

-- Quét workspace để tạo ESP
local function scanWorkspace()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedModels[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
            createESP(obj)
        end
    end
end

-- Bắt đầu ESP
local function startESP()
    scanWorkspace()

    espConnection = RunService.RenderStepped:Connect(function()
        for model, text in pairs(drawings) do
            if not model or not model.Parent or not model:FindFirstChild("HumanoidRootPart") then
                text.Visible = false
            else
                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude
                text.Text = string.format("%s [%.0fm]", model.Name, dist)
                text.Position = Vector2.new(pos.X, pos.Y)
                text.Visible = onScreen
            end
        end
    end)

    addedConn = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedModels[model.Name] and model:FindFirstChild("HumanoidRootPart") then
            createESP(model)
        end
    end)

    removedConn = workspace.DescendantRemoving:Connect(function(obj)
        if obj:IsA("Model") and drawings[obj] then
            removeESP(obj)
        end
    end)
end

-- Dừng ESP
local function stopESP()
    if espConnection then espConnection:Disconnect() espConnection = nil end
    if addedConn then addedConn:Disconnect() addedConn = nil end
    if removedConn then removedConn:Disconnect() removedConn = nil end

    for _, text in pairs(drawings) do
        text:Remove()
    end
    drawings = {}
end

-- ==========================
-- TÍCH HỢP FLUENT GUI Toggle
-- ==========================
Tabs.Visual:AddToggle("ESPMedkitBloxyToggle", {
    Title = "ESP Tool",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESP()
    else
        stopESP()
    end
end)


-- Tabs.Misc

    local UIS = game:GetService("UserInputService")
    local SkipHoldToggle = Tabs.Misc:AddToggle("SkipHoldToggle", {Title = "Bypass Hold Prompt", Default = false})

    local function skipHoldPrompt(prompt)
        if prompt and prompt:IsA("ProximityPrompt") and prompt.HoldDuration > 0 then
            -- Store original HoldDuration if not already stored
            if prompt:GetAttribute("OriginalHold") == nil then
                prompt:SetAttribute("OriginalHold", prompt.HoldDuration)
            end
            prompt.HoldDuration = 0 -- Remove hold time
        end
    end

    local function enableSkipHold()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("ProximityPrompt") then
                skipHoldPrompt(obj)
            end
        end

        -- Ensure new prompts also get modified
        local connection
        connection = workspace.DescendantAdded:Connect(function(obj)
            task.wait(0.1) -- Prevent errors
            if SkipHoldToggle.Value then
                skipHoldPrompt(obj)
            else
                connection:Disconnect() -- Stop listening if disabled
            end
        end)
    end

    local function disableSkipHold()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("ProximityPrompt") then
                local originalHold = obj:GetAttribute("OriginalHold")
                if originalHold then
                    obj.HoldDuration = originalHold -- Restore original HoldDuration
                    obj:SetAttribute("OriginalHold", nil) -- Remove stored attribute
                end
            end
        end
    end

    SkipHoldToggle:OnChanged(function()
        if SkipHoldToggle.Value then
            enableSkipHold()
        else
            disableSkipHold()
        end
    end)


-- Tabs.Misc

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- ✅ FullBright Settings
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end

    Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- sáng nhẹ
    Lighting.Brightness = 4 -- giảm độ sáng từ 10 → 4
    Lighting.GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then
        fullBrightLoop:Disconnect()
        fullBrightLoop = nil
    end

    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

-- ✅ Toggle: FullBright
local FbToggle = Tabs.Misc:AddToggle("FbToggle", {
    Title = "Auto Full Bright",
    Default = false
})
FbToggle:OnChanged(function(Value)
    fullBrightEnabled = Value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

-- ✅ Remove Fog Settings
local fogEnabled = false
local fogLoop

local function removeFog()
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1, 1, 1)
    end
end

local function restoreFog()
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200, 200, 200)
    end
end

-- ✅ Toggle: Remove Fog
local FogToggle = Tabs.Misc:AddToggle("FogToggle", {
    Title = "Remove Fog",
    Default = false
})
FogToggle:OnChanged(function(Value)
    fogEnabled = Value
    if fogEnabled then
        removeFog()
        fogLoop = RunService.Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop = nil end
        restoreFog()
    end
end)


    Tabs.Misc:AddSection("↳ Show")

-- FPS + Ping Drawing Setup
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- Update FPS
        if showFPS then
            fpsText.Text = "FPS: " .. tostring(fpsCounter)
            fpsText.Visible = true
        else
            fpsText.Visible = false
        end

        -- Update Ping
        if showPing then
            local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
            local ping = pingStat and math.floor(pingStat:GetValue()) or 0
            msText.Text = "Ping: " .. ping .. " ms"

            if ping <= 60 then
                msText.Color = Color3.fromRGB(0, 255, 0)
            elseif ping <= 120 then
                msText.Color = Color3.fromRGB(255, 165, 0)
            else
                msText.Color = Color3.fromRGB(255, 0, 0)
            end

            msText.Visible = true
        else
            msText.Visible = false
        end

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ✅ Fluent GUI Toggles chuẩn
local fpsToggle = Tabs.Misc:AddToggle("ShowFPSToggle", {
    Title = "Show FPS",
    Default = true
})
fpsToggle:OnChanged(function(val)
    showFPS = val
    fpsText.Visible = val
end)

local pingToggle = Tabs.Misc:AddToggle("ShowPingToggle", {
    Title = "Show Ping",
    Default = true
})
pingToggle:OnChanged(function(val)
    showPing = val
    msText.Visible = val
end)

-- Tabs.Settings


local AexecToggle = Tabs.Settings:AddToggle("AexecToggle", {Title = "Auto Execute", Default = false })
AexecToggle:OnChanged(function(Value)
    if Value then
        task.spawn(function()
            pcall(function()
                if queue_on_teleport then
                    local HutaoHubScript1 = [[
task.wait(3)
loadstring(game:HttpGet('https://raw.githubusercontent.com/hungquan99/SkullHub/main/loader.lua'))()
]]
                    queue_on_teleport(HutaoHubScript1)
                end
            end)
        end)
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is enabled!",
            Duration = 5
        })
    else
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is disabled!",
            Duration = 5
        })
    end
end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("Hutao HUB")
SaveManager:SetFolder("Hutao HUB/Forsaken")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Select First Tab By Default
Window:SelectTab(1)

Fluent:Notify({ Title = "Hutao HUB", Content = "forsaken script loaded successfully!", Duration = 5 })
SaveManager:LoadAutoloadConfig()


-- 🟢 DRAGGABLE UI BUTTON WITH ENHANCED CLICK AND HOVER ANIMATIONS
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local ExistingUI = CoreGui:FindFirstChild("HutaoHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

-- Create Floating UI
local DragUI = Instance.new("ScreenGui")
DragUI.Name = "HutaoHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Ensures highest rendering priority
DragUI.Parent = CoreGui -- Overrides all other UI elements

-- Create Circular Button (Draggable + Clickable)
local Button = Instance.new("ImageButton")
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50) -- Adjust size if needed
Button.Position = UDim2.new(0, 10, 1, -85) -- Initial position
Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Windows 11 Style
Button.BackgroundTransparency = 0.3 -- Semi-transparent
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Image = "rbxassetid://90508203972003" -- Replace with your custom image ID
Button.ScaleType = Enum.ScaleType.Fit
Button.Active = true -- Allows drag functionality
Button.ZIndex = 1000 -- Ensure it stays on top

-- Make UI Circular
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0) -- Full circle
UICorner.Parent = Button

-- Tween Info for Animations
local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

-- Function to simulate RightShift key press
local function SimulateKeyPress()
    VirtualInputManager:SendKeyEvent(true, minimizeUI, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, minimizeUI, false, game)
end

-- Click Animation & UI Toggle (Only if NOT dragged too much)
local isDragging = false
local dragThreshold = 10 -- Allow small movement without canceling click

Button.MouseButton1Click:Connect(function()
    if isDragging then return end -- Prevent click after large dragging

    -- Enhanced Click Animation
    local tween = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.5,
        Size = UDim2.new(0, 45, 0, 45),
        Rotation = 5
    })
    tween:Play()
    task.wait(0.1)
    local tweenBack = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.3,
        Size = UDim2.new(0, 50, 0, 50),
        Rotation = 0
    })
    tweenBack:Play()

    -- Simulate RightShift to Toggle UI
    SimulateKeyPress()
end)

-- Hover Animation
Button.MouseEnter:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
end)

Button.MouseLeave:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
end)

-- Dragging Logic for PC & Mobile
local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false -- Reset dragging state
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then -- Only mark as dragged if movement exceeds threshold
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

-- Dragging Support for PC & Mobile (on the same button)
Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)      
