--[[

 _   _    _   _   _____     _       ___     _   _   _   _   ____   
| | | |  | | | | |_   _|   / \     / _ \   | | | | | | | | | __ )  
| |_| |  | | | |   | |    / _ \   | | | |  | |_| | | | | | |  _ \  
|  _  |  | | | |   | |   / ___ \  | |_| |  |  _  | | |_| | | |_) | 
\_| |_/   \___/    \_/  /_/   \_\  \___/   \_| |_/  \___/  |____/

                        Hutao Hub
]]

---------------------------------------------------------------------------------

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/SaveManager.lua.txt"))()

local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/InterfaceManager.lua.txt"))()

local minimizeUI = Enum.KeyCode.RightAlt

-- üü¢ Create Main UI
local Window = Fluent:CreateWindow({
    Title = "Hutao Hub [Free] | Forsaken",
    SubTitle = "Version 2.2.0",
    TabWidth = 160,
    Size = UDim2.fromOffset(480, 360),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = minimizeUI
})

-- Tabs
local Tabs = {
    Dev = Window:AddTab({ Title = "About", Icon = "rbxassetid://121302760641013"}),
    Main = Window:AddTab({ Title = "Main", Icon = "rbxassetid://121302760641013" }),
    Player = Window:AddTab({ Title = "Player", Icon = "rbxassetid://121302760641013" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "rbxassetid://121302760641013" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "rbxassetid://121302760641013" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "rbxassetid://121302760641013" }),
}  

-- Tab.Dev

local Options = Fluent.Options


    Tabs.Dev:AddParagraph({
        Title = "Note",
        Content = "Thank you for using the script!"
    })

    Tabs.Dev:AddSection("‚Ü≥ Links")

    Tabs.Dev:AddButton({
        Title = "Discord",
        Description = "Copy the link to join the discord!",
        Callback = function()
            setclipboard("https://discord.gg/REdfuQTw")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })



    Tabs.Dev:AddButton({
        Title = "Youtube",
        Description = "Copy link to Subscribe to Youtube channel!",
        Callback = function()
            setclipboard("https://www.youtube.com/@SLKgamingSSR")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })


    Tabs.Dev:AddButton({
        Title = "Facebook",
        Description = "Copy link to join facebook group!",
        Callback = function()
            setclipboard("https://www.facebook.com/groups/1180845463307087/?ref=share&mibextid=NSMWBT")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })

-- Tabs.Main

-- Gi·∫£ s·ª≠ Tabs ƒë√£ khai b√°o s·∫µn
-- local Tabs = ...

local solveGeneratorCooldown = false
local AutoFinishGen = false
local autoLoop

-- H√†m t√¨m generator g·∫ßn nh·∫•t (d√πng chung)
local function getClosestGenerator()
    local char = game.Players.LocalPlayer.Character
    if not char or not char.PrimaryPart then return nil end

    local root = char.PrimaryPart
    local closest, shortestDist = nil, math.huge

    local mapContainer = workspace:FindFirstChild("Map")
    if mapContainer then
        local ingame = mapContainer:FindFirstChild("Ingame")
        if ingame then
            local map = ingame:FindFirstChild("Map")
            if map then
                for _, obj in ipairs(map:GetChildren()) do
                    if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                        local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                        if dist < shortestDist then
                            closest = obj
                            shortestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closest
end

-- N√∫t Finish generator th·ªß c√¥ng
Tabs.Main:AddButton({
    Title = "Finish Generator",
    Callback = function()
        if solveGeneratorCooldown then 
            print("Please wait before trying again!") -- ho·∫∑c fu.notification()
            return
        end
        if AutoFinishGen then
            print("Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(10, function()
                solveGeneratorCooldown = false
            end)
        end
    end
})

-- Toggle Auto Finish Generator
Tabs.Main:AddToggle("AutoFinishGen", {
    Title = "Auto Finish Generator",
    Default = false
}):OnChanged(function(state)
    AutoFinishGen = state

    if state then
        if solveGeneratorCooldown then
            print("Please wait cooldown to finish before enabling Auto Finish!") -- ho·∫∑c fu.notification()
            AutoFinishGen = false
            Tabs.Main:Set("AutoFinishGen", false) -- t·∫Øt toggle UI
            return
        end

        autoLoop = task.spawn(function()
            while AutoFinishGen do
                local gen = getClosestGenerator()
                if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                    gen.Remotes.RE:FireServer()
                end
                solveGeneratorCooldown = true
                task.wait(2.5)
                solveGeneratorCooldown = false
            end
        end)
    else
        if autoLoop then
            task.cancel(autoLoop)
            autoLoop = nil
        end
        solveGeneratorCooldown = false
    end
end)


local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RemoteEvent = ReplicatedStorage.Modules.Network.RemoteEvent

local ActiveAutoUseCoinFlip = false
local coinFlipLoop

Tabs.Main:AddToggle("AutoUseCoinFlip", {
    Title = "Auto Flip Coin (Chance)",
    Default = false,
}):OnChanged(function(value)
    ActiveAutoUseCoinFlip = value

    if value then
        -- N·∫øu ƒë√£ c√≥ loop c≈© th√¨ h·ªßy ƒë·ªÉ tr√°nh tr√πng l·∫∑p
        if coinFlipLoop then
            task.cancel(coinFlipLoop)
            coinFlipLoop = nil
        end

        -- B·∫Øt ƒë·∫ßu loop g·ª≠i s·ª± ki·ªán m·ªói 1 gi√¢y
        coinFlipLoop = task.spawn(function()
            while ActiveAutoUseCoinFlip do
                pcall(function()
                    RemoteEvent:FireServer("UseActorAbility", "CoinFlip")
                end)
                task.wait(1)
            end
        end)
    else
        -- Khi t·∫Øt toggle th√¨ h·ªßy loop
        if coinFlipLoop then
            task.cancel(coinFlipLoop)
            coinFlipLoop = nil
        end
    end
end)


-- Tabs.Player

-- Forsaken Player Aimlock with Fluent GUI Toggle (Fix: Switch to nearest, skip dead)
if not game:IsLoaded() then game.Loaded:Wait() end

-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ======= WHITELIST MODEL =======
local AllowedModels = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local AimlockEnabled = false

-- ======= H√ÄM KI·ªÇM TRA MODEL =======
local function IsAllowedModel(model)
    return AllowedModels[model.Name] == true
end

-- ======= L·∫§Y MODEL FORSAKEN =======
local function GetPlayerModel(plr)
    if not plr.Character then return nil end
    if IsAllowedModel(plr.Character) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
        return plr.Character
    end
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
            if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                if IsAllowedModel(model) then
                    return model
                end
            end
        end
    end
    return nil
end

-- ======= L·∫§Y M·ª§C TI√äU G·∫¶N NH·∫§T =======
local function GetClosestTarget()
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local model = GetPlayerModel(plr)
            if model and model.PrimaryPart then
                local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health > 0 then -- b·ªè qua model ch·∫øt
                    local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                    if distance < dist then
                        dist = distance
                        closest = model
                    end
                end
            end
        end
    end
    return closest
end

-- ======= AIMLOCK LOOP =======
RunService.RenderStepped:Connect(function()
    if AimlockEnabled then
        local newTarget = GetClosestTarget()
        if newTarget then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, newTarget.PrimaryPart.Position)
        end
    end
end)

-- ======= FLUENT GUI TOGGLE =======
Tabs.Player:AddToggle("ForsakenAimlock", {
    Title = "Aimlock Player",
    Default = false
}):OnChanged(function(Value)
    AimlockEnabled = Value
end)





-- Auto Aim Killer To Shoot 
if not game:IsLoaded() then game.Loaded:Wait() end

-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ======= WHITELIST MODEL =======
local AllowedModels = {
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local AimlockEnabled = false

-- ======= H√ÄM KI·ªÇM TRA MODEL =======
local function IsAllowedModel(model)
    return AllowedModels[model.Name] == true
end

-- ======= L·∫§Y MODEL FORSAKEN =======
local function GetPlayerModel(plr)
    if not plr.Character then return nil end
    if IsAllowedModel(plr.Character) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
        return plr.Character
    end
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
            if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                if IsAllowedModel(model) then
                    return model
                end
            end
        end
    end
    return nil
end

-- ======= L·∫§Y M·ª§C TI√äU G·∫¶N NH·∫§T =======
local function GetClosestTarget()
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local model = GetPlayerModel(plr)
            if model and model.PrimaryPart then
                local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health > 0 then -- b·ªè qua model ch·∫øt
                    local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                    if distance < dist then
                        dist = distance
                        closest = model
                    end
                end
            end
        end
    end
    return closest
end

-- ======= AIMLOCK LOOP =======
RunService.RenderStepped:Connect(function()
    if AimlockEnabled then
        local newTarget = GetClosestTarget()
        if newTarget then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, newTarget.PrimaryPart.Position)
        end
    end
end)

-- ======= FLUENT GUI TOGGLE =======
Tabs.Player:AddToggle("ForsakenAimlock1", {
    Title = "Aimlock Killer",
    Default = false
}):OnChanged(function(Value)
    AimlockEnabled = Value
end)




    Tabs.Player:AddSection("‚Ü≥ Cheats")


local ActiveNoStun = false
local noStunLoop

Tabs.Player:AddToggle("NoStunToggle", {
    Title = "No Stun",
    Default = false,
}):OnChanged(function(value)
    ActiveNoStun = value

    if value then
        -- N·∫øu c√≥ loop c≈© th√¨ d·ª´ng
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end

        -- T·∫°o loop m·ªõi li√™n t·ª•c ƒë·∫£m b·∫£o HumanoidRootPart kh√¥ng b·ªã anchore
        noStunLoop = task.spawn(function()
            while ActiveNoStun do
                local character = game.Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
                task.wait(0.1) -- Kh√¥ng c·∫ßn qu√° nhanh, tr√°nh lag
            end
        end)
    else
        -- T·∫Øt loop khi toggle off
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end
    end
end)


local StaminaModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
local InfStaminaEnabled = false
local staminaLoop

pcall(function() -- Ch·∫∑n l·ªói t·ª´ Fluent UI
    Tabs.Player:AddToggle("InfStamina", {
        Title = "Infinite Stamina",
        Default = false
    })
    :OnChanged(function(value)
        pcall(function() -- Ch·∫∑n l·ªói khi ch·∫°y
            InfStaminaEnabled = value
            StaminaModule.StaminaLossDisabled = value

            if value then
                -- H·ªìi ngay khi b·∫≠t
                StaminaModule.Stamina = StaminaModule.MaxStamina
                StaminaModule.StaminaChanged:Fire()

                -- N·∫øu ch∆∞a c√≥ loop th√¨ m·ªõi t·∫°o
                if not staminaLoop then
                    staminaLoop = task.spawn(function()
                        while InfStaminaEnabled do
                            task.wait(0.5) -- h·ªìi m·ªói 0.5s
                            StaminaModule.Stamina = StaminaModule.MaxStamina
                            StaminaModule.StaminaChanged:Fire()
                        end
                        staminaLoop = nil -- khi t·∫Øt xong th√¨ gi·∫£i ph√≥ng
                    end)
                end
            else
                -- Khi t·∫Øt th√¨ ch·ªâ c·∫ßn ƒë·∫∑t flag false, loop s·∫Ω t·ª± d·ª´ng
                InfStaminaEnabled = false
            end
        end)
    end)
end)



local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

local FakeDieEnabled = false
local FakeDieLoop
local MovementBlocked = false

-- H√†m n·∫±m xu·ªëng
local function LieDown()
    local Character = LocalPlayer.Character
    if not Character then return end
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    
    if Humanoid then
        Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    end

    if HRP then
        HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(math.rad(90), 0, 0)
        HRP.Velocity = Vector3.zero
        HRP.AssemblyLinearVelocity = Vector3.zero
        HRP.AssemblyAngularVelocity = Vector3.zero
    end

    -- Ch·∫∑n di chuy·ªÉn
    MovementBlocked = true
end

-- H√†m ƒë·ª©ng d·∫≠y
local function StandUp()
    local Character = LocalPlayer.Character
    if not Character then return end
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local HRP = Character:FindFirstChild("HumanoidRootPart")

    if Humanoid then
        Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end

    if HRP then
        HRP.CFrame = CFrame.new(HRP.Position + Vector3.new(0, 3, 0))
    end

    MovementBlocked = false
end

-- Ch·∫∑n input di chuy·ªÉn khi ƒëang n·∫±m
UserInputService.InputBegan:Connect(function(input, gp)
    if MovementBlocked and input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.W
        or input.KeyCode == Enum.KeyCode.A
        or input.KeyCode == Enum.KeyCode.S
        or input.KeyCode == Enum.KeyCode.D
        or input.KeyCode == Enum.KeyCode.Space then
            input:Capture() -- NgƒÉn thao t√°c
        end
    end
end)

-- Toggle trong Tabs.Player
Tabs.Player:AddToggle("FakeDie", {
    Title = "Fake Die [Beta]",
    Default = false
}):OnChanged(function(state)
    FakeDieEnabled = state

    if state then
        -- B·∫Øt ƒë·∫ßu loop gi·ªØ n·∫±m
        FakeDieLoop = task.spawn(function()
            while FakeDieEnabled do
                LieDown()
                task.wait(0.2) -- C·∫≠p nh·∫≠t li√™n t·ª•c ƒë·ªÉ ƒë·∫£m b·∫£o lu√¥n n·∫±m
            end
        end)
    else
        if FakeDieLoop then
            task.cancel(FakeDieLoop)
            FakeDieLoop = nil
        end
        StandUp()
    end
end)

-- ƒê·∫£m b·∫£o khi respawn v·∫´n gi·ªØ tr·∫°ng th√°i
LocalPlayer.CharacterAdded:Connect(function(char)
    if FakeDieEnabled then
        task.wait(1) -- ch·ªù load xong
        LieDown()
    end
end)




    Tabs.Player:AddSection("‚Ü≥ Hitbox")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch model c·∫ßn tƒÉng hitbox
local targetModels = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

local HitboxEnabled = false
local HitboxScale = 2 -- m·∫∑c ƒë·ªãnh
local originalSizes = {}

-- H√†m √°p d·ª•ng hitbox
local function applyHitboxToCharacter(char, owner)
    if not HitboxEnabled then return end
    if not targetModels[char.Name] then return end
    if owner == LocalPlayer then return end -- Kh√¥ng √°p d·ª•ng cho b·∫£n th√¢n

    local part = char:FindFirstChild("HumanoidRootPart")
    if part and part:IsA("BasePart") then
        if not originalSizes[part] then
            originalSizes[part] = part.Size
        end

        part.Size = originalSizes[part] * HitboxScale
        part.Transparency = 0.8 -- Trong su·ªët
        part.Color = Color3.fromRGB(255, 0, 0) -- ƒê·ªè
        part.Material = Enum.Material.Neon
        part.CanCollide = false
    end
end

-- H√†m reset hitbox
local function resetHitbox(char)
    local part = char:FindFirstChild("HumanoidRootPart")
    if part and part:IsA("BasePart") and originalSizes[part] then
        part.Size = originalSizes[part]
        part.Transparency = 1
        part.Material = Enum.Material.Plastic
    end
end

-- Slider ch·ªânh scale
Tabs.Player:AddSlider("HitboxScale", {
    Title = "Hitbox Scale",
    Default = 2,
    Min = 1,
    Max = 10,
    Rounding = 1
}):OnChanged(function(value)
    HitboxScale = value
    if HitboxEnabled then
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr.Character then
                applyHitboxToCharacter(plr.Character, plr)
            end
        end
    end
end)

-- Toggle b·∫≠t/t·∫Øt (n·∫±m d∆∞·ªõi slider)
Tabs.Player:AddToggle("HitboxToggle", {
    Title = "Hitbox Target Players",
    Default = false
}):OnChanged(function(state)
    HitboxEnabled = state

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            if state then
                applyHitboxToCharacter(player.Character, player)
            else
                resetHitbox(player.Character)
            end
        end
    end
end)

-- Theo d√µi player m·ªõi v√†o
Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        applyHitboxToCharacter(char, plr)
    end)
end)

-- √Åp d·ª•ng cho player hi·ªán t·∫°i
for _, plr in ipairs(Players:GetPlayers()) do
    plr.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        applyHitboxToCharacter(char, plr)
    end)
    if plr.Character then
        applyHitboxToCharacter(plr.Character, plr)
    end
end




    Tabs.Player:AddSection("‚Ü≥ Walk Speed")


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local speedEnabled = false
local speedValue = 16 -- m·∫∑c ƒë·ªãnh t·ªëc ƒë·ªô
local speedLoop

-- H√†m c·∫≠p nh·∫≠t t·ªëc ƒë·ªô l√™n humanoid hi·ªán t·∫°i c·ªßa character m·ªõi
local function updateSpeed()
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = speedEnabled and speedValue or 16
    end
end

-- B·∫Øt s·ª± ki·ªán khi Character thay ƒë·ªïi (ch·∫øt ho·∫∑c respawn)
LocalPlayer.CharacterAdded:Connect(function(char)
    if speedEnabled then
        -- delay 0.1s ƒë·ªÉ humanoid ch·∫Øc ch·∫Øn t·ªìn t·∫°i
        task.wait(0.1)
        updateSpeed()
    end
end)

-- T·∫°o Slider ch·ªânh t·ªëc ƒë·ªô t·ª´ 1 ƒë·∫øn 25
Tabs.Player:AddSlider("SpeedSlider", {
    Title = "Set Speed",
    Default = speedValue,
    Min = 1,
    Max = 25,
    Rounding = 1,
}):OnChanged(function(value)
    speedValue = value
    if speedEnabled then
        updateSpeed()
    end
end)

-- T·∫°o Toggle b·∫≠t/t·∫Øt t·ªëc ƒë·ªô
Tabs.Player:AddToggle("SpeedToggle", {
    Title = "Enable Speed",
    Default = false,
}):OnChanged(function(enabled)
    speedEnabled = enabled

    if enabled then
        updateSpeed()
        -- Kh·ªüi t·∫°o loop c·∫≠p nh·∫≠t li√™n t·ª•c ƒë·ªÉ x·ª≠ l√Ω tr∆∞·ªùng h·ª£p model ƒë·ªïi m√† Humanoid ch∆∞a c·∫≠p nh·∫≠t
        if speedLoop then
            task.cancel(speedLoop)
            speedLoop = nil
        end

        speedLoop = task.spawn(function()
            while speedEnabled do
                updateSpeed()
                task.wait(0.5) -- c·∫≠p nh·∫≠t m·ªói 0.5s
            end
        end)
    else
        -- Khi t·∫Øt toggle, h·ªßy v√≤ng l·∫∑p v√† reset t·ªëc ƒë·ªô v·ªÅ m·∫∑c ƒë·ªãnh
        if speedLoop then
            task.cancel(speedLoop)
            speedLoop = nil
        end
        local character = LocalPlayer.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = 16
        end
    end
end)


-- Tabs.Visual

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- üìå Danh s√°ch model cho ESP tr·∫Øng
local allowedModelsWhite = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
}

-- üìå Danh s√°ch model cho ESP ƒë·ªè
local allowedModelsRed = {
    ["Jason"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- Internal containers
local drawingsWhite = {}
local drawingsRed = {}
local espConnectionWhite, espConnectionRed
local addedConnWhite, removedConnWhite
local addedConnRed, removedConnRed

-- T·∫°o ESP (m√†u tu·ª≥ ch·ªçn)
local function createESP(model, drawings, color)
    if not model or drawings[model] then return end
    local hrp = model:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Visible = false
    text.Color = color

    drawings[model] = text
end

-- Xo√° ESP
local function removeESP(model, drawings)
    if drawings[model] then
        pcall(function() drawings[model]:Remove() end)
        drawings[model] = nil
    end
end

-- Qu√©t workspace v√† t·∫°o ESP
local function scanWorkspaceForAllowed(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
            createESP(obj, drawings, color)
        end
    end
end

-- B·∫Øt ƒë·∫ßu ESP (m√†u tu·ª≥ ch·ªçn)
local function startESP(allowedList, drawings, espConnectionVar, addedConnVar, removedConnVar, color)
    if espConnectionVar then return end
    scanWorkspaceForAllowed(allowedList, drawings, color)

    espConnectionVar = RunService.RenderStepped:Connect(function()
        for model, text in pairs(drawings) do
            if not model or not model.Parent or not model:FindFirstChild("HumanoidRootPart") then
                text.Visible = false
            else
                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude
                text.Text = string.format("%s [%.0fm]", model.Name, dist)
                text.Position = Vector2.new(pos.X, pos.Y)
                text.Visible = onScreen
            end
        end
    end)

    addedConnVar = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedList[model.Name] and model:FindFirstChild("HumanoidRootPart") then
            createESP(model, drawings, color)
        end
    end)

    removedConnVar = workspace.DescendantRemoving:Connect(function(obj)
        if obj:IsA("Model") and drawings[obj] then
            removeESP(obj, drawings)
        end
    end)

    return espConnectionVar, addedConnVar, removedConnVar
end

-- D·ª´ng ESP
local function stopESP(drawings, espConnectionVar, addedConnVar, removedConnVar)
    if espConnectionVar then espConnectionVar:Disconnect() end
    if addedConnVar then addedConnVar:Disconnect() end
    if removedConnVar then removedConnVar:Disconnect() end
    for _, text in pairs(drawings) do
        pcall(function() text:Remove() end)
    end
    table.clear(drawings)
    return nil, nil, nil
end

Tabs.Visual:AddToggle("ESPModelWhiteToggle", {
    Title = "ESP Player",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        espConnectionWhite, addedConnWhite, removedConnWhite =
            startESP(allowedModelsWhite, drawingsWhite, espConnectionWhite, addedConnWhite, removedConnWhite, Color3.fromRGB(255, 255, 255))
    else
        espConnectionWhite, addedConnWhite, removedConnWhite =
            stopESP(drawingsWhite, espConnectionWhite, addedConnWhite, removedConnWhite)
    end
end)

Tabs.Visual:AddToggle("ESPModelRedToggle", {
    Title = "ESP Killer",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        espConnectionRed, addedConnRed, removedConnRed =
            startESP(allowedModelsRed, drawingsRed, espConnectionRed, addedConnRed, removedConnRed, Color3.fromRGB(255, 0, 0))
    else
        espConnectionRed, addedConnRed, removedConnRed =
            stopESP(drawingsRed, espConnectionRed, addedConnRed, removedConnRed)
    end
end)



-- ESP Highlight cho model "Generator"
local RunService = game:GetService("RunService")
local allowedName = "Generator"
local highlights = {}
local espConnection, addedConn, removedConn

-- T·∫°o highlight cho model
local function createHighlight(model)
    if not model or highlights[model] then return end
    if not model:IsA("Model") then return end

    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 255, 255)    -- M√†u tr·∫Øng
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255) -- Vi·ªÅn tr·∫Øng
    highlight.FillTransparency = 0.5                       -- ƒê·ªô trong su·ªët b√™n trong
    highlight.OutlineTransparency = 0                      -- Vi·ªÅn r√µ n√©t
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model

    highlights[model] = highlight
end

-- Xo√° highlight
local function removeHighlight(model)
    if highlights[model] then
        highlights[model]:Destroy()
        highlights[model] = nil
    end
end

-- Qu√©t t·∫•t c·∫£ model hi·ªán t·∫°i
local function scanWorkspace()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj.Name == allowedName then
            createHighlight(obj)
        end
    end
end

-- B·∫Øt ƒë·∫ßu ESP
local function startESP()
    scanWorkspace()

    addedConn = workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Model") and obj.Name == allowedName then
            createHighlight(obj)
        end
    end)

    removedConn = workspace.DescendantRemoving:Connect(function(obj)
        if highlights[obj] then
            removeHighlight(obj)
        end
    end)
end

-- D·ª´ng ESP
local function stopESP()
    if addedConn then addedConn:Disconnect() addedConn = nil end
    if removedConn then removedConn:Disconnect() removedConn = nil end

    for model, hl in pairs(highlights) do
        hl:Destroy()
    end
    table.clear(highlights)
end

-- ==========================
-- T√çCH H·ª¢P FLUENT GUI Toggle
-- ==========================
Tabs.Visual:AddToggle("ESPGeneratorToggle", {
    Title = "ESP Generator",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESP()
    else
        stopESP()
    end
end)


local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- ESP Container cho c√°c model
local drawings = {}
local espConnection

-- Danh s√°ch model c·∫ßn theo d√µi v√† m√†u s·∫Øc
local trackedModels = {
    ["Bloxycola"] = Color3.fromRGB(139, 69, 19), -- Brown
    ["Medkit"] = Color3.fromRGB(0, 255, 0),      -- Green
}

-- T·∫°o ESP cho model v·ªõi vi·ªÅn v√† ph√°t s√°ng
local function createESP(model)
    if drawings[model] then return end

    -- Text ch√≠nh
    local text = Drawing.new("Text")
    text.Size = 16
    text.Center = true
    text.Outline = false -- T·∫Øt outline cho text ch√≠nh
    text.Color = trackedModels[model.Name] or Color3.new(1, 1, 1)
    text.Visible = false

    -- Vi·ªÅn (Outline) b·∫±ng nhi·ªÅu text nh·ªè h∆°n, offset
    local outlineTexts = {}

    local offsets = {
        Vector2.new(-1, 0),
        Vector2.new(1, 0),
        Vector2.new(0, -1),
        Vector2.new(0, 1),
        Vector2.new(-1, -1),
        Vector2.new(1, -1),
        Vector2.new(-1, 1),
        Vector2.new(1, 1),
    }

    for _, offset in ipairs(offsets) do
        local outline = Drawing.new("Text")
        outline.Size = 16
        outline.Center = true
        outline.Color = trackedModels[model.Name] or Color3.new(1, 1, 1)
        outline.Position = Vector2.new(0, 0)
        outline.Visible = false
        outline.Text = ""
        table.insert(outlineTexts, {obj = outline, offset = offset})
    end

    drawings[model] = {
        main = text,
        outlines = outlineTexts
    }
end

-- Xo√° ESP
local function removeESP(model)
    if drawings[model] then
        drawings[model].main:Remove()
        for _, outline in ipairs(drawings[model].outlines) do
            outline.obj:Remove()
        end
        drawings[model] = nil
    end
end

-- B·∫Øt ƒë·∫ßu ESP
local function startESP()
    -- T·∫°o ESP cho c√°c model ƒëang c√≥ trong workspace
    for _, model in ipairs(workspace:GetChildren()) do
        if trackedModels[model.Name] then
            createESP(model)
        end
    end

    -- L·∫Øng nghe model m·ªõi th√™m v√†o workspace
    workspace.ChildAdded:Connect(function(model)
        if trackedModels[model.Name] then
            createESP(model)
        end
    end)

    -- L·∫Øng nghe model b·ªã xo√° kh·ªèi workspace
    workspace.ChildRemoved:Connect(function(model)
        if trackedModels[model.Name] then
            removeESP(model)
        end
    end)

    -- C·∫≠p nh·∫≠t v·ªã tr√≠ v√† hi·ªÉn th·ªã ESP m·ªói frame
    espConnection = RunService.RenderStepped:Connect(function()
        for model, esp in pairs(drawings) do
            local primaryPart = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
            if primaryPart then
                local pos, visible = Camera:WorldToViewportPoint(primaryPart.Position + Vector3.new(0, 2.5, 0))
                local distance = (primaryPart.Position - Camera.CFrame.Position).Magnitude

                esp.main.Text = string.format("%s [%.0fm]", model.Name, distance)
                esp.main.Position = Vector2.new(pos.X, pos.Y)
                esp.main.Visible = visible

                for _, outline in ipairs(esp.outlines) do
                    outline.obj.Text = esp.main.Text
                    outline.obj.Position = esp.main.Position + outline.offset
                    outline.obj.Color = Color3.new(0, 0, 0) -- vi·ªÅn ƒëen r√µ h∆°n
                    outline.obj.Visible = visible
                end
            else
                esp.main.Visible = false
                for _, outline in ipairs(esp.outlines) do
                    outline.obj.Visible = false
                end
            end
        end
    end)
end

-- D·ª´ng ESP
local function stopESP()
    if espConnection then
        espConnection:Disconnect()
        espConnection = nil
    end

    for model, esp in pairs(drawings) do
        esp.main:Remove()
        for _, outline in ipairs(esp.outlines) do
            outline.obj:Remove()
        end
    end
    drawings = {}
end

-- T√≠ch h·ª£p Fluent GUI Toggle trong Tabs.Visual (ho·∫∑c Tabs.Player t√πy b·∫°n)
Tabs.Visual:AddToggle("ESPModelsToggle", {
    Title = "ESP Item Drop",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESP()
    else
        stopESP()
    end
end)




-- Tabs.Misc

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- ‚úÖ FullBright Settings
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end

    Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- s√°ng nh·∫π
    Lighting.Brightness = 4 -- gi·∫£m ƒë·ªô s√°ng t·ª´ 10 ‚Üí 4
    Lighting.GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then
        fullBrightLoop:Disconnect()
        fullBrightLoop = nil
    end

    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

-- ‚úÖ Toggle: FullBright
local FbToggle = Tabs.Misc:AddToggle("FbToggle", {
    Title = "Auto Full Bright",
    Default = false
})
FbToggle:OnChanged(function(Value)
    fullBrightEnabled = Value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

-- ‚úÖ Remove Fog Settings
local fogEnabled = false
local fogLoop

local function removeFog()
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1, 1, 1)
    end
end

local function restoreFog()
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200, 200, 200)
    end
end

-- ‚úÖ Toggle: Remove Fog
local FogToggle = Tabs.Misc:AddToggle("FogToggle", {
    Title = "Remove Fog",
    Default = false
})
FogToggle:OnChanged(function(Value)
    fogEnabled = Value
    if fogEnabled then
        removeFog()
        fogLoop = RunService.Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop = nil end
        restoreFog()
    end
end)


    Tabs.Misc:AddSection("‚Ü≥ Show")

-- FPS + Ping Drawing Setup
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- Update FPS
        if showFPS then
            fpsText.Text = "FPS: " .. tostring(fpsCounter)
            fpsText.Visible = true
        else
            fpsText.Visible = false
        end

        -- Update Ping
        if showPing then
            local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
            local ping = pingStat and math.floor(pingStat:GetValue()) or 0
            msText.Text = "Ping: " .. ping .. " ms"

            if ping <= 60 then
                msText.Color = Color3.fromRGB(0, 255, 0)
            elseif ping <= 120 then
                msText.Color = Color3.fromRGB(255, 165, 0)
            else
                msText.Color = Color3.fromRGB(255, 0, 0)
            end

            msText.Visible = true
        else
            msText.Visible = false
        end

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ‚úÖ Fluent GUI Toggles chu·∫©n
local fpsToggle = Tabs.Misc:AddToggle("ShowFPSToggle", {
    Title = "Show FPS",
    Default = true
})
fpsToggle:OnChanged(function(val)
    showFPS = val
    fpsText.Visible = val
end)

local pingToggle = Tabs.Misc:AddToggle("ShowPingToggle", {
    Title = "Show Ping",
    Default = true
})
pingToggle:OnChanged(function(val)
    showPing = val
    msText.Visible = val
end)

-- Tabs.Settings


local AexecToggle = Tabs.Settings:AddToggle("AexecToggle", {Title = "Auto Execute", Default = false })
AexecToggle:OnChanged(function(Value)
    if Value then
        task.spawn(function()
            pcall(function()
                if queue_on_teleport then
                    local HutaoHubScript1 = [[
task.wait(3)
loadstring(game:HttpGet('https://raw.githubusercontent.com/hungquan99/SkullHub/main/loader.lua'))()
]]
                    queue_on_teleport(HutaoHubScript1)
                end
            end)
        end)
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is enabled!",
            Duration = 5
        })
    else
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is disabled!",
            Duration = 5
        })
    end
end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("Hutao HUB")
SaveManager:SetFolder("Hutao HUB/Forsaken")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Select First Tab By Default
Window:SelectTab(1)

Fluent:Notify({ Title = "Hutao HUB", Content = "forsaken script loaded successfully!", Duration = 5 })
SaveManager:LoadAutoloadConfig()


-- üü¢ DRAGGABLE UI BUTTON WITH ENHANCED CLICK AND HOVER ANIMATIONS
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local ExistingUI = CoreGui:FindFirstChild("HutaoHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

-- Create Floating UI
local DragUI = Instance.new("ScreenGui")
DragUI.Name = "HutaoHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Ensures highest rendering priority
DragUI.Parent = CoreGui -- Overrides all other UI elements

-- Create Circular Button (Draggable + Clickable)
local Button = Instance.new("ImageButton")
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50) -- Adjust size if needed
Button.Position = UDim2.new(0, 10, 1, -85) -- Initial position
Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Windows 11 Style
Button.BackgroundTransparency = 0.3 -- Semi-transparent
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Image = "rbxassetid://90508203972003" -- Replace with your custom image ID
Button.ScaleType = Enum.ScaleType.Fit
Button.Active = true -- Allows drag functionality
Button.ZIndex = 1000 -- Ensure it stays on top

-- Make UI Circular
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0) -- Full circle
UICorner.Parent = Button

-- Tween Info for Animations
local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

-- Function to simulate RightShift key press
local function SimulateKeyPress()
    VirtualInputManager:SendKeyEvent(true, minimizeUI, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, minimizeUI, false, game)
end

-- Click Animation & UI Toggle (Only if NOT dragged too much)
local isDragging = false
local dragThreshold = 10 -- Allow small movement without canceling click

Button.MouseButton1Click:Connect(function()
    if isDragging then return end -- Prevent click after large dragging

    -- Enhanced Click Animation
    local tween = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.5,
        Size = UDim2.new(0, 45, 0, 45),
        Rotation = 5
    })
    tween:Play()
    task.wait(0.1)
    local tweenBack = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.3,
        Size = UDim2.new(0, 50, 0, 50),
        Rotation = 0
    })
    tweenBack:Play()

    -- Simulate RightShift to Toggle UI
    SimulateKeyPress()
end)

-- Hover Animation
Button.MouseEnter:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
end)

Button.MouseLeave:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
end)

-- Dragging Logic for PC & Mobile
local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false -- Reset dragging state
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then -- Only mark as dragged if movement exceeds threshold
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

-- Dragging Support for PC & Mobile (on the same button)
Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)      
