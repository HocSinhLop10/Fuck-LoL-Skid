local Library = loadstring(Game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()

local PhantomForcesWindow = Library:NewWindow("Don't Press The Button")

local KillingCheats = PhantomForcesWindow:NewSection("Main")

local Player = PhantomForcesWindow:NewSection("Player")

local Esp = PhantomForcesWindow:NewSection("Esp")

-- Button --

--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// Danh s√°ch t√™n model c·∫ßn teleport ƒë·∫øn
local targetModelNames = { "SpinningCoin", "Coin" }

--// H√†m l·∫•y to√†n b·ªô model ƒë√∫ng t√™n ƒëang t·ªìn t·∫°i v√† hi·ªÉn th·ªã
local function getVisibleCoins()
	local allCoins = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") then
			for _, name in ipairs(targetModelNames) do
				if model.Name == name then
					local part = model:FindFirstChildWhichIsA("BasePart")
					if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
						table.insert(allCoins, part)
					end
				end
			end
		end
	end
	return allCoins
end

--// T√≠ch h·ª£p Toggle Fluent
KillingCheats:CreateToggle("Auto Farm Coin", function(value)
	autoTeleport = value
	print("Auto Farm Coin:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p d·ªãch chuy·ªÉn lu√¢n phi√™n gi·ªØa t·∫•t c·∫£ coin ƒëang hi·ªán
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local coins = getVisibleCoins()

				if #coins > 0 then
					if currentIndex > #coins then
						currentIndex = 1
					end

					local target = coins[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 3, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1) -- delay gi·ªØa m·ªói l·∫ßn teleport
	end
end)





--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// H√†m l·∫•y to√†n b·ªô Fireworks ƒëang t·ªìn t·∫°i v√† c√≤n hi·ªÉn th·ªã
local function getVisibleFireworks()
	local fireworks = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "Fireworks" then
			local part = model:FindFirstChildWhichIsA("BasePart")
			if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
				table.insert(fireworks, part)
			end
		end
	end
	return fireworks
end

--// T√≠ch h·ª£p v√†o Toggle Start Trade
KillingCheats:CreateToggle("Find Fireworks", function(value)
	autoTeleport = value
	print("Find Fireworks:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p teleport lu√¢n phi√™n qua c√°c Fireworks
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local fireworks = getVisibleFireworks()

				if #fireworks > 0 then
					if currentIndex > #fireworks then
						currentIndex = 1
					end

					local target = fireworks[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 3, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1) -- th·ªùi gian gi·ªØa c√°c l·∫ßn d·ªãch chuy·ªÉn
	end
end)





--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// H√†m l·∫•y to√†n b·ªô Bucket ƒëang t·ªìn t·∫°i v√† c√≤n hi·ªÉn th·ªã
local function getVisibleBuckets()
	local buckets = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "Bucket" then
			local part = model:FindFirstChildWhichIsA("BasePart")
			if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
				table.insert(buckets, part)
			end
		end
	end
	return buckets
end

--// T√≠ch h·ª£p v√†o Toggle Start Trade
KillingCheats:CreateToggle("Find Bucket", function(value)
	autoTeleport = value
	print("Find Bucket:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p teleport lu√¢n phi√™n qua c√°c Bucket
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local buckets = getVisibleBuckets()

				if #buckets > 0 then
					if currentIndex > #buckets then
						currentIndex = 1
					end

					local target = buckets[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 3, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1)
	end
end)


--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// Danh s√°ch t√™n model c·∫ßn teleport ƒë·∫øn
local targetModelNames = { "Candy" }

--// H√†m l·∫•y to√†n b·ªô model ƒë√∫ng t√™n ƒëang t·ªìn t·∫°i v√† hi·ªÉn th·ªã
local function getVisibleCandy()
	local allCandy = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") then
			for _, name in ipairs(targetModelNames) do
				if model.Name == name then
					local part = model:FindFirstChildWhichIsA("BasePart")
					if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
						table.insert(allCandy, part)
					end
				end
			end
		end
	end
	return allCandy
end

--// T√≠ch h·ª£p Toggle Fluent
KillingCheats:CreateToggle("Find All Candy", function(value)
	autoTeleport = value
	print("Auto Find Candy:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p d·ªãch chuy·ªÉn lu√¢n phi√™n gi·ªØa t·∫•t c·∫£ coin ƒëang hi·ªán
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local Candy = getVisibleCandy()

				if #Candy > 0 then
					if currentIndex > #Candy then
						currentIndex = 1
					end

					local target = Candy[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 3, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1) -- delay gi·ªØa m·ªói l·∫ßn teleport
	end
end)


-- Player

--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Bi·∫øn ƒëi·ªÅu khi·ªÉn
local speedEnabled = false
local speedValue = 16 -- m·∫∑c ƒë·ªãnh

--// Toggle b·∫≠t/t·∫Øt tƒÉng t·ªëc
Player:CreateToggle("Walk Speed", function(value)
	speedEnabled = value
	print("Walk Speed Enabled:", value)

	local char = lp.Character
	if char and char:FindFirstChild("Humanoid") then
		char.Humanoid.WalkSpeed = value and speedValue or 16
	end
end)

--// TextBox nh·∫≠p t·ªëc ƒë·ªô th·ªß c√¥ng (thay v√¨ slider)
Player:CreateTextbox("Speed (1 - 300)", function(text)
	local number = tonumber(text)
	if number and number >= 1 and number <= 300 then
		speedValue = number
		print("Speed set to:", speedValue)

		if speedEnabled then
			local char = lp.Character
			if char and char:FindFirstChild("Humanoid") then
				char.Humanoid.WalkSpeed = speedValue
			end
		end
	else
		warn("Invalid speed input! Must be a number between 1 and 300.")
	end
end)

--// C·∫≠p nh·∫≠t l·∫°i khi nh√¢n v·∫≠t respawn
lp.CharacterAdded:Connect(function(char)
	char:WaitForChild("Humanoid")
	task.wait(0.1)
	char.Humanoid.WalkSpeed = speedEnabled and speedValue or 16
end)





--// Bi·∫øn tr·∫°ng th√°i
local noclipEnabled = false

--// Toggle Noclip
Player:CreateToggle("Noclip", function(value)
    noclipEnabled = value
    print("Noclip Enabled:", value)
end)

--// H√†m ch√≠nh ƒë·ªÉ duy tr√¨ Noclip n·∫øu ƒë∆∞·ª£c b·∫≠t
game:GetService("RunService").Stepped:Connect(function()
    if noclipEnabled then
        local character = game:GetService("Players").LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide == true then
                    part.CanCollide = false
                end
            end
        end
    end
end)





--// Infinite Jump Toggle
Player:CreateToggle("Infinite Jump", function(state)
    getgenv().InfiniteJump = state
    print("Infinite Jump Enabled:", state)
end)

--// Infinite Jump Handler
game:GetService("UserInputService").JumpRequest:Connect(function()
    if getgenv().InfiniteJump then
        local lp = game:GetService("Players").LocalPlayer
        local char = lp.Character
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)


-- Esp

if not game:IsLoaded() then game.Loaded:Wait() end

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local drawings = {}
local espEnabled = false

-- L·ªçc c√°c model KH√îNG ph·∫£i NPC (kh√¥ng c√≥ Humanoid)
local function isValidModel(model)
	return model:IsA("Model")
		and model:FindFirstChildWhichIsA("BasePart")
		and not model:FindFirstChildOfClass("Humanoid")
end

-- L·∫•y v·ªã tr√≠ trung t√¢m model t·ª´ BasePart
local function getModelPosition(model)
	local parts = {}
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			table.insert(parts, part.Position)
		end
	end
	if #parts == 0 then return nil end

	local avg = Vector3.new(0, 0, 0)
	for _, pos in pairs(parts) do
		avg += pos
	end
	return avg / #parts
end

-- T·∫°o ESP Text
local function createESP(model)
	if drawings[model] then return end

	local text = Drawing.new("Text")
	text.Visible = true
	text.Size = 13
	text.Center = true
	text.Outline = true
	text.Font = 2
	text.Color = Color3.fromRGB(255, 255, 255)

	drawings[model] = text
end

-- Xo√° ESP khi model b·ªã xo√°
local function removeESP(model)
	if drawings[model] then
		drawings[model]:Remove()
		drawings[model] = nil
	end
end

-- D√≤ t·∫•t c·∫£ c√°c model tƒ©nh
local function scanModels()
	for _, model in ipairs(workspace:GetDescendants()) do
		if isValidModel(model) then
			createESP(model)
		end
	end
end

-- Render ESP m·ªói frame n·∫øu b·∫≠t
RunService.RenderStepped:Connect(function()
	if not espEnabled then
		for model, esp in pairs(drawings) do
			esp.Visible = false
		end
		return
	end

	for model, esp in pairs(drawings) do
		if model and model.Parent and isValidModel(model) then
			local pos = getModelPosition(model)
			if pos then
				local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
				if onScreen then
					esp.Position = Vector2.new(screenPos.X, screenPos.Y)
					esp.Text = model.Name
					esp.Visible = true
				else
					esp.Visible = false
				end
			else
				esp.Visible = false
			end
		else
			removeESP(model)
		end
	end
end)

-- Qu√©t l·∫°i model m·ªói 5 gi√¢y n·∫øu b·∫≠t
task.spawn(function()
	while true do
		if espEnabled then
			scanModels()
		end
		task.wait(5)
	end
end)

-- üü© Toggle ESP Model d√πng GUI c·ªßa b·∫°n
Esp:CreateToggle("ESP Model", function(value)
	espEnabled = value
	if not value then
		for model, esp in pairs(drawings) do
			esp.Visible = false
		end
	end
end)





--// ESP Diamond
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

local diamondESPEnabled = false
local drawings = {}

Esp:CreateToggle("ESP Diamond", function(value)
    diamondESPEnabled = value
    print("ESP Diamond:", value)

    if not value then
        -- X√≥a t·∫•t c·∫£ ESP khi t·∫Øt
        for _, drawing in ipairs(drawings) do
            if drawing.Text then drawing.Text:Remove() end
        end
        drawings = {}
    end
end)

RunService.RenderStepped:Connect(function()
    if not diamondESPEnabled then return end

    -- X√≥a ESP c≈©
    for _, drawing in ipairs(drawings) do
        if drawing.Text then drawing.Text:Remove() end
    end
    drawings = {}

    for _, model in ipairs(workspace:GetDescendants()) do
        if model:IsA("Model") and model.Name:lower():find("diamond") then
            local part = model:FindFirstChildWhichIsA("BasePart")
            if part and part:IsDescendantOf(workspace) and part:IsA("BasePart") then
                local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local text = Drawing.new("Text")
                    text.Text = model.Name
                    text.Position = Vector2.new(screenPos.X, screenPos.Y)
                    text.Size = 16
                    text.Color = Color3.fromRGB(0, 255, 255)
                    text.Center = true
                    text.Outline = true
                    text.Visible = true

                    table.insert(drawings, {Text = text})
                end
            end
        end
    end
end)






