local Library = loadstring(Game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()

local PhantomForcesWindow = Library:NewWindow("Don't Press The Button")

local KillingCheats = PhantomForcesWindow:NewSection("Main")

local Player = PhantomForcesWindow:NewSection("Player")

local Esp = PhantomForcesWindow:NewSection("Esp")

local Misc = PhantomForcesWindow:NewSection("Misc")

-- Button --

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local player = Players.LocalPlayer

-- T·∫°o GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CenterClickGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- T·∫°o t√¢m b·∫Øn ·ªü gi·ªØa m√†n h√¨nh
local crosshair = Instance.new("Frame")
crosshair.Size = UDim2.new(0, 12, 0, 12)
crosshair.Position = UDim2.new(0.5, -6, 0.5, -6)
crosshair.AnchorPoint = Vector2.new(0.5, 0.5)
crosshair.BackgroundColor3 = Color3.new(1, 1, 1)
crosshair.BackgroundTransparency = 0
crosshair.BorderSizePixel = 0
crosshair.Parent = screenGui

local circle = Instance.new("UICorner")
circle.CornerRadius = UDim.new(1, 0)
circle.Parent = crosshair

-- Toggle k√≠ch ho·∫°t
local shootClickEnabled = false

-- H√†m m√¥ ph·ªèng click gi·ªØa m√†n h√¨nh
local function simulateClickCenter()
	if not shootClickEnabled then return end

	local viewportSize = workspace.CurrentCamera.ViewportSize
	local center = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)

	VirtualInputManager:SendMouseButtonEvent(center.X, center.Y, 0, true, game, 0)
	task.wait(0.05)
	VirtualInputManager:SendMouseButtonEvent(center.X, center.Y, 0, false, game, 0)
end

-- B·∫Øt t·∫•t c·∫£ click ho·∫∑c ch·∫°m m√†n h√¨nh
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed or not shootClickEnabled then return end

	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		simulateClickCenter()
	end
end)

-- N√∫t b·∫≠t/t·∫Øt t·ª´ GUI
KillingCheats:CreateToggle("Shoot Click", function(value)
	shootClickEnabled = value
	print("Shoot Click Enabled:", value)
end)



--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// Danh s√°ch t√™n model c·∫ßn teleport ƒë·∫øn
local targetModelNames = { "SpinningCoin", "Coin" }

--// H√†m l·∫•y to√†n b·ªô model ƒë√∫ng t√™n ƒëang t·ªìn t·∫°i v√† hi·ªÉn th·ªã
local function getVisibleCoins()
	local allCoins = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") then
			for _, name in ipairs(targetModelNames) do
				if model.Name == name then
					local part = model:FindFirstChildWhichIsA("BasePart")
					if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
						table.insert(allCoins, part)
					end
				end
			end
		end
	end
	return allCoins
end

--// T√≠ch h·ª£p Toggle Fluent
KillingCheats:CreateToggle("Auto Farm Coin", function(value)
	autoTeleport = value
	print("Auto Farm Coin:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p d·ªãch chuy·ªÉn lu√¢n phi√™n gi·ªØa t·∫•t c·∫£ coin ƒëang hi·ªán
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local coins = getVisibleCoins()

				if #coins > 0 then
					if currentIndex > #coins then
						currentIndex = 1
					end

					local target = coins[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 0, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1) -- delay gi·ªØa m·ªói l·∫ßn teleport
	end
end)





--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// H√†m l·∫•y to√†n b·ªô Fireworks ƒëang t·ªìn t·∫°i v√† c√≤n hi·ªÉn th·ªã
local function getVisibleFireworks()
	local fireworks = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "Fireworks" then
			local part = model:FindFirstChildWhichIsA("BasePart")
			if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
				table.insert(fireworks, part)
			end
		end
	end
	return fireworks
end

--// T√≠ch h·ª£p v√†o Toggle Start Trade
KillingCheats:CreateToggle("Find Fireworks", function(value)
	autoTeleport = value
	print("Find Fireworks:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p teleport lu√¢n phi√™n qua c√°c Fireworks
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local fireworks = getVisibleFireworks()

				if #fireworks > 0 then
					if currentIndex > #fireworks then
						currentIndex = 1
					end

					local target = fireworks[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 3, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1) -- th·ªùi gian gi·ªØa c√°c l·∫ßn d·ªãch chuy·ªÉn
	end
end)





--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// H√†m l·∫•y to√†n b·ªô Bucket ƒëang t·ªìn t·∫°i v√† c√≤n hi·ªÉn th·ªã
local function getVisibleBuckets()
	local buckets = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "Bucket" then
			local part = model:FindFirstChildWhichIsA("BasePart")
			if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
				table.insert(buckets, part)
			end
		end
	end
	return buckets
end

--// T√≠ch h·ª£p v√†o Toggle Start Trade
KillingCheats:CreateToggle("Find Bucket", function(value)
	autoTeleport = value
	print("Find Bucket:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p teleport lu√¢n phi√™n qua c√°c Bucket
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local buckets = getVisibleBuckets()

				if #buckets > 0 then
					if currentIndex > #buckets then
						currentIndex = 1
					end

					local target = buckets[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 3, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1)
	end
end)


--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// Danh s√°ch t√™n model c·∫ßn teleport ƒë·∫øn
local targetModelNames = { "Candy" }

--// H√†m l·∫•y to√†n b·ªô model ƒë√∫ng t√™n ƒëang t·ªìn t·∫°i v√† hi·ªÉn th·ªã
local function getVisibleCandy()
	local allCandy = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") then
			for _, name in ipairs(targetModelNames) do
				if model.Name == name then
					local part = model:FindFirstChildWhichIsA("BasePart")
					if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
						table.insert(allCandy, part)
					end
				end
			end
		end
	end
	return allCandy
end

--// T√≠ch h·ª£p Toggle Fluent
KillingCheats:CreateToggle("Find All Candy", function(value)
	autoTeleport = value
	print("Auto Find Candy:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p d·ªãch chuy·ªÉn lu√¢n phi√™n gi·ªØa t·∫•t c·∫£ coin ƒëang hi·ªán
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local Candy = getVisibleCandy()

				if #Candy > 0 then
					if currentIndex > #Candy then
						currentIndex = 1
					end

					local target = Candy[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 0, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1) -- delay gi·ªØa m·ªói l·∫ßn teleport
	end
end)





--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Toggle ƒëi·ªÅu khi·ªÉn
local autoTeleport = false
local currentIndex = 1

--// Danh s√°ch t√™n model c·∫ßn teleport ƒë·∫øn
local targetModelNames = { "Bloxy" }

--// H√†m l·∫•y to√†n b·ªô model ƒë√∫ng t√™n ƒëang t·ªìn t·∫°i v√† hi·ªÉn th·ªã
local function getVisibleBloxy()
	local allBloxy = {}
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") then
			for _, name in ipairs(targetModelNames) do
				if model.Name == name then
					local part = model:FindFirstChildWhichIsA("BasePart")
					if part and part.Transparency < 1 and part:IsDescendantOf(workspace) then
						table.insert(allBloxy, part)
					end
				end
			end
		end
	end
	return allBloxy
end

--// T√≠ch h·ª£p Toggle Fluent
KillingCheats:CreateToggle("Find All Bloxy", function(value)
	autoTeleport = value
	print("Auto Find Bloxy:", value)
	currentIndex = 1
end)

--// V√≤ng l·∫∑p d·ªãch chuy·ªÉn lu√¢n phi√™n gi·ªØa t·∫•t c·∫£ coin ƒëang hi·ªán
task.spawn(function()
	while true do
		if autoTeleport then
			local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local Bloxy = getVisibleBloxy()

				if #Bloxy > 0 then
					if currentIndex > #Bloxy then
						currentIndex = 1
					end

					local target = Bloxy[currentIndex]
					if target then
						root.CFrame = target.CFrame + Vector3.new(0, 0, 0)
						currentIndex += 1
					end
				end
			end
		end
		task.wait(0.1) -- delay gi·ªØa m·ªói l·∫ßn teleport
	end
end)





-- Player

--// Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer

--// Bi·∫øn ƒëi·ªÅu khi·ªÉn
local speedEnabled = false
local speedValue = 16 -- m·∫∑c ƒë·ªãnh

--// Toggle b·∫≠t/t·∫Øt tƒÉng t·ªëc
Player:CreateToggle("Walk Speed", function(value)
	speedEnabled = value
	print("Walk Speed Enabled:", value)

	local char = lp.Character
	if char and char:FindFirstChild("Humanoid") then
		char.Humanoid.WalkSpeed = value and speedValue or 16
	end
end)

--// TextBox nh·∫≠p t·ªëc ƒë·ªô th·ªß c√¥ng (thay v√¨ slider)
Player:CreateTextbox("Speed (1 - 300)", function(text)
	local number = tonumber(text)
	if number and number >= 1 and number <= 300 then
		speedValue = number
		print("Speed set to:", speedValue)

		if speedEnabled then
			local char = lp.Character
			if char and char:FindFirstChild("Humanoid") then
				char.Humanoid.WalkSpeed = speedValue
			end
		end
	else
		warn("Invalid speed input! Must be a number between 1 and 300.")
	end
end)

--// C·∫≠p nh·∫≠t l·∫°i khi nh√¢n v·∫≠t respawn
lp.CharacterAdded:Connect(function(char)
	char:WaitForChild("Humanoid")
	task.wait(0.1)
	char.Humanoid.WalkSpeed = speedEnabled and speedValue or 16
end)




local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- State
local flying = false
local flySpeed = 50
local renderConn

-- Function: Attach Body Movers
local function attachBodyMovers(character)
	local humanoid = character:WaitForChild("Humanoid")
	local HRP = character:WaitForChild("HumanoidRootPart")
	
	-- Clean old
	if HRP:FindFirstChild("BodyVelocity") then HRP.BodyVelocity:Destroy() end
	if HRP:FindFirstChild("BodyGyro") then HRP.BodyGyro:Destroy() end

	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
	bv.Velocity = Vector3.zero
	bv.Name = "BodyVelocity"
	bv.Parent = HRP

	local bg = Instance.new("BodyGyro")
	bg.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
	bg.CFrame = HRP.CFrame
	bg.Name = "BodyGyro"
	bg.Parent = HRP

	humanoid:ChangeState(Enum.HumanoidStateType.Physics)

	return bv, bg
end

-- Function: Start Flying
local function startFlying()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	if humanoid.Health <= 0 then return end

	local HRP = character:WaitForChild("HumanoidRootPart")
	local bv, bg = attachBodyMovers(character)

	-- Start render loop
	renderConn = RunService.RenderStepped:Connect(function()
		if not flying or humanoid.Health <= 0 then return end
		local moveDir = humanoid.MoveDirection
		local camCF = Camera.CFrame
		local moveVec = Vector3.zero

		if moveDir.Magnitude > 0 then
			local forward = camCF.LookVector
			local flatForward = Vector3.new(forward.X, 0, forward.Z).Unit
			local verticalInfluence = forward.Unit.Y

			local movingForward = flatForward:Dot(moveDir.Unit) > 0.1
			local movingBackward = flatForward:Dot(moveDir.Unit) < -0.1

			local yVelocity = 0
			if movingForward then yVelocity = verticalInfluence
			elseif movingBackward then yVelocity = -verticalInfluence end

			moveVec = Vector3.new(moveDir.X, yVelocity, moveDir.Z).Unit
		end

		if bv and bg then
			bv.Velocity = moveVec * flySpeed
			bg.CFrame = camCF
		end
	end)

	flying = true
end

-- Function: Stop Flying
local function stopFlying()
	flying = false
	if renderConn then renderConn:Disconnect() renderConn = nil end

	local character = player.Character
	if character then
		local HRP = character:FindFirstChild("HumanoidRootPart")
		if HRP then
			if HRP:FindFirstChild("BodyVelocity") then HRP.BodyVelocity:Destroy() end
			if HRP:FindFirstChild("BodyGyro") then HRP.BodyGyro:Destroy() end
		end

		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		end
	end
end

-- Handle respawn (ensure re-attach body movers if flying)
player.CharacterAdded:Connect(function()
	task.wait(0.5)
	if flying then
		startFlying()
	end
end)

-- UI Button
Player:CreateToggle("Fly (Mobile + PC)", function(value)
	if value then
		startFlying()
	else
		stopFlying()
	end
end)

Player:CreateTextbox("Fly Speed", function(text)
	local num = tonumber(text)
	if num and num > 0 then
		flySpeed = num
	else
		warn("Invalid fly speed:", text)
	end
end)





--// Bi·∫øn tr·∫°ng th√°i
local noclipEnabled = false

--// Toggle Noclip
Player:CreateToggle("Noclip", function(value)
    noclipEnabled = value
    print("Noclip Enabled:", value)
end)

--// H√†m ch√≠nh ƒë·ªÉ duy tr√¨ Noclip n·∫øu ƒë∆∞·ª£c b·∫≠t
game:GetService("RunService").Stepped:Connect(function()
    if noclipEnabled then
        local character = game:GetService("Players").LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide == true then
                    part.CanCollide = false
                end
            end
        end
    end
end)





--// Infinite Jump Toggle
Player:CreateToggle("Infinite Jump", function(state)
    getgenv().InfiniteJump = state
    print("Infinite Jump Enabled:", state)
end)

--// Infinite Jump Handler
game:GetService("UserInputService").JumpRequest:Connect(function()
    if getgenv().InfiniteJump then
        local lp = game:GetService("Players").LocalPlayer
        local char = lp.Character
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)


-- Esp

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ESP Container
local drawings = {}
local espConnection

-- T·∫°o ESP cho Player
local function createESP(player)
    if player == LocalPlayer then return end
    if drawings[player] then return end

    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Visible = false

    drawings[player] = text
end

-- Xo√° ESP
local function removeESP(player)
    if drawings[player] then
        drawings[player]:Remove()
        drawings[player] = nil
    end
end

-- B·∫Øt ƒë·∫ßu ESP
local function startESP()
    for _, player in ipairs(Players:GetPlayers()) do
        createESP(player)
    end

    Players.PlayerAdded:Connect(createESP)
    Players.PlayerRemoving:Connect(removeESP)

    espConnection = RunService.RenderStepped:Connect(function()
        for player, text in pairs(drawings) do
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")

            if hrp and humanoid and humanoid.Health > 0 then
                local pos, visible = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local distance = (hrp.Position - Camera.CFrame.Position).Magnitude
                text.Text = string.format("%s [%.0fm]", player.Name, distance)

                -- Ki·ªÉm tra n·∫øu player c√≥ Knife
                local hasKnife = false
                local backpack = player:FindFirstChildOfClass("Backpack")
                local characterTools = character:GetChildren()

                if backpack and backpack:FindFirstChild("Knife") then
                    hasKnife = true
                else
                    for _, tool in ipairs(characterTools) do
                        if tool:IsA("Tool") and tool.Name == "Knife" then
                            hasKnife = true
                            break
                        end
                    end
                end

                -- M√†u s·∫Øc theo Knife
                text.Color = hasKnife and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(0, 255, 255)
                text.Position = Vector2.new(pos.X, pos.Y)
                text.Visible = visible
            else
                text.Visible = false
            end
        end
    end)
end

-- D·ª´ng ESP
local function stopESP()
    if espConnection then
        espConnection:Disconnect()
        espConnection = nil
    end

    for _, text in pairs(drawings) do
        text:Remove()
    end
    drawings = {}
end

-- N√∫t gui ƒë·∫πp, nh·ªè g·ªçn
Esp:CreateToggle("ESP Player", function(value)
    if value then
        startESP()
    else
        stopESP()
    end
end)


--// Services
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- ESP Container
local drawings = {}
local espConnection

-- ƒê·ªëi t∆∞·ª£ng c·∫ßn ESP
local targetPart = workspace:FindFirstChild("Map118") and workspace.Map118:FindFirstChild("Eggs")
    and workspace.Map118.Eggs:FindFirstChild("Egg12") and workspace.Map118.Eggs.Egg12:FindFirstChild("MeshPart")

-- T·∫°o ESP cho Part
local function createESP()
    if not targetPart or drawings["Egg"] then return end

    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Color = Color3.fromRGB(255, 255, 0)
    text.Text = "Egg12"
    text.Visible = false

    drawings["Egg"] = {
        Part = targetPart,
        Text = text
    }
end

-- Xo√° ESP
local function removeESP()
    if drawings["Egg"] then
        drawings["Egg"].Text:Remove()
        drawings["Egg"] = nil
    end
end

-- B·∫Øt ƒë·∫ßu ESP
local function startESP()
    createESP()

    espConnection = RunService.RenderStepped:Connect(function()
        local entry = drawings["Egg"]
        if not entry or not entry.Part then return end

        local part = entry.Part
        local text = entry.Text

        if part and part:IsDescendantOf(workspace) then
            local pos, visible = Camera:WorldToViewportPoint(part.Position)
            local distance = (part.Position - Camera.CFrame.Position).Magnitude

            text.Text = string.format("Egg12 [%.0fm]", distance)
            text.Position = Vector2.new(pos.X, pos.Y)
            text.Visible = visible
        else
            text.Visible = false
        end
    end)
end

-- D·ª´ng ESP
local function stopESP()
    if espConnection then
        espConnection:Disconnect()
        espConnection = nil
    end

    removeESP()
end

-- N√∫t GUI ƒë·ªÉ b·∫≠t/t·∫Øt ESP
Esp:CreateToggle("ESP Egg", function(value)
    if value then
        startESP()
    else
        stopESP()
    end
end)

if not game:IsLoaded() then game.Loaded:Wait() end

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local drawings = {}
local espEnabled = false

-- L·ªçc c√°c model KH√îNG ph·∫£i NPC (kh√¥ng c√≥ Humanoid)
local function isValidModel(model)
	return model:IsA("Model")
		and model:FindFirstChildWhichIsA("BasePart")
		and not model:FindFirstChildOfClass("Humanoid")
end

-- L·∫•y v·ªã tr√≠ trung t√¢m model t·ª´ BasePart
local function getModelPosition(model)
	local parts = {}
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			table.insert(parts, part.Position)
		end
	end
	if #parts == 0 then return nil end

	local avg = Vector3.new(0, 0, 0)
	for _, pos in pairs(parts) do
		avg += pos
	end
	return avg / #parts
end

-- T·∫°o ESP Text
local function createESP(model)
	if drawings[model] then return end

	local text = Drawing.new("Text")
	text.Visible = true
	text.Size = 13
	text.Center = true
	text.Outline = true
	text.Font = 2
	text.Color = Color3.fromRGB(255, 255, 255)

	drawings[model] = text
end

-- Xo√° ESP khi model b·ªã xo√°
local function removeESP(model)
	if drawings[model] then
		drawings[model]:Remove()
		drawings[model] = nil
	end
end

-- D√≤ t·∫•t c·∫£ c√°c model tƒ©nh
local function scanModels()
	for _, model in ipairs(workspace:GetDescendants()) do
		if isValidModel(model) then
			createESP(model)
		end
	end
end

-- Render ESP m·ªói frame n·∫øu b·∫≠t
RunService.RenderStepped:Connect(function()
	if not espEnabled then
		for model, esp in pairs(drawings) do
			esp.Visible = false
		end
		return
	end

	for model, esp in pairs(drawings) do
		if model and model.Parent and isValidModel(model) then
			local pos = getModelPosition(model)
			if pos then
				local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
				if onScreen then
					esp.Position = Vector2.new(screenPos.X, screenPos.Y)
					esp.Text = model.Name
					esp.Visible = true
				else
					esp.Visible = false
				end
			else
				esp.Visible = false
			end
		else
			removeESP(model)
		end
	end
end)

-- Qu√©t l·∫°i model m·ªói 5 gi√¢y n·∫øu b·∫≠t
task.spawn(function()
	while true do
		if espEnabled then
			scanModels()
		end
		task.wait(5)
	end
end)

-- üü© Toggle ESP Model d√πng GUI c·ªßa b·∫°n
Esp:CreateToggle("ESP Model", function(value)
	espEnabled = value
	if not value then
		for model, esp in pairs(drawings) do
			esp.Visible = false
		end
	end
end)



--// D·ªãch v·ª•
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local enableESP = false
local drawings = {}

--// GUI Toggle
Esp:CreateToggle("ESP All Map Parts", function(state)
    enableESP = state
    print("ESP All Map Parts:", state)

    if not state then
        for _, draw in ipairs(drawings) do
            draw:Remove()
        end
        drawings = {}
    end
end)

--// Ki·ªÉm tra object c√≥ ph·∫£i l√† Part hi·ªÉn th·ªã
local function isDrawablePart(obj)
    -- Lo·∫°i b·ªè part thu·ªôc v·ªÅ Player
    local plrChar = obj:FindFirstAncestorOfClass("Model")
    if plrChar and Players:GetPlayerFromCharacter(plrChar) then
        return false
    end

    return obj:IsA("BasePart")
        and obj.Transparency < 1
        and obj:IsDescendantOf(workspace)
        and obj.Name ~= ""
end

--// Render ESP
RunService.RenderStepped:Connect(function()
    if not enableESP then return end

    -- Clear ESP tr∆∞·ªõc m·ªói frame
    for _, draw in ipairs(drawings) do
        draw:Remove()
    end
    drawings = {}

    -- V·ªã tr√≠ nh√¢n v·∫≠t
    local character = LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    for _, obj in ipairs(workspace:GetDescendants()) do
        if isDrawablePart(obj) then
            local distance = (obj.Position - root.Position).Magnitude
            if distance <= 25 then -- Ch·ªâ v·∫Ω khi trong b√°n k√≠nh 25m
                local pos, visible = Camera:WorldToViewportPoint(obj.Position)
                if visible then
                    local text = Drawing.new("Text")
                    text.Text = obj:GetFullName()
                    text.Position = Vector2.new(pos.X, pos.Y)
                    text.Size = 14
                    text.Color = Color3.fromRGB(255, 255, 0)
                    text.Center = true
                    text.Outline = true
                    text.Visible = true

                    table.insert(drawings, text)
                end
            end
        end
    end
end)



-- Misc

local UIS = game:GetService("UserInputService")
local workspace = game:GetService("Workspace")

local skipHoldConnection -- ƒë·ªÉ gi·ªØ k·∫øt n·ªëi DescendantAdded

-- H√†m ch·ªânh th·ªùi gian gi·ªØ
local function skipHoldPrompt(prompt)
    if prompt and prompt:IsA("ProximityPrompt") and prompt.HoldDuration > 0 then
        if prompt:GetAttribute("OriginalHold") == nil then
            prompt:SetAttribute("OriginalHold", prompt.HoldDuration)
        end
        prompt.HoldDuration = 0
    end
end

-- H√†m b·∫≠t Skip Hold
local function enableSkipHold()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") then
            skipHoldPrompt(obj)
        end
    end

    skipHoldConnection = workspace.DescendantAdded:Connect(function(obj)
        task.wait(0.1)
        skipHoldPrompt(obj)
    end)
end

-- H√†m t·∫Øt Skip Hold
local function disableSkipHold()
    if skipHoldConnection then
        skipHoldConnection:Disconnect()
        skipHoldConnection = nil
    end

    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") then
            local originalHold = obj:GetAttribute("OriginalHold")
            if originalHold then
                obj.HoldDuration = originalHold
                obj:SetAttribute("OriginalHold", nil)
            end
        end
    end
end

-- üîò T·∫°o Toggle b·∫±ng Fluent GUI b·∫°n d√πng
Misc:CreateToggle("Bypass Hold Prompt", function(value)
    if value then
        enableSkipHold()
    else
        disableSkipHold()
    end
end)








Misc:CreateButton("Server Hop", function()
    local PlaceID = game.PlaceId
    local AllIDs = {}
    local foundAnything = ""
    local actualHour = os.date("!*t").hour
    local Deleted = false

    local File = pcall(function()
        AllIDs = game:GetService('HttpService'):JSONDecode(readfile("NotSameServers.json"))
    end)

    if not File then
        table.insert(AllIDs, actualHour)
        writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
    end

    function TPReturner()
        local Site
        if foundAnything == "" then
            Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
        else
            Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
        end

        local ID = ""
        if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
            foundAnything = Site.nextPageCursor
        end

        local num = 0
        for i, v in pairs(Site.data) do
            local Possible = true
            ID = tostring(v.id)
            if tonumber(v.maxPlayers) > tonumber(v.playing) then
                for _, Existing in pairs(AllIDs) do
                    if num ~= 0 then
                        if ID == tostring(Existing) then
                            Possible = false
                        end
                    else
                        if tonumber(actualHour) ~= tonumber(Existing) then
                            local delFile = pcall(function()
                                delfile("NotSameServers.json")
                                AllIDs = {}
                                table.insert(AllIDs, actualHour)
                            end)
                        end
                    end
                    num = num + 1
                end
                if Possible == true then
                    table.insert(AllIDs, ID)
                    pcall(function()
                        writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
                        game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
                    end)
                    wait(4)
                end
            end
        end
    end

    function Teleport()
        while wait() do
            pcall(function()
                TPReturner()
                if foundAnything ~= "" then
                    TPReturner()
                end
            end)
        end
    end

    -- G·ªçi h√†m ƒë·ªÉ b·∫Øt ƒë·∫ßu Server Hop
    Teleport()
end)


