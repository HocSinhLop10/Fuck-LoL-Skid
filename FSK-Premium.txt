--[[  
 _   _    _   _   _____     _       ___     _   _   _   _   ____   
| | | |  | | | | |_   _|   / \     / _ \   | | | | | | | | | __ )  
| |_| |  | | | |   | |    / _ \   | | | |  | |_| | | | | | |  _ \  
|  _  |  | | | |   | |   / ___ \  | |_| |  |  _  | | |_| | | |_) | 
\_| |_/   \___/    \_/  /_/   \_\  \___/   \_| |_/  \___/  |____/
                        Hutao Hub
]]

---------------------------------------------------------------------------------
-- ‚öôÔ∏è Load GUI g·ªëc
---------------------------------------------------------------------------------

local Update = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/New-Gui/refs/heads/main/Hutao-Hub-V2.lua"))()
local Library = Update:Window(" ")

local AboutTab = Library:Tab("About", "rbxassetid://10723426722")
local FarmTab = Library:Tab("Farm", "rbxassetid://10723345749")
local MainTab = Library:Tab("Main", "rbxassetid://10723407389")
local PlayerTab = Library:Tab("Player", "rbxassetid://10747372167")
local VisualTab = Library:Tab("Visual", "rbxassetid://10723346959")
local MiscTab = Library:Tab("Misc", "rbxassetid://10723424838")
local SettingsTab = Library:Tab("Setting", "rbxassetid://10734950309")

---------------------------------------------------------------------------------
-- üß© Thay ch·ªØ + ·∫£nh
---------------------------------------------------------------------------------

local OLD_TEXTS = {"relz hub |", "RELZ HUB |", "Relz Hub |"}
local NEW_TEXT = "Hutao Hub [Free] | Forsaken | Version 5.0.0"
local OLD_IMG = "13940080072"
local NEW_IMG = "rbxassetid://90508203972003"

local function FixObject(obj)
	local lower, find, gsub = string.lower, string.find, string.gsub
	if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
		for _, v in ipairs(OLD_TEXTS) do
			if obj.Text and find(lower(obj.Text), lower(v)) then
				obj.Text = gsub(obj.Text, v, NEW_TEXT)
			end
		end
	elseif obj:IsA("StringValue") or obj:IsA("ValueBase") then
		if typeof(obj.Value) == "string" then
			for _, v in ipairs(OLD_TEXTS) do
				if find(lower(obj.Value), lower(v)) then
					obj.Value = gsub(obj.Value, v, NEW_TEXT)
				end
			end
		end
	elseif obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
		if obj.Image and find(obj.Image, OLD_IMG) then
			obj.Image = NEW_IMG
		end
	elseif obj:IsA("Decal") or obj:IsA("Texture") then
		if obj.Texture and find(obj.Texture, OLD_IMG) then
			obj.Texture = NEW_IMG
		end
	end
end

for _, obj in ipairs(game:GetDescendants()) do FixObject(obj) end
game.DescendantAdded:Connect(FixObject)

---------------------------------------------------------------------------------
-- üß† Ph√°t hi·ªán v√† ‚Äúc·ª©u‚Äù n√∫t toggle ·∫©n/hi·ªán GUI kh·ªèi b·ªã che
---------------------------------------------------------------------------------

local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

local function ProtectToggleButtons(container)
	for _, obj in ipairs(container:GetDescendants()) do
		if obj:IsA("TextButton") or obj:IsA("ImageButton") then
			local nameLower = string.lower(obj.Name)
			if nameLower:find("toggle") or nameLower:find("hide") or nameLower:find("open") or nameLower:find("show") then
				-- Di chuy·ªÉn n√∫t ra ngo√†i GUI b·ªã che
				obj.Parent = CoreGui
				obj.ZIndex = 99999
				obj.Active = true
				obj.Draggable = true
				obj.AutoButtonColor = true

				-- N·∫øu c√≥ frame n·ªÅn ƒëen, v√¥ hi·ªáu h√≥a
				local bg = obj:FindFirstAncestorWhichIsA("Frame")
				if bg and bg.BackgroundColor3 == Color3.new(0, 0, 0) and bg.BackgroundTransparency < 0.5 then
					bg.BackgroundTransparency = 1
				end
			end
		end
	end
end

-- Qu√©t c·∫£ CoreGui + PlayerGui
for _, gui in ipairs(CoreGui:GetChildren()) do ProtectToggleButtons(gui) end
for _, gui in ipairs(playerGui:GetChildren()) do ProtectToggleButtons(gui) end

-- T·ª± c·∫≠p nh·∫≠t khi GUI m·ªõi ƒë∆∞·ª£c th√™m v√†o
CoreGui.ChildAdded:Connect(ProtectToggleButtons)
playerGui.ChildAdded:Connect(ProtectToggleButtons)

---------------------------------------------------------------------------------
-- ‚ú® TƒÉng ƒë·ªô s√°ng ·∫£nh
---------------------------------------------------------------------------------

task.spawn(function()
	while true do
		for _, img in ipairs(CoreGui:GetDescendants()) do
			if img:IsA("ImageLabel") or img:IsA("ImageButton") then
				if img.Image == NEW_IMG then
					img.ImageColor3 = Color3.fromRGB(255, 255, 255)
					img.ImageTransparency = 0.05
					img.ZIndex = 9999
				end
			end
		end
		task.wait(2)
	end
end)

---------------------------------------------------------------------------------
-- Ch·ª©c NƒÉng
---------------------------------------------------------------------------------



---------------------------------------------------------------------------------
-- About
---------------------------------------------------------------------------------

AboutTab:Button("Copy Youtube Link", function()
	setclipboard("https://www.youtube.com/@SLKgamingSSR");
end);


AboutTab:Button("Copy Discord Link", function()
	setclipboard("https://discord.gg/s8NVhKwUz");
end);

AboutTab:Seperator("Update 5.0.0");
Client = AboutTab:Label("‚Ä¢ New Hutao Hub");
Client = AboutTab:Label("‚Ä¢ Update Anti Ban");
Client = AboutTab:Label("‚Ä¢ Fix All Button");
Client = AboutTab:Label("‚Ä¢ Protect Code Max");

do
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = Players.LocalPlayer

    local Active = false
    local loopRunning = false
    local CurrentTarget = nil
    local lastAttack = 0

    local KillersList = {
        ["Slasher"] = true,
        ["1x1x1x1"] = true,
        ["c00lkidd"] = true,
        ["Noli"] = true,
        ["JohnDoe"] = true,
        ["Quest666"] = true,
    }

    local PriorityList = {
        ["0206octavio"] = true
    }

    local SkillList = {
        "Slash", "Stab", "Punch",
        "VoidRush", "Nova",
        "CorruptEnergy", "Behead", "GashingWound",
        "MassInfection", "CorruptNature", "WalkspeedOverride", "PizzaDelivery",
        "UnstableEye", "Entanglement",
        "DigitalFootprint", "404Error",
        "RagingPace"
    }

    local SkillRemotes = {}

    local function findSkillRemoteFromButton(button)
        for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                for _, v in pairs(getupvalues(f)) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        return v
                    end
                end
            end
        end
        return nil
    end

    local function initSkillButtons()
        local gui = LocalPlayer:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        if not container then return end

        for _, child in ipairs(container:GetChildren()) do
            if child:IsA("ImageButton") then
                local remote = findSkillRemoteFromButton(child)
                if remote then
                    SkillRemotes[child.Name] = remote
                    warn("[Skill] Found RemoteEvent for:", child.Name, remote:GetFullName())
                end
            end
        end
    end

    initSkillButtons()
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        initSkillButtons()
    end)

    local function GetPriorityTarget()
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                if PriorityList[survivor.Name] then
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        return survivor
                    end
                end
            end
        end
        return nil
    end

    local function GetClosestSurvivor()
        local priorityTarget = GetPriorityTarget()
        if priorityTarget then return priorityTarget end

        local localChar = LocalPlayer.Character
        if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        local closest, minDist = nil, math.huge
        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            local humanoid = survivor:FindFirstChildOfClass("Humanoid")
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                local dist = (localChar.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    closest = survivor
                end
            end
        end
        return closest
    end

    local function KillTarget(target)
        pcall(function()
            if not target then return end
            local localChar = LocalPlayer.Character
            if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end

            local root = localChar.HumanoidRootPart
            local targetRoot = target:FindFirstChild("HumanoidRootPart")
            if not targetRoot then return end

            if tick() - lastAttack >= 0.05 then
                lastAttack = tick()

                for _, skillName in ipairs(SkillList) do
                    local offset = targetRoot.CFrame.LookVector * -2
                    root.CFrame = targetRoot.CFrame + offset

                    local remote = SkillRemotes[skillName]
                    if remote then
                        remote:FireServer(true)
                        task.wait(0.005)
                        remote:FireServer(false)
                    else
                        local gui = LocalPlayer:FindFirstChild("PlayerGui")
                        local mainUI = gui and gui:FindFirstChild("MainUI")
                        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
                        if container then
                            local button = container:FindFirstChild(skillName)
                            if button and button:IsA("ImageButton") then
                                for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
                                    if conn.Function then
                                        pcall(conn.Function)
                                    end
                                end
                                pcall(function() button:Activate() end)
                            end
                        end

                        local net = ReplicatedStorage:FindFirstChild("Modules")
                                    and ReplicatedStorage.Modules:FindFirstChild("Network")
                                    and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
                        if net and typeof(net.FireServer) == "function" then
                            net:FireServer("UseActorAbility", skillName)
                        end
                    end

                    task.wait(0.01)
                end
            end
        end)
    end

    local function StartLoop()
        if loopRunning then return end
        loopRunning = true
        task.spawn(function()
            while Active do
                local char = LocalPlayer.Character
                if not (char and KillersList[char.Name]) then
                    CurrentTarget = nil
                    task.wait(0.5)
                    continue
                end

                if not CurrentTarget 
                   or not CurrentTarget.Parent 
                   or not CurrentTarget:FindFirstChildOfClass("Humanoid") 
                   or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
                    CurrentTarget = GetClosestSurvivor()
                end
                if CurrentTarget then
                    KillTarget(CurrentTarget)
                end
                task.wait(0.01)
            end
            loopRunning = false
        end)
    end

    -- üü¢ N√∫t d·∫°ng code1
    FarmTab:Toggle("Killers Farm V2", Active, "T·ª± ƒë·ªông gi·∫øt ng∆∞·ªùi s·ªëng s√≥t", function(Value)
        Active = Value
        if Active then
            StartLoop()
        end
    end)
end


do
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local solveGeneratorCooldown = false
local genDelay = 0.75
local currentCharacter
local Spectators = {}
local isInGame, Survivor = false, false

-- üü• Killer nguy hi·ªÉm
local DangerousKillers = {
    ["Slasher"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- üü¢ Ki·ªÉm tra killer g·∫ßn generator
local function isKillerNearGenerator(generatorPos, distance)
    local killersFolder = workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return false end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            if DangerousKillers[killer.Name] then
                local dist = (killer.HumanoidRootPart.Position - generatorPos).Magnitude
                if dist <= distance then
                    return true
                end
            end
        end
    end
    return false
end

-- üü¢ T√¨m generator ch∆∞a xong
local function getUnfinishedGenerators()
    local list = {}
    local map = workspace:FindFirstChild("Map") 
        and workspace.Map:FindFirstChild("Ingame") 
        and workspace.Map.Ingame:FindFirstChild("Map")
    if map then
        for _, gen in ipairs(map:GetChildren()) do
            if gen.Name == "Generator" 
                and gen:FindFirstChild("Progress") 
                and gen.Progress.Value < 100 then
                table.insert(list, gen)
            end
        end
    end

    genDelay = (#list == 1) and 1.5 or 0.75
    return list
end

-- üü¢ H√†m s·ª≠a 1 generator
local function fixOneGenerator(gen)
    if solveGeneratorCooldown then return end
    if not currentCharacter or not currentCharacter:FindFirstChild("HumanoidRootPart") then return end

    local genCFrame = gen:GetPivot()
    local goalPos = (genCFrame * CFrame.new(0, 0, -6)).Position

    if isKillerNearGenerator(goalPos, 45) then
        print("‚ö†Ô∏è B·ªè qua generator v√¨ killer g·∫ßn!")
        return
    end

    -- Teleport t·ªõi gen (1 l·∫ßn)
    currentCharacter:PivotTo(CFrame.new(goalPos))
    task.wait(0.25)

    -- Chu·∫©n b·ªã prompt
    local prompt = gen:FindFirstChild("Main") and gen.Main:FindFirstChild("Prompt")
    if prompt then
        prompt.HoldDuration = 0
        prompt.RequiresLineOfSight = false
        prompt.MaxActivationDistance = 99999
    end

    -- ·∫§n m·ªü gen 3 l·∫ßn c·ª±c nhanh (gi·ªëng b·∫£n g·ªëc)
    if prompt then
        pcall(function()
            for i = 1, 3 do
                prompt:InputHoldBegin()
                task.wait(0)
                prompt:InputHoldEnd()
            end
        end)
    end

    -- G·ª≠i t√≠n hi·ªáu s·ª≠a gen
    if gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
        pcall(function()
            gen.Remotes.RE:FireServer()
        end)
    end

    -- Cooldown tr√°nh spam
    solveGeneratorCooldown = true
    task.delay(genDelay, function()
        solveGeneratorCooldown = false
    end)
end

-- ‚úÖ Toggle ch√≠nh (Fluent style)
FarmTab:Toggle("Survivors Farm V2", _G.SurvivorsFarm or false, "T·ª± ƒë·ªông s·ª≠a m√°y ph√°t ƒëi·ªán", function(Value)
    _G.SurvivorsFarm = Value
    StopTween(_G.SurvivorsFarm)
end)

-- ‚úÖ V√≤ng l·∫∑p ch√≠nh
task.spawn(function()
    while task.wait(0.1) do
        if _G.SurvivorsFarm then
            -- c·∫≠p nh·∫≠t spectators
            Spectators = {}
            for _, v in ipairs(workspace:WaitForChild("Players"):WaitForChild("Spectating"):GetChildren()) do
                table.insert(Spectators, v.Name)
            end
            isInGame = not table.find(Spectators, LP.Name)

            -- ki·ªÉm tra survivor
            local survivorsFolder = workspace.Players:FindFirstChild("Survivors")
            Survivor = survivorsFolder 
                and (survivorsFolder:FindFirstChild(LP.Name) 
                or table.find(survivorsFolder:GetChildren(), LP.Character))

            -- n·∫øu l√† survivor v√† ƒëang trong game
            if Survivor and isInGame then
                local survivorsFolder = workspace.Players:WaitForChild("Survivors")
                for _, surv in ipairs(survivorsFolder:GetChildren()) do
                    if surv:GetAttribute("Username") == LP.Name then
                        currentCharacter = surv
                        break
                    end
                end

                -- t√¨m v√† s·ª≠a gen
                local gens = getUnfinishedGenerators()
                for _, gen in ipairs(gens) do
                    if not _G.SurvivorsFarm then break end
                    fixOneGenerator(gen)
                    -- ƒë·ª£i cooldown tr∆∞·ªõc khi sang gen kh√°c
                    while solveGeneratorCooldown and _G.SurvivorsFarm do
                        task.wait(0.05)
                    end
                end
            end
        end
    end
end)
end

FarmTab:Seperator("Generator");

do
    local solveGeneratorCooldown = false
    _G.AutoFinishGen = _G.AutoFinishGen or false
    _G.GenDelay = _G.GenDelay or 2 -- m·∫∑c ƒë·ªãnh 2s, ƒë·ªÉ global ƒë·ªÉ thread c√≥ th·ªÉ ƒë·ªçc realtime

    -- üß≠ H√†m t√¨m generator g·∫ßn nh·∫•t
    local function getClosestGenerator()
        local char = game.Players.LocalPlayer.Character
        if not char or not char.PrimaryPart then return nil end

        local root = char.PrimaryPart
        local closest, shortestDist = nil, math.huge

        local mapContainer = workspace:FindFirstChild("Map")
        if mapContainer then
            local ingame = mapContainer:FindFirstChild("Ingame")
            if ingame then
                local map = ingame:FindFirstChild("Map")
                if map then
                    for _, obj in ipairs(map:GetChildren()) do
                        if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                            local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                            if dist < shortestDist then
                                closest = obj
                                shortestDist = dist
                            end
                        end
                    end
                end
            end
        end
        return closest
    end

    -- üß© N√∫t Finish generator th·ªß c√¥ng
    FarmTab:Button("Finish Generator", function()
        if solveGeneratorCooldown then 
            print("‚è≥ Please wait before trying again!") 
            return
        end
        if _G.AutoFinishGen then
            print("‚ùå Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(_G.GenDelay, function()
                solveGeneratorCooldown = false
            end)
        else
            print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y generator kh·∫£ d·ª•ng!")
        end
    end)

    -- üîÅ Toggle Auto Finish Generator
    FarmTab:Toggle("Auto Finish Generator", _G.AutoFinishGen, "T·ª± ƒë·ªông ho√†n th√†nh m√°y ph√°t ƒëi·ªán", function(state)
        _G.AutoFinishGen = state

        if state then
            if solveGeneratorCooldown then
                print("‚ö†Ô∏è Please wait cooldown before enabling Auto Finish!") 
                _G.AutoFinishGen = false
                return
            end

            task.spawn(function()
                while _G.AutoFinishGen do
                    local gen = getClosestGenerator()
                    if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                        gen.Remotes.RE:FireServer()
                    end

                    solveGeneratorCooldown = true
                    -- üß† d√πng _G.GenDelay realtime, kh√¥ng b·ªã gi·ªØ gi√° tr·ªã c≈©
                    task.wait(_G.GenDelay)
                    solveGeneratorCooldown = false
                end
            end)
        else
            solveGeneratorCooldown = false
        end
    end)

    -- üéöÔ∏è Slider ch·ªânh delay (chu·∫©n Fluent)
    -- ‚öôÔ∏è D·∫°ng ƒë√∫ng c·ªßa Fluent slider: Tab:Slider("T√™n", min, max, default, callback)
    FarmTab:Slider("Generator Delay", 2, 10, _G.GenDelay, function(v)
        _G.GenDelay = v
        print("‚è± Delay set to:", v)
    end)
end

FarmTab:Seperator("Item");

do
    local Players = game:GetService("Players")
    local LP = Players.LocalPlayer
    local pickDelay = 0.2 -- delay m·∫∑c ƒë·ªãnh
    _G.PickupItem = _G.PickupItem or false

    -- üß≠ H√†m nh·∫∑t item g·∫ßn nh·∫•t
    local function pickUpNearest()
        local map = workspace:FindFirstChild("Map")
                    and workspace.Map:FindFirstChild("Ingame")
                    and workspace.Map.Ingame:FindFirstChild("Map")

        if not map or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then return end

        local oldCFrame = LP.Character.HumanoidRootPart.CFrame
        for _, item in ipairs(map:GetChildren()) do
            if item:IsA("Tool") and item:FindFirstChild("ItemRoot")
               and item.ItemRoot:FindFirstChild("ProximityPrompt") then
                LP.Character.HumanoidRootPart.CFrame = item.ItemRoot.CFrame
                task.wait(0.3)
                fireproximityprompt(item.ItemRoot.ProximityPrompt)
                task.wait(0.4)
                LP.Character.HumanoidRootPart.CFrame = oldCFrame
                break
            end
        end
    end

    -- üß© N√∫t nh·∫∑t item 1 l·∫ßn (chu·∫©n Fluent)
    FarmTab:Button("Pick Up Item", function()
        pickUpNearest()
    end)

    -- üîÅ Toggle auto nh·∫∑t item (chu·∫©n Fluent)
    FarmTab:Toggle("Auto Pick Up Item", _G.PickupItem, "T·ª± ƒë·ªông nh·∫∑t v·∫≠t ph·∫©m g·∫ßn nh·∫•t", function(state)
        _G.PickupItem = state
        if not state then return end

        task.spawn(function()
            while _G.PickupItem do
                pickUpNearest()
                task.wait(pickDelay)
            end
        end)
    end)
end


---------------------------------------------------------------------------------
-- Main
---------------------------------------------------------------------------------

MainTab:Seperator("Shedletky");

do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local enabled = false
    local cooldown = false
    local lastTarget = nil
    local maxDistance = 5

    local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli", "Quest666" }
    local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

    -- Slash button + remote
    local slashButton, slashRemote, slashConnections = nil, nil, {}

    local function findSlashRemote()
        if slashRemote then return slashRemote end
        if not slashButton then return nil end
        for _, conn in ipairs(getconnections(slashButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                for _, v in pairs(getupvalues(f)) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        slashRemote = v
                        warn("[AutoSlash] Found Slash Remote:", v:GetFullName())
                        return slashRemote
                    end
                end
            end
        end
        return nil
    end

    local function initSlashButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        slashButton = container and container:FindFirstChild("Slash")
        if slashButton and slashButton:IsA("ImageButton") then
            slashConnections = getconnections(slashButton.MouseButton1Click)
            findSlashRemote()
        end
    end

    initSlashButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initSlashButton()
    end)

    local function useSlash()
        if slashRemote then
            pcall(function()
                slashRemote:FireServer(true)
                task.delay(0.05, function()
                    slashRemote:FireServer(false)
                end)
            end)
        elseif slashButton then
            for _, conn in ipairs(slashConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() slashButton:Activate() end)
        end
    end

    -- Toggle ki·ªÉu MainTab
    MainTab:Toggle("Auto Slash", enabled, "T·ª± ƒë·ªông d·ªãch chuy·ªÉn v√† t·∫•n c√¥ng", function(val)
        enabled = val
    end)

    -- Slider ki·ªÉu SeaTab
    MainTab:Slider("Slash Distance", 1, 50, maxDistance, function(v)
        maxDistance = v
    end)

    -- Helper
    local function isBehindTarget(hrp, targetHRP)
        local direction = targetHRP.CFrame.LookVector
        local toPlayer = (hrp.Position - targetHRP.Position)
        local distance = toPlayer.Magnitude
        local isBehind = toPlayer:Dot(direction) < -0.5
        return distance <= maxDistance and isBehind
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if not enabled or cooldown then return end

        local char = lp.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
        local hrp = char.HumanoidRootPart

        for _, name in ipairs(killerNames) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("HumanoidRootPart") then
                local kHRP = killer.HumanoidRootPart

                if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
                    cooldown = true
                    lastTarget = killer

                    -- Teleport ra sau l∆∞ng
                    local backPos = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                    hrp.CFrame = CFrame.new(backPos, kHRP.Position)

                    -- Gi·ªØ v·ªã tr√≠ + spam Slash 1 gi√¢y
                    local start = tick()
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not (char and char.Parent and kHRP and kHRP.Parent) then
                            if connection then connection:Disconnect() end
                            return
                        end
                        if tick() - start >= 1 then
                            if connection then connection:Disconnect() end
                            task.delay(2, function()
                                cooldown = false
                                lastTarget = nil
                            end)
                            return
                        end

                        local back = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                        hrp.CFrame = CFrame.new(back, kHRP.Position)

                        -- G·ªçi skill Slash qua UI Remote
                        useSlash()
                    end)

                    break
                end
            end
        end
    end)
end





do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local healEnabled = false
    local healHPThreshold = 50
    local healDistance = 50

    -- Heal button + remote
    local healButton, healRemote, healConnections = nil, nil, {}

    -- T√¨m RemoteEvent t·ª´ button Heal
    local function findHealRemote()
        if healRemote then return healRemote end
        if not healButton then return nil end
        for _, conn in ipairs(getconnections(healButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                local upvals = getupvalues(f)
                for _, v in pairs(upvals) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        healRemote = v
                        warn("[AutoHeal] Found Heal Remote:", v:GetFullName())
                        return healRemote
                    end
                end
            end
        end
        return nil
    end

    local function initHealButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        healButton = container and container:FindFirstChild("FriedChicken")
        if healButton and healButton:IsA("ImageButton") then
            healConnections = getconnections(healButton.MouseButton1Click)
            findHealRemote()
        end
    end

    initHealButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initHealButton()
    end)

    local function useHeal()
        if healRemote then
            pcall(function()
                healRemote:FireServer(true)
                task.delay(0.05, function()
                    healRemote:FireServer(false)
                end)
            end)
        elseif healButton then
            for _, conn in ipairs(healConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() healButton:Activate() end)
        end
    end

    -- Toggle + slider UI ki·ªÉu Fluent
    MainTab:Toggle("Auto Heal", healEnabled, "T·ª± ƒë·ªông h·ªìi m√°u khi HP th·∫•p v√† kh√¥ng c√≥ k·∫ª g·∫ßn", function(val)
        healEnabled = val
    end)

    MainTab:Slider("Heal HP", 1, 100, healHPThreshold, function(v)
        healHPThreshold = v
    end)

    MainTab:Slider("Heal Distance", 1, 150, healDistance, function(v)
        healDistance = v
    end)

    -- Helpers -------------------------------------------------------------
    local function getPlayersFolders()
        local pf = workspace:FindFirstChild("Players")
        if not pf then return nil, nil, nil end
        return pf, pf:FindFirstChild("Killers"), pf:FindFirstChild("Survivors")
    end

    local function belongsToMe(m)
        if not (m and m:IsA("Model")) then return false end
        if m:GetAttribute("Username") == lp.Name then return true end
        local UsernameSV = m:FindFirstChild("Username")
        if UsernameSV and typeof(UsernameSV.Value) == "string" and UsernameSV.Value == lp.Name then return true end
        local Owner = m:FindFirstChild("Owner") or m:FindFirstChild("Player")
        if Owner and Owner.Value == lp then return true end
        local uidAttr = m:GetAttribute("UserId")
        if uidAttr and tonumber(uidAttr) == lp.UserId then return true end
        if m.Name == lp.Name then return true end
        return false
    end

    local function getMyShedletsky()
        local pf, killersFolder, survivorsFolder = getPlayersFolders()
        local candidates = {}

        local function scan(container)
            if not container then return end
            for _, d in ipairs(container:GetDescendants()) do
                if d:IsA("Model") and d.Name == "Shedletsky" and d:FindFirstChild("Humanoid") and d:FindFirstChild("HumanoidRootPart") then
                    if belongsToMe(d) then table.insert(candidates, d) end
                end
            end
        end

        scan(killersFolder)
        scan(survivorsFolder)
        scan(workspace)

        if #candidates == 0 then return nil, nil, nil end

        local basePos
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            basePos = lp.Character.HumanoidRootPart.Position
        end

        local best, bestDist = candidates[1], math.huge
        if basePos then
            for _, m in ipairs(candidates) do
                local hrp = m:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local d = (hrp.Position - basePos).Magnitude
                    if d < bestDist then best, bestDist = m, d end
                end
            end
        end

        local hum = best:FindFirstChildOfClass("Humanoid")
        local hrp = best:FindFirstChild("HumanoidRootPart")
        return best, hum, hrp
    end

    local function getNearestKillerDist(fromHRP, myModel)
        local _, killersFolder = getPlayersFolders()
        if not (killersFolder and fromHRP) then return math.huge end
        local nearest = math.huge
        for _, k in ipairs(killersFolder:GetChildren()) do
            if k ~= myModel then
                local khrp = k:FindFirstChild("HumanoidRootPart")
                if khrp then
                    local d = (fromHRP.Position - khrp.Position).Magnitude
                    if d < nearest then nearest = d end
                end
            end
        end
        return nearest
    end

    -- Main loop ----------------------------------------------------------
    RunService.Heartbeat:Connect(function()
        if not healEnabled then return end

        local myModel, myHumanoid, myHRP = getMyShedletsky()
        if not (myModel and myHumanoid and myHRP) then return end
        if myHumanoid.Health <= 0 then return end

        local nearestDist = getNearestKillerDist(myHRP, myModel)

        if myHumanoid.Health <= healHPThreshold and nearestDist >= healDistance then
            useHeal()
        end
    end)
end





MainTab:Seperator("Two Time");

--// Auto Backstab Unified (AI Aimbot + Player Aimbot, Fluent UI Version)
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- ‚öôÔ∏è CONFIG
    local ModeList = { "AI Aimbot", "Player Aimbot" }
    _G.BackstabMode = "AI Aimbot"
    _G.AutoBackstab = false
    _G.BackstabRadius = 18

    local backstabDelay = 0.01
    local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli", "Quest666" }
    local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

    local ANIM_IDS = {
        "115194624791339", "86545133269813", "89448354637442",
        "115194624791339", "89448354637442", "86545133269813",
        "77119710693654", "107640065977686", "112902284724598",
    }
    local KILLER_MODELS = {
        ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
        ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true,
    }

    -- üß≠ UI
    MainTab:Dropdown("Backstab Mode", ModeList, _G.BackstabMode, function(value)
        _G.BackstabMode = value
        print("üéØ Backstab Mode:", value)
    end)

    MainTab:Toggle("Auto Backstab V2", _G.AutoBackstab, "T·ª± ƒë·ªông t·∫•n c√¥ng k·∫ª gi·∫øt ng∆∞·ªùi", function(state)
        _G.AutoBackstab = state
        print("üî™ Auto Backstab:", state and "ON" or "OFF")
    end)

    MainTab:Slider("Backstab Radius", 1, 100, _G.BackstabRadius, function(v)
        _G.BackstabRadius = v
        print("üìè Check Radius set to:", v)
    end)

    -- ‚öôÔ∏è REMOTE HANDLER
    local daggerButton, daggerRemote, daggerConnections = nil, nil, {}

    local function findDaggerRemote()
        if daggerRemote then return daggerRemote end
        if not daggerButton then return nil end
        for _, conn in ipairs(getconnections(daggerButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                local upvals = getupvalues(f)
                for _, v in pairs(upvals) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        daggerRemote = v
                        warn("[Backstab] Found Dagger Remote:", v:GetFullName())
                        return daggerRemote
                    end
                end
            end
        end
        return nil
    end

    local function initDaggerButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        daggerButton = container and container:FindFirstChild("Dagger")
        if daggerButton and daggerButton:IsA("ImageButton") then
            daggerConnections = getconnections(daggerButton.MouseButton1Click)
            findDaggerRemote()
        end
    end

    initDaggerButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initDaggerButton()
    end)

    local function useDagger()
        if daggerRemote then
            pcall(function()
                daggerRemote:FireServer(true)
                task.delay(0.05, function()
                    daggerRemote:FireServer(false)
                end)
            end)
        elseif daggerButton then
            for _, conn in ipairs(daggerConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() daggerButton:Activate() end)
        end
    end

    -- üß† CORE LOGIC
    local function getCharacter()
        local ch = lp.Character
        if ch and ch.Parent then
            local hrp = ch:FindFirstChild("HumanoidRootPart")
            local humanoid = ch:FindFirstChildOfClass("Humanoid")
            return ch, humanoid, hrp
        end
        return nil, nil, nil
    end

    local function isPlayingTargetAnimation(humanoid)
        if not humanoid then return false end
        for _, t in ipairs(humanoid:GetPlayingAnimationTracks()) do
            local animId = tostring(t.Animation.AnimationId or "")
            for _, id in ipairs(ANIM_IDS) do
                if animId:find(id, 1, true) then
                    return true
                end
            end
        end
        return false
    end

    local function teleportBehind(targetHRP, myHRP)
        local look = targetHRP.CFrame.LookVector
        local destPos = targetHRP.Position - look * 2
        myHRP.CFrame = CFrame.new(destPos, destPos + look)
    end

    local function isBehindTarget(targetHRP, myHRP)
        local look = targetHRP.CFrame.LookVector
        local dir = (myHRP.Position - targetHRP.Position).Unit
        return look:Dot(dir) < -0.5
    end

    local function getNearbyKillers(position)
        local killers = {}
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= lp and plr.Character then
                local char = plr.Character
                local hrp = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
                if hrp and KILLER_MODELS[char.Name] then
                    local dist = (hrp.Position - position).Magnitude
                    if dist <= _G.BackstabRadius then
                        table.insert(killers, {model = char, hrp = hrp, dist = dist})
                    end
                end
            end
        end
        return killers
    end

    local function getNearbyAIKillers(hrp)
        local killers = {}
        for _, name in ipairs(killerNames) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("HumanoidRootPart") then
                local kHRP = killer.HumanoidRootPart
                local dist = (kHRP.Position - hrp.Position).Magnitude
                if dist <= _G.BackstabRadius then
                    table.insert(killers, {model = killer, hrp = kHRP, dist = dist})
                end
            end
        end
        return killers
    end

    -- üîÑ LOOP
    local cooldown = false
    local lastTarget = nil

    RunService.Heartbeat:Connect(function()
        if not _G.AutoBackstab or cooldown then return end
        local char, humanoid, myHRP = getCharacter()
        if not (char and humanoid and myHRP) then return end

        if char.Name ~= "TwoTime" then return end

        if _G.BackstabMode == "Player Aimbot" then
            if isPlayingTargetAnimation(humanoid) then
                local killers = getNearbyKillers(myHRP.Position)
                if #killers > 0 then
                    table.sort(killers, function(a,b) return a.dist < b.dist end)
                    teleportBehind(killers[1].hrp, myHRP)
                end
            end

        elseif _G.BackstabMode == "AI Aimbot" then
            local killers = getNearbyAIKillers(myHRP)
            if #killers > 0 then
                table.sort(killers, function(a,b) return a.dist < b.dist end)
                local target = killers[1]
                if target.model ~= lastTarget and isBehindTarget(target.hrp, myHRP) then
                    cooldown = true
                    lastTarget = target.model

                    local start = tick()
                    local conn
                    conn = RunService.Heartbeat:Connect(function()
                        if not (char and char.Parent and target.hrp and target.hrp.Parent) then
                            if conn then conn:Disconnect() end
                            return
                        end
                        if tick() - start >= 0.7 then
                            if conn then conn:Disconnect() end
                            task.delay(10, function()
                                cooldown = false
                                lastTarget = nil
                            end)
                            return
                        end

                        teleportBehind(target.hrp, myHRP)
                        useDagger()
                    end)
                end
            end
        end
    end)

    lp.CharacterAdded:Connect(function()
        task.wait(1)
        print("üîÑ Character respawned/changed, Auto Backstab v·∫´n ho·∫°t ƒë·ªông (n·∫øu model = 'TwoTime').")
    end)
end

MainTab:Seperator("007n7");


do
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local running = false
    local animTrack
    local InvisibleEnabled = false

    local SpecialModels = {
        ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
        ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
        ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true,
        ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
        ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true, ["Veeronica"] = true
    }

    local function getHumanoid()
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        return char:FindFirstChildOfClass("Humanoid"), char
    end

    local function getAnimator(humanoid)
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then
            animator = Instance.new("Animator")
            animator.Parent = humanoid
        end
        return animator
    end

    local function playInvisibleAnim(humanoid)
        local animator = getAnimator(humanoid)
        if not animTrack or not animTrack.IsPlaying then
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://75804462760596"
            animTrack = animator:LoadAnimation(animation)
            animTrack.Looped = true
            animTrack:Play()
            animTrack:AdjustSpeed(0)
        end
    end

    local function stopInvisibleAnim()
        if animTrack and animTrack.IsPlaying then
            animTrack:Stop()
            animTrack = nil
        end
    end

    local function isSpecialModel(char)
        if not char then return false end
        if SpecialModels[char.Name] then return true end
        for _, child in ipairs(char:GetChildren()) do
            if SpecialModels[child.Name] then return true end
        end
        return false
    end

    local function handleToggle(enabled)
        InvisibleEnabled = enabled
        local humanoid, char = getHumanoid()
        if not humanoid or not char then return end

        if enabled then
            running = true
            task.spawn(function()
                while running and InvisibleEnabled do
                    humanoid, char = getHumanoid()
                    if not humanoid or not char then
                        task.wait(0.5)
                        continue
                    end
                    if isSpecialModel(char) then
                        playInvisibleAnim(humanoid)
                    else
                        stopInvisibleAnim()
                    end
                    task.wait(0.5)
                end
            end)
        else
            running = false
            stopInvisibleAnim()
        end
    end

    LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(1)
        if InvisibleEnabled and isSpecialModel(char) then
            handleToggle(true)
        end
    end)

    -- === Toggle Fluent d·∫°ng n√∫t chu·∫©n ===
    MainTab:Toggle("Instant Invisible", InvisibleEnabled, "Khi b·∫≠t t√†ng h√¨nh ngay l·∫≠p t·ª©c", function(value)
        handleToggle(value)
    end)
end




do
    -- Invisible upon Cloning (sandboxed)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local running = false
    local animTrack

    local function getHumanoid()
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        return char:FindFirstChildOfClass("Humanoid"), char
    end

    local function getAnimator(humanoid)
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then
            animator = Instance.new("Animator")
            animator.Parent = humanoid
        end
        return animator
    end

    local function playInvisibleAnim(humanoid)
        local animator = getAnimator(humanoid)
        if not animTrack or not animTrack.IsPlaying then
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://75804462760596"
            animTrack = animator:LoadAnimation(animation)
            animTrack.Looped = true
            animTrack:Play()
            animTrack:AdjustSpeed(0)
        end
    end

    local function stopInvisibleAnim()
        if animTrack and animTrack.IsPlaying then
            animTrack:Stop()
            animTrack = nil
        end
    end

    local function handleToggle(enabled)
        local humanoid, char = getHumanoid()
        if not humanoid or not char then return end

        if enabled then
            running = true
            task.spawn(function()
                while running do
                    humanoid, char = getHumanoid()
                    if not humanoid or not char then break end

                    local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
                    local root = char:FindFirstChild("HumanoidRootPart")

                    if torso and torso.Transparency ~= 0 then
                        playInvisibleAnim(humanoid)
                        if root then root.Transparency = 0.4 end
                    else
                        stopInvisibleAnim()
                        if root then root.Transparency = 1 end
                    end

                    task.wait(0.5)
                end
            end)
        else
            running = false
            stopInvisibleAnim()
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Transparency = 1
            end
        end
    end

    -- === Toggle Fluent ch√≠nh (b·ªè ‚ÄúInstantInvisible‚Äù) ===
    MainTab:Toggle("Invisible if cloned", _G.InvisibleClone, "T·ª± ƒë·ªông t√†ng h√¨nh khi t·∫°o b·∫£n sao", function(value)
        _G.InvisibleClone = value
        handleToggle(_G.InvisibleClone)
    end)
end


MainTab:Seperator("Chance");

do
    -- ================= D·ªäCH V·ª§ =================
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Stats = game:GetService("Stats")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local LocalPlayer = Players.LocalPlayer

    local active = false
    local useOffset = true
    local predictionMode = "Speed"
    local aimMode = "Normal"
    local aimDuration = 1.7
    local fasterDuration = 1.5
    local spinDuration = 0.5
    local aimTargets = {"Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli", "Quest666"}

    local Humanoid, HRP = nil, nil
    local originalWS, originalJP, originalAutoRotate = nil, nil, nil
    local aiming = false
    local prevFlintVisibleAim = false
    local lastTriggerTime = 0

    local autoCoinflip = false
    local coinflipTargetCharge = 3
    local coinflipCooldown = 0.15
    local lastCoinflipTime = 0

    local blockCoinflipWhenClose = true
    local coinflipBlockDist = 50

    local RemoteEvent
    pcall(function()
        RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
    end)

    -- ================= FLUENT DROPDOWNS =================
    local AimModeList = {"Normal", "Faster", "Reflex"}
    MainTab:Dropdown("Aim Mode", AimModeList, aimMode, function(value)
        aimMode = value
    end)

    local PredictionList = {"Speed", "Ping", "front", "No Lag"}
    MainTab:Dropdown("Prediction Mode", PredictionList, predictionMode, function(value)
        predictionMode = value
    end)

    local CoinflipChargeList = {"1 Point", "2 Point", "3 Point"}
    MainTab:Dropdown("Coinflip Charge", CoinflipChargeList, "3 Point", function(value)
        local num = tonumber(value and value:match("%d+"))
        if num then coinflipTargetCharge = num end
    end)

    MainTab:Toggle("Safe Mode (Coinflip)", blockCoinflipWhenClose, "Kh√¥ng tung xu khi c√≥ killers ·ªü g·∫ßn", function(state)
        blockCoinflipWhenClose = state
    end)

    MainTab:Toggle("Enable Offset", useOffset, "Th√™m t√≠nh to√°n ƒë·ªô l·ªách ƒë·ªÉ aim chu·∫©n h∆°n", function(state)
        useOffset = state
    end)

    MainTab:Toggle("Auto Aim Shoot", active, "T·ª± ƒë·ªông aim khi d√πng k·ªπ nƒÉng b·∫Øn", function(state)
        active = state
    end)

    MainTab:Toggle("Auto Coin Flip", autoCoinflip, "T·ª± ƒë·ªông tung ƒë·ªìng xu theo ƒëi·ªÉm ƒë√£ ch·ªçn", function(state)
        autoCoinflip = state
    end)

    MainTab:Slider("Coinflip Safe Distance", 10, 300, coinflipBlockDist, function(val)
        coinflipBlockDist = val
    end)

    -- ================= CHARACTER SETUP =================
    local function setupCharacter(char)
        Humanoid = char:WaitForChild("Humanoid")
        HRP = char:WaitForChild("HumanoidRootPart")
    end
    if LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
    LocalPlayer.CharacterAdded:Connect(setupCharacter)

    -- ================= HELPER FUNCS =================
    local function getValidTarget()
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local char = plr.Character
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    for _, targetName in ipairs(aimTargets) do
                        if char.Name:lower():find(targetName:lower()) then
                            return hrp
                        end
                    end
                end
            end
        end
        return nil
    end

    local function getPingSeconds()
        local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
        if pingStat then return pingStat:GetValue() / 1000 end
        return 0.1
    end

    local function isFlintlockVisible()
        if not LocalPlayer.Character then return false end
        local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
        if not flint then return false end
        if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
            flint = flint:FindFirstChildWhichIsA("BasePart", true)
            if not flint then return false end
        end
        return flint.Transparency < 1
    end

    local movementThreshold = 0.5
    local function getPredictedAimPosPing(targetHRP)
        local ping = getPingSeconds()
        local velocity = targetHRP.Velocity
        if velocity.Magnitude <= movementThreshold then return targetHRP.Position end
        return targetHRP.Position + (velocity * ping)
    end

    local function getPredictedAimPosInfrontHRPPing(targetHRP)
        local ping = getPingSeconds()
        local studs = ping * 60
        if targetHRP.Velocity.Magnitude <= movementThreshold then return targetHRP.Position end
        return targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
    end

    local function computeAimPos(targetHRP)
        if predictionMode == "Ping" then
            return getPredictedAimPosPing(targetHRP)
        elseif predictionMode == "front" then
            return targetHRP.Position + targetHRP.CFrame.LookVector * 4
        elseif predictionMode == "No Lag" then
            return getPredictedAimPosInfrontHRPPing(targetHRP)
        else
            local velocity = targetHRP.Velocity
            if velocity.Magnitude > 0.1 then
                if useOffset and HRP then
                    local ok, toTarget = pcall(function() return (targetHRP.Position - HRP.Position).Unit end)
                    if not ok then return targetHRP.Position end
                    local moveDir = velocity.Unit
                    local dot = toTarget:Dot(moveDir)
                    if math.abs(dot) < 0.85 then
                        return targetHRP.Position + velocity * (4 / 60)
                    else
                        return targetHRP.Position
                    end
                else
                    return targetHRP.Position
                end
            else
                return targetHRP.Position
            end
        end
    end

    local function safeSetCFrame(newCF)
        if typeof(newCF) == "CFrame" and tostring(newCF) ~= "nan" and HRP then
            HRP.CFrame = newCF
        end
    end

    local function faceInstant(toPos)
        if not HRP or not toPos then return end
        local fromPos = HRP.Position
        if (toPos - fromPos).Magnitude < 0.01 then return end
        local lookAt = Vector3.new(toPos.X, fromPos.Y, toPos.Z)
        local targetCF = CFrame.new(fromPos, lookAt)
        safeSetCFrame(HRP.CFrame:Lerp(targetCF, 0.99))
    end

    -- ================= COINFLIP HELPERS =================
    local function getAbilityContainer()
        local ok, container = pcall(function()
            local gui = LocalPlayer:FindFirstChild("PlayerGui")
            if not gui then return nil end
            local mainUI = gui:FindFirstChild("MainUI")
            if not mainUI then return nil end
            return mainUI:FindFirstChild("AbilityContainer")
        end)
        if ok then return container end
        return nil
    end

    local function tryActivateButton(button)
        if not button then return false end
        pcall(function() if button.Activate then button:Activate() end end)
        local ok, conns = pcall(function()
            if type(getconnections) == "function" and button.MouseButton1Click then
                return getconnections(button.MouseButton1Click)
            end
            return nil
        end)
        if ok and conns then
            for _, conn in ipairs(conns) do
                pcall(function()
                    if conn.Function then conn.Function()
                    elseif conn.func then conn.func()
                    elseif conn.Fire then conn.Fire() end
                end)
            end
        end
        pcall(function() if button.Activated then button.Activated:Fire() end end)
        pcall(function() if button.MouseButton1Click then button.MouseButton1Click:Fire() end end)
        return true
    end

    local function findAbilityButtonByName(name)
        local container = getAbilityContainer()
        if not container then return nil end
        local btn = container:FindFirstChild(name)
        if btn then return btn end
        local lname = name:lower()
        for _, child in ipairs(container:GetChildren()) do
            if child.Name and child.Name:lower():find(lname) then return child end
            local found = child:FindFirstChildWhichIsA("ImageButton") or child:FindFirstChildWhichIsA("TextButton")
            if found and found.Name and found.Name:lower():find(lname) then
                return found
            end
        end
        return nil
    end

    local function clickCoinflipButton()
        local tryNames = {"CoinFlip", "Coin", "Reroll"}
        for _, n in ipairs(tryNames) do
            local b = findAbilityButtonByName(n)
            if b then
                if tryActivateButton(b) then return true end
            end
        end
        return false
    end

    local function findRerollContainer()
        local container = getAbilityContainer()
        if not container then return nil end
        local reroll = container:FindFirstChild("Reroll") or container:FindFirstChild("RerollAbility") or nil
        if reroll then return reroll end
        for _, child in ipairs(container:GetChildren()) do
            for _, obj in ipairs(child:GetDescendants()) do
                if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and obj.Text and tostring(obj.Text):match("%d") then
                    return child
                end
            end
        end
        return nil
    end

    local function getNearbyMaxNumber()
        local reroll = findRerollContainer()
        if not reroll then return nil end
        local maxNum = nil
        for _, obj in ipairs(reroll:GetDescendants()) do
            if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and obj.Text then
                for num in tostring(obj.Text):gmatch("%d+") do
                    local n = tonumber(num)
                    if n then
                        if not maxNum or n > maxNum then maxNum = n end
                    end
                end
            end
        end
        return maxNum
    end

    -- ================= MAIN LOOP =================
    RunService.RenderStepped:Connect(function()
        if active and Humanoid and HRP then
            local isVisible = isFlintlockVisible()
            if isVisible and not prevFlintVisibleAim and not aiming then
                lastTriggerTime = tick()
                aiming = true
            end
            prevFlintVisibleAim = isVisible

            if aiming then
                local elapsed = tick() - lastTriggerTime
                local duration = (aimMode == "Faster") and fasterDuration or aimDuration

                if aimMode == "Reflex" then
                    if elapsed <= spinDuration then
                        local spinProgress = elapsed / spinDuration
                        local spinAngle = math.rad(360 * spinProgress)
                        safeSetCFrame(CFrame.new(HRP.Position) * CFrame.Angles(0, spinAngle, 0))
                    elseif elapsed <= spinDuration + 0.7 then
                        if not originalWS then
                            originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                        end
                        Humanoid.AutoRotate = false
                        HRP.AssemblyAngularVelocity = Vector3.zero
                        local targetHRP = getValidTarget()
                        if targetHRP then faceInstant(computeAimPos(targetHRP)) end
                    else
                        aiming = false
                        if originalWS then
                            Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate = originalWS, originalJP, originalAutoRotate
                            originalWS, originalJP, originalAutoRotate = nil, nil, nil
                        end
                    end
                else
                    if elapsed <= duration then
                        if not originalWS then
                            originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                        end
                        Humanoid.AutoRotate = false
                        HRP.AssemblyAngularVelocity = Vector3.zero
                        local targetHRP = getValidTarget()
                        if targetHRP then faceInstant(computeAimPos(targetHRP)) end
                    else
                        aiming = false
                        if originalWS then
                            Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate = originalWS, originalJP, originalAutoRotate
                            originalWS, originalJP, originalAutoRotate = nil, nil, nil
                        end
                    end
                end
            end
        end

        -- COINFLIP
        if autoCoinflip then
            local tooClose = false
            if blockCoinflipWhenClose then
                local targetHRP = getValidTarget()
                if targetHRP and HRP then
                    if (targetHRP.Position - HRP.Position).Magnitude <= coinflipBlockDist then
                        tooClose = true
                    end
                end
            end

            if not tooClose then
                local maxNum = getNearbyMaxNumber()
                if not maxNum or maxNum < coinflipTargetCharge then
                    if tick() - lastCoinflipTime >= coinflipCooldown then
                        lastCoinflipTime = tick()
                        local ok = clickCoinflipButton()
                        if not ok and RemoteEvent then
                            pcall(function()
                                RemoteEvent:FireServer("UseActorAbility", "CoinFlip")
                            end)
                        end
                    end
                end
            end
        end
    end)
end




MainTab:Seperator("Noli");


--// ‚ö° Void Rush Aimbot (Fluent UI Version)
do
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    -- ====== CONFIG ======
    _G.VoidRushControl = false
    local DASH_SPEED = 80
    local ATTACK_RANGE = 6
    local ATTACK_INTERVAL = 0.2
    local PRIORITY_NAMES = {
        ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
        ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true, ["Veeronica"] = true,
        ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true
    }

    -- ====== STATE ======
    local isOverrideActive = false
    local connection
    local Humanoid, RootPart
    local lastState = nil
    local attackingLoop = nil

    -- üß© Character setup
    local function setupCharacter(character)
        Humanoid = character:WaitForChild("Humanoid")
        RootPart = character:WaitForChild("HumanoidRootPart")

        Humanoid.Died:Connect(function()
            stopOverride()
        end)
    end

    if LocalPlayer.Character then
        setupCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(setupCharacter)

    -- üéØ Target validator
    local function validTarget(p)
        if p == LocalPlayer then return false end
        local c = p.Character
        if not c then return false end
        local hrp = c:FindFirstChild("HumanoidRootPart")
        local hum = c:FindFirstChild("Humanoid")
        return hrp and hum and hum.Health > 0
    end

    -- üîç Find closest target (priority by whitelist)
    local function getClosestTarget()
        if not RootPart then return nil end

        local closestW, distW = nil, math.huge
        local closestA, distA = nil, math.huge

        for _, p in ipairs(Players:GetPlayers()) do
            if validTarget(p) then
                local hrp = p.Character.HumanoidRootPart
                local d = (hrp.Position - RootPart.Position).Magnitude

                if PRIORITY_NAMES[p.Name] and d < distW then
                    distW = d
                    closestW = p
                end
                if d < distA then
                    distA = d
                    closestA = p
                end
            end
        end

        return closestW or closestA, distW < math.huge and distW or distA
    end

    -- ‚öîÔ∏è Attempt attack (Tool:Activate)
    local function attemptAttack()
        local char = LocalPlayer.Character
        if not char then return end
        local tool = char:FindFirstChildOfClass("Tool")
        if tool and tool.Parent == char then
            pcall(function() tool:Activate() end)
        end
    end

    -- üåÄ Control Void Rush
    local function startOverride()
        if isOverrideActive or not Humanoid or not RootPart then return end
        isOverrideActive = true

        connection = RunService.RenderStepped:Connect(function()
            if not Humanoid or not RootPart or Humanoid.Health <= 0 then return end
            local target, dist = getClosestTarget()

            if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = target.Character.HumanoidRootPart
                local dir = hrp.Position - RootPart.Position
                local horizontal = Vector3.new(dir.X, 0, dir.Z)

                if horizontal.Magnitude > 0.1 then
                    RootPart.CFrame = CFrame.new(RootPart.Position, Vector3.new(hrp.Position.X, RootPart.Position.Y, hrp.Position.Z))
                    RootPart.AssemblyLinearVelocity = horizontal.Unit * DASH_SPEED
                else
                    RootPart.AssemblyLinearVelocity = Vector3.zero
                end
            else
                RootPart.AssemblyLinearVelocity = Vector3.zero
            end
        end)

        attackingLoop = task.spawn(function()
            while isOverrideActive do
                local target, dist = getClosestTarget()
                if target and dist and dist <= ATTACK_RANGE then
                    attemptAttack()
                end
                task.wait(ATTACK_INTERVAL)
            end
        end)
    end

    function stopOverride()
        if not isOverrideActive then return end
        isOverrideActive = false

        if connection then
            connection:Disconnect()
            connection = nil
        end
        if RootPart then
            RootPart.AssemblyLinearVelocity = Vector3.zero
        end
    end

    -- üîÑ Check Void Rush State
    RunService.RenderStepped:Connect(function()
        if not _G.VoidRushControl or not Humanoid then return end
        local state = Humanoid.Parent and Humanoid.Parent:GetAttribute("VoidRushState")
        if state ~= lastState then
            lastState = state
            if state == "Dashing" then
                startOverride()
            else
                stopOverride()
            end
        end
    end)

    -- üß≠ Fluent Toggle
    MainTab:Toggle("Void Rush Aimbot", _G.VoidRushControl, "T·ª± ƒë·ªông aim v√†o ng∆∞·ªùi g·∫ßn nh·∫•t", function(v)
        _G.VoidRushControl = v
        if not v then
            stopOverride()
        end
    end)
end


MainTab:Seperator("1x1x1x1");

--// ‚ö° 1x1x1x1 MassInfection Aimbot (Fluent UI Version)
do
    -- ‚öôÔ∏è STATE
    local aimModes = {
        "One Player",
        "Multi Players",
        "Teleport"
    }

    _G.AimMode = "One Player"
    _G.MassAimOn = false
    _G.PredictMovement = false

    -- üß© GUI
    MainTab:Dropdown("Aim Mode", aimModes, _G.AimMode, function(value)
        _G.AimMode = value
    end)

    MainTab:Toggle("MassInfection Aimbot", _G.MassAimOn, "Auto Aim system for killer 1x1x1x1", function(value)
        _G.MassAimOn = value
    end)

    MainTab:Toggle("Predict Movement", _G.PredictMovement, "Predict target movement slightly ahead", function(value)
        _G.PredictMovement = value
    end)

    -- üß† SERVICES
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer

    local dangerousAnimations = {
        ["131430497821198"] = true,
        ["100592913030351"] = true,
        ["70447634862911"]  = true,
        ["83685305553364"] = true
    }

    local killerModels = {["1x1x1x1"] = true}
    local survivorModels = {
        ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
        ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true, ["Veeronica"] = true,
        ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true
    }

    local autoRotateDisabledByScript = false
    local currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false

    local function isKiller()
        local char = localPlayer.Character
        return char and killerModels[char.Name] or false
    end

    local function getMyHumanoid()
        local char = localPlayer.Character
        return char and char:FindFirstChildWhichIsA("Humanoid")
    end

    local function restoreAutoRotate()
        local hum = getMyHumanoid()
        if hum and autoRotateDisabledByScript then
            hum.AutoRotate = true
            autoRotateDisabledByScript = false
        end
    end

    local function isPlayingDangerousAnimation()
        local humanoid = getMyHumanoid()
        if not humanoid then return false end
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then return false end

        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            local animId = tostring(track.Animation.AnimationId):match("%d+")
            if animId and dangerousAnimations[animId] then
                return true
            end
        end
        return false
    end

    local function getClosestSurvivor()
        local myHumanoid = getMyHumanoid()
        if not myHumanoid then return nil end
        local myRoot = myHumanoid.Parent and myHumanoid.Parent:FindFirstChild("HumanoidRootPart")
        if not myRoot then return nil end

        local closest, closestDist = nil, math.huge
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and survivorModels[obj.Name] then
                local hrp = obj:FindFirstChild("HumanoidRootPart")
                local hum = obj:FindFirstChildWhichIsA("Humanoid")
                if hrp and hum and hum.Health > 0 then
                    local dist = (hrp.Position - myRoot.Position).Magnitude
                    if dist < closestDist then
                        closest = obj
                        closestDist = dist
                    end
                end
            end
        end
        return closest
    end

    localPlayer.CharacterAdded:Connect(function()
        task.delay(0.1, function()
            autoRotateDisabledByScript = false
        end)
    end)

    -- üîÅ MAIN LOOP
    RunService.RenderStepped:Connect(function()
        if not _G.MassAimOn then
            restoreAutoRotate()
            currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
            return
        end

        if not isKiller() then
            restoreAutoRotate()
            currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
            return
        end

        local myHumanoid = getMyHumanoid()
        if not myHumanoid then return end
        local myRoot = myHumanoid.Parent and myHumanoid.Parent:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end

        local isPlaying = isPlayingDangerousAnimation()

        if isPlaying and not isLockedOn then
            currentTarget = getClosestSurvivor()
            if currentTarget then isLockedOn = true end
        end

        if isLockedOn and currentTarget then
            local tHum = currentTarget:FindFirstChildWhichIsA("Humanoid")
            local tHrp = currentTarget:FindFirstChild("HumanoidRootPart")
            if (not tHum) or (tHum and tHum.Health <= 0) or (not tHrp) then
                currentTarget, isLockedOn = nil, false
            end
        end

        if (not isPlaying) and wasPlayingAnimation then
            currentTarget, isLockedOn = nil, false
            restoreAutoRotate()
        end
        wasPlayingAnimation = isPlaying

        if isPlaying and isLockedOn and currentTarget and currentTarget:FindFirstChild("HumanoidRootPart") then
            local hrp = currentTarget.HumanoidRootPart
            local targetPos = hrp.Position

            if not autoRotateDisabledByScript then
                myHumanoid.AutoRotate = false
                autoRotateDisabledByScript = true
            end

            if _G.PredictMovement then
                local vel = hrp.Velocity
                if vel.Magnitude > 2 then
                    targetPos = targetPos + hrp.CFrame.LookVector * 3
                end
            end

            local lookAt = Vector3.new(targetPos.X, myRoot.Position.Y, targetPos.Z)

            if _G.AimMode == "One Player" then
                myRoot.CFrame = myRoot.CFrame:Lerp(CFrame.lookAt(myRoot.Position, lookAt), 0.99)
            elseif _G.AimMode == "Multi Players" then
                local newTarget = getClosestSurvivor()
                if newTarget then currentTarget = newTarget end
                myRoot.CFrame = myRoot.CFrame:Lerp(CFrame.lookAt(myRoot.Position, lookAt), 0.99)
            elseif _G.AimMode == "Teleport" then
                local targetLookVector = hrp.CFrame.LookVector
                local behindPos = hrp.Position - targetLookVector * 3
                myRoot.CFrame = CFrame.new(behindPos, targetPos)
            end
        end
    end)
end


---------------------------------------------------------------------------------
-- Player
---------------------------------------------------------------------------------

do
    -- ======= D·ªäCH V·ª§ =======
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer

    -- ======= WHITELIST =======
    local AllowedPlayers = {
        ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
        ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
        ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true,
        ["Dusekkar"] = true, ["Veeronica"] = true,
    }

    local AllowedKillers = {
        ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
        ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true,
    }

    -- ======= BI·∫æN TR·∫†NG TH√ÅI =======
    local AimlockPlayerEnabled = false
    local AimlockKillerEnabled = false
    local CurrentTarget = nil
    local lastHumanoidAutoRotate = nil

    -- ======= H√ÄM H·ªñ TR·ª¢ =======
    local function IsAllowed(model, list)
        return list[model.Name] == true
    end

    local function GetModelFromPlayer(plr, list)
        if not plr.Character then return nil end
        if IsAllowed(plr.Character, list) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
            return plr.Character
        end
        for _, model in ipairs(workspace:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
                if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                    if IsAllowed(model, list) then
                        return model
                    end
                end
            end
        end
        return nil
    end

    local function GetClosestTarget(list)
        local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return nil end
        local closest, dist = nil, math.huge

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local model = GetModelFromPlayer(plr, list)
                if model and model.PrimaryPart then
                    local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                        if distance < dist then
                            dist = distance
                            closest = model
                        end
                    end
                end
            end
        end
        return closest
    end

    local function ValidateTarget(target)
        if not target then return false end
        local humanoid = target:FindFirstChildWhichIsA("Humanoid")
        return humanoid and humanoid.Health > 0 and target.PrimaryPart ~= nil
    end

    -- reset khi respawn
    LocalPlayer.CharacterAdded:Connect(function(char)
        CurrentTarget = nil
        if lastHumanoidAutoRotate ~= nil then
            local hum = char:FindFirstChildWhichIsA("Humanoid")
            if hum then
                hum.AutoRotate = lastHumanoidAutoRotate
            end
            lastHumanoidAutoRotate = nil
        end
    end)

    -- ======= AIMBOT LOOP =======
    RunService.RenderStepped:Connect(function()
        local myChar = LocalPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local humanoid = myChar and myChar:FindFirstChildWhichIsA("Humanoid")

        if not myRoot then return end

        -- toggle AutoRotate
        if (AimlockPlayerEnabled or AimlockKillerEnabled) and humanoid then
            if lastHumanoidAutoRotate == nil then
                lastHumanoidAutoRotate = humanoid.AutoRotate
            end
            humanoid.AutoRotate = false
        elseif humanoid and lastHumanoidAutoRotate ~= nil then
            humanoid.AutoRotate = lastHumanoidAutoRotate
            lastHumanoidAutoRotate = nil
        end

        -- h∆∞·ªõng nh√¨n target
        local function faceTarget(target)
            if not target or not target.PrimaryPart then return end
            local pos = myRoot.Position
            local targetPos = target.PrimaryPart.Position
            local dir = Vector3.new(targetPos.X, pos.Y, targetPos.Z) - pos
            if dir.Magnitude == 0 then return end

            local lookVector = dir.Unit
            local up = Vector3.yAxis
            local rightVector = lookVector:Cross(up)
            if rightVector.Magnitude == 0 then
                rightVector = Vector3.new(1, 0, 0)
            else
                rightVector = rightVector.Unit
            end

            myRoot.CFrame = CFrame.fromMatrix(pos, rightVector, up)
        end

        if AimlockPlayerEnabled then
            if not ValidateTarget(CurrentTarget) then
                CurrentTarget = GetClosestTarget(AllowedPlayers)
            end
            if ValidateTarget(CurrentTarget) then
                faceTarget(CurrentTarget)
            end
        elseif AimlockKillerEnabled then
            if not ValidateTarget(CurrentTarget) then
                CurrentTarget = GetClosestTarget(AllowedKillers)
            end
            if ValidateTarget(CurrentTarget) then
                faceTarget(CurrentTarget)
            end
        else
            CurrentTarget = nil
        end
    end)

    -- ======= FLUENT TOGGLES (chu·∫©n d·∫°ng code1) =======

    PlayerTab:Toggle("Aimbot Survivor", AimlockPlayerEnabled, "T·ª± ƒë·ªông kh√≥a h∆∞·ªõng nh√¨n v√†o Player", function(value)
        AimlockPlayerEnabled = value
        if value then
            AimlockKillerEnabled = false
            CurrentTarget = nil
        end
    end)

    PlayerTab:Toggle("Aimbot Killer", AimlockKillerEnabled, "T·ª± ƒë·ªông kh√≥a h∆∞·ªõng nh√¨n v√†o Killer", function(value)
        AimlockKillerEnabled = value
        if value then
            AimlockPlayerEnabled = false
            CurrentTarget = nil
        end
    end)
end




PlayerTab:Seperator("Cheats");

do
local ActiveNoStun = false
local noStunLoop

PlayerTab:Toggle("No Stun", _G.NoStun or false, "Ch·∫∑n b·ªã stun khi b·ªã t·∫•n c√¥ng", function(value)
    _G.NoStun = value
    ActiveNoStun = value

    if value then
        -- N·∫øu c√≥ loop c≈© th√¨ d·ª´ng
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end

        -- T·∫°o loop m·ªõi li√™n t·ª•c ƒë·∫£m b·∫£o HumanoidRootPart kh√¥ng b·ªã anchored
        noStunLoop = task.spawn(function()
            while ActiveNoStun do
                local character = game.Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
                task.wait(0.1) -- nh·∫π, tr√°nh lag
            end
        end)
    else
        -- T·∫Øt loop khi toggle off
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end
    end
end)
end




do
    local InfStaminaEnabled = false  
    local staminaLoop  
    local StaminaModule  

    -- Th·ª≠ l·∫•y module an to√†n
    pcall(function()  
        local ReplicatedStorage = game:GetService("ReplicatedStorage")  
        local path = ReplicatedStorage:FindFirstChild("Systems")  
            and ReplicatedStorage.Systems:FindFirstChild("Character")  
            and ReplicatedStorage.Systems.Character:FindFirstChild("Game")  
            and ReplicatedStorage.Systems.Character.Game:FindFirstChild("Sprinting")  

        if path then  
            StaminaModule = require(path)  
        end  
    end)  

    -- H√†m h·ªìi stamina an to√†n
    local function restoreStamina()  
        if not StaminaModule then return end  

        local maxStamina = StaminaModule.MaxStamina or 100  
        if StaminaModule.Stamina then  
            if typeof(StaminaModule.SetStamina) == "function" then  
                StaminaModule:SetStamina(maxStamina)  
            elseif typeof(StaminaModule.UpdateStamina) == "function" then  
                StaminaModule:UpdateStamina(maxStamina)  
            else  
                StaminaModule.Stamina = maxStamina  
            end  
        end  
    end  

    -- Ch·ªâ t·∫°o toggle n·∫øu module t·ªìn t·∫°i
    if StaminaModule then  
        PlayerTab:Toggle("Infinite Stamina", InfStaminaEnabled, "V√¥ h·∫°n stamina", function(value)
            InfStaminaEnabled = value

            -- N·∫øu module c√≥ thu·ªôc t√≠nh StaminaLossDisabled th√¨ set lu√¥n
            if StaminaModule.StaminaLossDisabled ~= nil then
                StaminaModule.StaminaLossDisabled = value
            end

            if value then
                restoreStamina()
                if not staminaLoop then
                    staminaLoop = task.spawn(function()
                        while InfStaminaEnabled do
                            task.wait(0.01)
                            restoreStamina()
                        end
                        staminaLoop = nil
                    end)
                end
            end
        end)
    else
        warn("[InfStamina] Sprinting module not found, toggle disabled.")
    end
end





PlayerTab:Seperator("Animation");

do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local player = Players.LocalPlayer

    local sprintModule
    pcall(function()
        sprintModule = require(ReplicatedStorage:WaitForChild("Systems").Character.Game.Sprinting)
    end)

    local KillersData = {
        ["Shasher"] = {
            ["Default"] = {Idle="rbxassetid://116050994905421", Walk="rbxassetid://93622022596108", Run="rbxassetid://93054787145505"},
            ["Pursuer"] = {Idle="rbxassetid://94895464960972", Walk="rbxassetid://100206079439305", Run="rbxassetid://138660433982140"},
            ["subject_0"] = {Idle="rbxassetid://14301056458", Walk="rbxassetid://122325883800612", Run="rbxassetid://97248175252805"}
        },
        ["Coolkidd"] = {["Default"] = {Idle="rbxassetid://18885903667", Walk="rbxassetid://18885906143", Run="rbxassetid://96571077893813"}},
        ["John Doe"] = {
            ["Default"] = {Idle="rbxassetid://105880087711722", Walk="rbxassetid://81193817424328", Run="rbxassetid://132653655520682"},
            ["Shadow"] = {Idle="rbxassetid://00000000001", Walk="rbxassetid://00000000002", Run="rbxassetid://00000000003"}
        },
        ["Noli"] = {["Default"] = {Idle="rbxassetid://93841120533318", Walk="rbxassetid://109700476007435", Run="rbxassetid://117451341682452"}},
        ["1x1x1x1"] = {
            ["Default"] = {Idle="rbxassetid://138754221537146", Walk="rbxassetid://131235528875091", Run="rbxassetid://106485518413331"},
            ["Hacklord [Old]"] = {Idle="rbxassetid://82241652784826", Walk="rbxassetid://119242164490314", Run="rbxassetid://92430101129682"},
            ["Hacklord [New]"] = {Idle="rbxassetid://106131211773069", Walk="rbxassetid://119112338263474", Run="rbxassetid://85339002634979"}
        },
        ["Herobrine"] = {["Default"] = {Idle="rbxassetid://107799240559806", Walk="rbxassetid://89380107485006", Run="rbxassetid://134157363854022"}},
        ["Gubby"] = {["Default"] = {Idle="rbxassetid://88333702239259", Walk="rbxassetid://115244584291581", Run="rbxassetid://115244584291581"}},
        ["Sancho"] = {["Default"] = {Idle="rbxassetid://115073581864188", Walk="rbxassetid://95213748170889", Run="rbxassetid://75409814098993"}},
        ["Erlking"] = {["Default"] = {Idle="rbxassetid://93727662665079", Walk="rbxassetid://97625643261790", Run="rbxassetid://119357938208454"}},
        ["Sukuna"] = {["Default"] = {Idle="rbxassetid://115268929362938", Walk="rbxassetid://123678890237669", Run="rbxassetid://132086389849889", Music="rbxassetid://73595818073606"}}
    }

    local enabled = false
    local selectedKiller = "Shasher"
    local selectedSkin = "Default"
    local character, humanoid, animator
    local idleAnim, walkAnim, runAnim
    local idleTrack, walkTrack, runTrack
    local _isSprinting = false
    local musicSound
    local runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn
    local heartbeatAccumulator = 0
    local HEARTBEAT_CHECK_INTERVAL = 0.12

    -- ==============================
    local function stopAndClearTracks()
        for _, track in ipairs({idleTrack, walkTrack, runTrack}) do
            if track then pcall(function() track:Stop() end) end
        end
        idleTrack, walkTrack, runTrack = nil, nil, nil
    end

    local function stopMusic()
        if musicSound then
            pcall(function() musicSound:Stop() musicSound:Destroy() end)
            musicSound = nil
        end
    end

    local function playMusicIfSukuna(set)
        stopMusic()
        if selectedKiller=="Sukuna" and set and set.Music then
            local sound = Instance.new("Sound")
            sound.SoundId = set.Music
            sound.Looped = true
            sound.Volume = 2
            sound.Parent = workspace
            sound:Play()
            musicSound = sound
        end
    end

    local function loadAnimObjects(killer, skin)
        local killerTable = KillersData[killer]
        if not killerTable then return end
        local set = killerTable[skin or "Default"] or killerTable["Default"]
        if not set then return end

        idleAnim = Instance.new("Animation")
        walkAnim = Instance.new("Animation")
        runAnim = Instance.new("Animation")
        idleAnim.AnimationId, walkAnim.AnimationId, runAnim.AnimationId = set.Idle, set.Walk, set.Run
        playMusicIfSukuna(set)
    end

    local function playAnim(animObj, trackType)
        if not animator then return end
        if trackType~="Idle" and idleTrack then pcall(function() idleTrack:Stop() end) idleTrack=nil end
        if trackType~="Walk" and walkTrack then pcall(function() walkTrack:Stop() end) walkTrack=nil end
        if trackType~="Run" and runTrack then pcall(function() runTrack:Stop() end) runTrack=nil end

        local track
        if trackType=="Idle" and not idleTrack then idleTrack=animator:LoadAnimation(idleAnim) track=idleTrack
        elseif trackType=="Walk" and not walkTrack then walkTrack=animator:LoadAnimation(walkAnim) track=walkTrack
        elseif trackType=="Run" and not runTrack then runTrack=animator:LoadAnimation(runAnim) track=runTrack
        else track=(trackType=="Idle" and idleTrack) or (trackType=="Walk" and walkTrack) or runTrack end

        if track and not track.IsPlaying then pcall(function() track:Play() end) end
    end

    local function updateMovementState()
        if not enabled or not character then return end
        local moving=false
        if humanoid and humanoid.MoveDirection then
            moving = humanoid.MoveDirection.Magnitude>0
            if not moving then
                local root=character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
                if root and root.Velocity.Magnitude>1 then moving=true end
            end
        end
        if moving then
            local sprintingNow=(sprintModule and sprintModule.IsSprinting) or _isSprinting
            if sprintingNow then playAnim(runAnim,"Run") else playAnim(walkAnim,"Walk") end
        else
            playAnim(idleAnim,"Idle")
        end
    end

    local function setupMovementListeners()
        if inputBeganConn then inputBeganConn:Disconnect() end
        if inputEndedConn then inputEndedConn:Disconnect() end
        if runningConn then runningConn:Disconnect() end
        if heartbeatConn then heartbeatConn:Disconnect() end

        inputBeganConn=UserInputService.InputBegan:Connect(function(input,gp)
            if gp then return end
            if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=true end
        end)
        inputEndedConn=UserInputService.InputEnded:Connect(function(input,gp)
            if gp then return end
            if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=false end
        end)

        if humanoid and humanoid.Running then
            runningConn=humanoid.Running:Connect(function(speed)
                if not enabled then return end
                if speed>0 then updateMovementState() else playAnim(idleAnim,"Idle") end
            end)
        else
            heartbeatAccumulator=0
            heartbeatConn=RunService.Heartbeat:Connect(function(dt)
                if not enabled or not character then return end
                heartbeatAccumulator+=dt
                if heartbeatAccumulator>=HEARTBEAT_CHECK_INTERVAL then
                    heartbeatAccumulator=0
                    updateMovementState()
                end
            end)
        end
    end

    local function onCharacterBound(char)
        stopAndClearTracks()
        stopMusic()
        character=char
        humanoid=char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
        if humanoid then
            animator=humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator",humanoid)
        end
        if enabled then
            loadAnimObjects(selectedKiller, selectedSkin)
            setupMovementListeners()
            updateMovementState()
        end
    end

    player.CharacterAdded:Connect(onCharacterBound)
    if player.Character then onCharacterBound(player.Character) end

    -- =========================
    -- H·ª£p nh·∫•t Dropdown Killer + Skin
    -- =========================
    local options = {}
    for k, skins in pairs(KillersData) do
        for s,_ in pairs(skins) do
            table.insert(options, k.." | "..s)
        end
    end
    table.sort(options)

    PlayerTab:Dropdown("Choose Killer & Skin", options, selectedKiller.." | "..selectedSkin, function(value)
        local split = string.split(value," | ")
        selectedKiller = split[1] or "Shasher"
        selectedSkin = split[2] or "Default"
        if enabled and player.Character then
            loadAnimObjects(selectedKiller, selectedSkin)
            stopAndClearTracks()
            updateMovementState()
        else
            stopMusic()
        end
    end)

    PlayerTab:Toggle("Fake Killers", false, "M·ªü kh√≥a animation c·ªßa c√°c killers", function(value)
        enabled = value
        if enabled and player.Character then
            loadAnimObjects(selectedKiller, selectedSkin)
            onCharacterBound(player.Character)
        else
            stopAndClearTracks()
            stopMusic()
        end
    end)
end




PlayerTab:Seperator("Hitbox");

do
repeat task.wait() until game:IsLoaded()

-- üîß Bi·∫øn c·∫•u h√¨nh to√†n c·ª•c
_G.ForsakenReachEnabled = _G.ForsakenReachEnabled or false
_G.NearestDist = _G.NearestDist or 120

-- üß≠ H√†m Fluent Toggle / Slider t·ª± ch·∫ø
PlayerTab:Toggle("Hitbox Devil", _G.ForsakenReachEnabled, "TƒÉng kho·∫£ng c√°ch hitbox", function(state)
    _G.ForsakenReachEnabled = state
    -- n·∫øu v·ª´a b·∫≠t m√† ƒëang trong combat ‚Üí k√≠ch ho·∫°t ngay
    if state then
        task.spawn(function()
            task.wait(0.1)
            pcall(ForsakenReachLogic)
        end)
    end
end)

PlayerTab:Slider("Distance", 10, 1000, _G.NearestDist, 1, "Kho·∫£ng c√°ch nh·∫≠n di·ªán m·ª•c ti√™u", function(value)
    _G.NearestDist = value
end)

-- ‚ö° Services setup
local Players = game:GetService('Players')
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

Player.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

local RNG = Random.new()

-- ‚öîÔ∏è AttackAnimations (gi·ªØ nguy√™n)
local AttackAnimations = { -- r√∫t g·ªçn v√≠ d·ª•
    'rbxassetid://131430497821198',
    'rbxassetid://83829782357897',
    'rbxassetid://126830014841198',
    'rbxassetid://126355327951215',
    'rbxassetid://121086746534252',
    'rbxassetid://105458270463374',
    'rbxassetid://127172483138092',
    'rbxassetid://18885919947',
    'rbxassetid://18885909645',
    'rbxassetid://87259391926321',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://86545133269813',
    'rbxassetid://89448354637442',
    'rbxassetid://90499469533503',
    'rbxassetid://116618003477002',
    'rbxassetid://106086955212611',
    'rbxassetid://107640065977686',
    'rbxassetid://77124578197357',
    'rbxassetid://101771617803133',
    'rbxassetid://134958187822107',
    'rbxassetid://111313169447787',
    'rbxassetid://71685573690338',
    'rbxassetid://71685573690338',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://136007065400978',
    'rbxassetid://136007065400978',
    'rbxassetid://86096387000557',
    'rbxassetid://86096387000557',
    'rbxassetid://108807732150251',
    'rbxassetid://138040001965654',
    'rbxassetid://73502073176819',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://97623143664485',
    'rbxassetid://97623143664485',
    'rbxassetid://86709774283672',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://140703210927645',
    'rbxassetid://96173857867228',
    'rbxassetid://121255898612475',
    'rbxassetid://98031287364865',
    'rbxassetid://119462383658044',
    'rbxassetid://77448521277146',
    'rbxassetid://77448521277146',
    'rbxassetid://103741352379819',
    'rbxassetid://119462383658044',
    'rbxassetid://131696603025265',
    'rbxassetid://122503338277352',
    'rbxassetid://97648548303678',
    'rbxassetid://94162446513587',
    'rbxassetid://84426150435898',
    'rbxassetid://93069721274110',
    'rbxassetid://114620047310688',
    'rbxassetid://97433060861952',
    'rbxassetid://82183356141401',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://70447634862911',
    'rbxassetid://92173139187970',
    'rbxassetid://106847695270773',
    'rbxassetid://125403313786645',
    'rbxassetid://81639435858902',
    'rbxassetid://137314737492715',
    'rbxassetid://120112897026015',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://126681776859538',
    'rbxassetid://129976080405072',
    'rbxassetid://109667959938617',
    'rbxassetid://74707328554358',
    'rbxassetid://133336594357903',
    'rbxassetid://86204001129974',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://124243639579224',
    'rbxassetid://70371667919898',
    'rbxassetid://131543461321709',
    'rbxassetid://136323728355613',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://106538427162796',
    'rbxassetid://109667959938617',
    'rbxassetid://126681776859538',
    'rbxassetid://129976080405072',
    'rbxassetid://110400453990786',
    'rbxassetid://83685305553364',
    'rbxassetid://126171487400618'
}

-- üßç‚Äç‚ôÇÔ∏è Danh s√°ch Killers / Survivors (gi·ªØ nguy√™n)
local Killers = { ["Slasher"] = true, ["1x1x1x1"] = true, ["Noli"] = true }
local Survivors = { ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true }

-- üåÄ H√†m ch√≠nh (ƒë·∫∑t tr∆∞·ªõc v√≤ng loop ƒë·ªÉ callback ·ªü tr√™n d√πng ƒë∆∞·ª£c)
function ForsakenReachLogic()
    if not _G.ForsakenReachEnabled or not HumanoidRootPart then
        return
    end

    local Playing = false
    for _, v in Humanoid:GetPlayingAnimationTracks() do
        if table.find(AttackAnimations, v.Animation.AnimationId)
        and (v.TimePosition / v.Length < 0.75) then
            Playing = true
            break
        end
    end
    if not Playing then return end

    local Target = nil
    local nearest = _G.NearestDist

    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj ~= Character then
            local hrp = obj:FindFirstChild("HumanoidRootPart")
            local hum = obj:FindFirstChild("Humanoid")
            if hrp and hum and hum.Health > 0 then
                local dist = (hrp.Position - HumanoidRootPart.Position).Magnitude
                if dist < nearest then
                    nearest = dist
                    Target = obj
                end
            end
        end
    end

    if Target then
        local OldVel = HumanoidRootPart.Velocity
        local NeededVel = (Target.HumanoidRootPart.Position - HumanoidRootPart.Position) / (Player:GetNetworkPing() * 2)
        HumanoidRootPart.Velocity = NeededVel
        game:GetService("RunService").RenderStepped:Wait()
        HumanoidRootPart.Velocity = OldVel
    end
end

-- üîÅ V√≤ng l·∫∑p ch√≠nh
task.spawn(function()
    while task.wait() do
        pcall(ForsakenReachLogic)
    end
end)
end

PlayerTab:Seperator("Walk Speed");


do
    -- === Teleport Speed Setup ===
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")
    local HRP = Character:WaitForChild("HumanoidRootPart")

    -- ‚öôÔ∏è C·∫•u h√¨nh
    local defaultSpeed = 40
    local maxSpeed = 300

    _G.TeleportSpeedEnabled = _G.TeleportSpeedEnabled or false
    _G.TeleportSpeedValue = _G.TeleportSpeedValue or defaultSpeed

    -- üîÅ C·∫≠p nh·∫≠t l·∫°i khi respawn
    LocalPlayer.CharacterAdded:Connect(function(char)
        Character = char
        Humanoid = Character:WaitForChild("Humanoid")
        HRP = Character:WaitForChild("HumanoidRootPart")
    end)

    -- üåÄ Loop teleport (ƒë·ªçc gi√° tr·ªã global m·ªói frame)
    RunService.Heartbeat:Connect(function(dt)
        if _G.TeleportSpeedEnabled and Humanoid and HRP then
            if Humanoid.MoveDirection.Magnitude > 0 then
                local moveDir = Humanoid.MoveDirection.Unit
                HRP.CFrame = HRP.CFrame + (moveDir * (_G.TeleportSpeedValue * dt))
            end
        end
    end)

    -- === GUI Fluent Custom ===

    -- üîò Toggle b·∫≠t/t·∫Øt teleport
    PlayerTab:Toggle("Teleport Speed", _G.TeleportSpeedEnabled, "ƒêi Si√™u Nhanh C√≥ Th·ªÉ Bay Ra Ngo√†i Map", function(state)
        _G.TeleportSpeedEnabled = state
    end)

    -- üéöÔ∏è Slider ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô (chu·∫©n Fluent)
    PlayerTab:Slider("Teleport Speed Value", 1, maxSpeed, _G.TeleportSpeedValue, function(v)
        _G.TeleportSpeedValue = v
    end)
end


---------------------------------------------------------------------------------
-- Visual
---------------------------------------------------------------------------------

do
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera

    local allowedModelsClone = {
        ["1x1x1x1Zombie"] = true,
        ["PizzaDeliveryRig"] = true,
        ["Mafia1"] = true,
        ["Mafia2"] = true,
        ["Mafia3"] = true,
        ["Mafia4"] = true,
    }

    local drawingsClone = {}
    local espConnectionClone, addedConnClone, removedConnClone

    local function createOrRepairESP(model, drawings, color)
        if not model then return end
        local data = drawings[model]

        if not data then
            local hrp = model:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color

            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model

            drawings[model] = { text = text, highlight = highlight }
            return
        end

        if not data.text then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color
            data.text = text
        end

        if not data.highlight or not data.highlight.Parent then
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model
            data.highlight = highlight
        else
            data.highlight.Adornee = model
            data.highlight.Enabled = true
            data.highlight.FillColor = color
            data.highlight.OutlineColor = color
        end
    end

    local function removeESP(model, drawings)
        local data = drawings[model]
        if data then
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        drawings[model] = nil
    end

    local function scanWorkspaceForAllowed(allowedList, drawings, color)
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
                createOrRepairESP(obj, drawings, color)
            end
        end
    end

    local function startESPClone()
        if espConnectionClone then return end

        local COLOR = Color3.fromRGB(0, 255, 0)
        scanWorkspaceForAllowed(allowedModelsClone, drawingsClone, COLOR)

        espConnectionClone = RunService.RenderStepped:Connect(function()
            for model, data in pairs(drawingsClone) do
                createOrRepairESP(model, drawingsClone, COLOR)
                data = drawingsClone[model]

                if model.Parent and model:FindFirstChild("HumanoidRootPart") then
                    local hrp = model.HumanoidRootPart
                    local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                    local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                    if data.text then
                        data.text.Text = string.format("%s [%.0fm]", model.Name, dist)
                        data.text.Position = Vector2.new(pos.X, pos.Y)
                        data.text.Visible = onScreen
                    end

                    if data.highlight then
                        data.highlight.Enabled = true
                    end
                else
                    if data.text then data.text.Visible = false end
                    if data.highlight then data.highlight.Enabled = false end
                end
            end
        end)

        addedConnClone = workspace.DescendantAdded:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and allowedModelsClone[model.Name] then
                createOrRepairESP(model, drawingsClone, COLOR)
            end
        end)

        removedConnClone = workspace.DescendantRemoving:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and drawingsClone[model] then
                removeESP(model, drawingsClone)
            end
        end)
    end

    local function stopESPClone()
        if espConnectionClone then espConnectionClone:Disconnect() end
        if addedConnClone then addedConnClone:Disconnect() end
        if removedConnClone then removedConnClone:Disconnect() end
        for _, data in pairs(drawingsClone) do
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        table.clear(drawingsClone)
        espConnectionClone, addedConnClone, removedConnClone = nil, nil, nil
    end

    _G.ESPCloneEnabled = _G.ESPCloneEnabled or false

    VisualTab:Toggle("ESP Clone", _G.ESPCloneEnabled, "Hi·ªán v·ªã tr√≠ c·ªßa nh√¢n b·∫£n", function(state)
        _G.ESPCloneEnabled = state
        if state then
            startESPClone()
        else
            stopESPClone()
        end
    end)
end






do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera

    local LocalPlayer = Players.LocalPlayer
    local drawingsESP = {}
    local espConnection, addedConn, removingConn

    -- üé® M√†u xanh l∆°
    local ESP_COLOR = Color3.fromRGB(0, 255, 255)

    -- üìå T·∫°o ho·∫∑c s·ª≠a ESP cho Player
    local function createOrRepairESP(player)
        if not player.Character then return end
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local data = drawingsESP[player]
        if not data then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = ESP_COLOR

            local highlight = Instance.new("Highlight")
            highlight.Adornee = player.Character
            highlight.FillColor = ESP_COLOR
            highlight.OutlineColor = ESP_COLOR
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = player.Character

            drawingsESP[player] = { text = text, highlight = highlight }
            return
        end

        if not data.text then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = ESP_COLOR
            data.text = text
        end

        if (not data.highlight) or (not data.highlight.Parent) then
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
            local highlight = Instance.new("Highlight")
            highlight.Adornee = player.Character
            highlight.FillColor = ESP_COLOR
            highlight.OutlineColor = ESP_COLOR
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = player.Character
            data.highlight = highlight
        else
            data.highlight.Adornee = player.Character
            data.highlight.Enabled = true
            data.highlight.FillColor = ESP_COLOR
            data.highlight.OutlineColor = ESP_COLOR
        end
    end

    -- üìå Xo√° ESP
    local function removeESP(player)
        local data = drawingsESP[player]
        if data then
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        drawingsESP[player] = nil
    end

    -- üìå Qu√©t to√†n b·ªô Player hi·ªán t·∫°i
    local function scanAllPlayers()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                createOrRepairESP(player)
            end
        end
    end

    -- üî• B·∫≠t ESP
    local function startESP()
        if espConnection then return end

        scanAllPlayers()

        espConnection = RunService.RenderStepped:Connect(function()
            for player, data in pairs(drawingsESP) do
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = player.Character.HumanoidRootPart
                    createOrRepairESP(player)
                    data = drawingsESP[player]

                    local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                    local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                    if data.text then
                        data.text.Text = string.format("%s [%.0fm]", player.Name, dist)
                        data.text.Position = Vector2.new(pos.X, pos.Y)
                        data.text.Visible = onScreen
                    end

                    if data.highlight then
                        data.highlight.Enabled = true
                    end
                else
                    if data.text then data.text.Visible = false end
                    if data.highlight then data.highlight.Enabled = false end
                end
            end
        end)

        addedConn = Players.PlayerAdded:Connect(function(player)
            if player ~= LocalPlayer then
                player.CharacterAdded:Connect(function()
                    task.wait(1)
                    createOrRepairESP(player)
                end)
            end
        end)

        removingConn = Players.PlayerRemoving:Connect(function(player)
            removeESP(player)
        end)
    end

    -- üõë T·∫Øt ESP
    local function stopESP()
        if espConnection then espConnection:Disconnect() end
        if addedConn then addedConn:Disconnect() end
        if removingConn then removingConn:Disconnect() end

        for _, data in pairs(drawingsESP) do
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        table.clear(drawingsESP)
        espConnection, addedConn, removingConn = nil, nil, nil
    end

    -- üß© Toggle ki·ªÉu Fluent
    _G.ESPPlayer = _G.ESPPlayer or false

    VisualTab:Toggle("ESP Player", _G.ESPPlayer, "Hi·ªán v·ªã tr√≠ c·ªßa ng∆∞·ªùi ch∆°i", function(value)
        _G.ESPPlayer = value
        if value then
            startESP()
        else
            stopESP()
        end
    end)
end





-- ‚úÖ ESP Model (Survivors & Killers) - Chu·∫©n Relz Hub
do
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    local Players = game:GetService("Players")

    -- Danh s√°ch model
    local allowedModelsWhite = {
        ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
        ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true, ["Veeronica"] = true,
        ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true,
    }

    local allowedModelsRed = {
        ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
        ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true
    }

    -- Containers
    local drawingsWhite, drawingsRed = {}, {}
    local conWhiteLoop, conWhiteAdded, conWhiteRemoved
    local conRedLoop, conRedAdded, conRedRemoved

    -- Check model c√≥ ph·∫£i player ƒëi·ªÅu khi·ªÉn kh√¥ng
    local function isControlledByPlayer(model)
        if model:FindFirstChildOfClass("Humanoid") then
            local plr = Players:GetPlayerFromCharacter(model)
            return plr ~= nil
        end
        return false
    end

    -- Utility t·∫°o/repair ESP
    local function createOrRepairESP(model, drawings, color)
        if not model then return end

        local data = drawings[model]
        if not data then
            local hrp = model:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color

            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model

            drawings[model] = { text = text, highlight = highlight }
            return
        end

        -- Repair n·∫øu m·∫•t
        if not data.text then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color
            data.text = text
        end
        if not (data.highlight and data.highlight.Parent) then
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model
            data.highlight = highlight
        end
    end

    local function removeESP(model, drawings)
        local data = drawings[model]
        if data then
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        drawings[model] = nil
    end

    -- Loop ESP update
    local function updateESP(drawings, color)
        for model, data in pairs(drawings) do
            if model.Parent and model:FindFirstChild("HumanoidRootPart") then
                createOrRepairESP(model, drawings, color)
                data = drawings[model]

                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    local displayName = model.Name
                    if model.Name == "Noli" and not isControlledByPlayer(model) then
                        displayName = "Noli Fake"
                    end

                    data.text.Text = string.format("%s [%.0fm]", displayName, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end

                if data.highlight then
                    data.highlight.Adornee = model
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end

    -- === White ESP ===
    local function startESPWhite()
        if conWhiteLoop then return end
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and allowedModelsWhite[obj.Name] then
                createOrRepairESP(obj, drawingsWhite, Color3.fromRGB(255, 255, 255))
            end
        end

        conWhiteLoop = RunService.Heartbeat:Connect(function()
            updateESP(drawingsWhite, Color3.fromRGB(255, 255, 255))
        end)

        conWhiteAdded = workspace.DescendantAdded:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and allowedModelsWhite[model.Name] then
                createOrRepairESP(model, drawingsWhite, Color3.fromRGB(255, 255, 255))
            end
        end)
        conWhiteRemoved = workspace.DescendantRemoving:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and drawingsWhite[model] then
                removeESP(model, drawingsWhite)
            end
        end)
    end

    local function stopESPWhite()
        if conWhiteLoop then conWhiteLoop:Disconnect(); conWhiteLoop = nil end
        if conWhiteAdded then conWhiteAdded:Disconnect(); conWhiteAdded = nil end
        if conWhiteRemoved then conWhiteRemoved:Disconnect(); conWhiteRemoved = nil end
        for _, d in pairs(drawingsWhite) do
            pcall(function() if d.text then d.text:Remove() end end)
            pcall(function() if d.highlight then d.highlight:Destroy() end end)
        end
        drawingsWhite = {}
    end

    -- === Red ESP ===
    local function startESPRed()
        if conRedLoop then return end
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and allowedModelsRed[obj.Name] then
                createOrRepairESP(obj, drawingsRed, Color3.fromRGB(255, 0, 0))
            end
        end

        conRedLoop = RunService.Heartbeat:Connect(function()
            updateESP(drawingsRed, Color3.fromRGB(255, 0, 0))
        end)

        conRedAdded = workspace.DescendantAdded:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and allowedModelsRed[model.Name] then
                createOrRepairESP(model, drawingsRed, Color3.fromRGB(255, 0, 0))
            end
        end)
        conRedRemoved = workspace.DescendantRemoving:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and drawingsRed[model] then
                removeESP(model, drawingsRed)
            end
        end)
    end

    local function stopESPRed()
        if conRedLoop then conRedLoop:Disconnect(); conRedLoop = nil end
        if conRedAdded then conRedAdded:Disconnect(); conRedAdded = nil end
        if conRedRemoved then conRedRemoved:Disconnect(); conRedRemoved = nil end
        for _, d in pairs(drawingsRed) do
            pcall(function() if d.text then d.text:Remove() end end)
            pcall(function() if d.highlight then d.highlight:Destroy() end end)
        end
        drawingsRed = {}
    end

    -- üü© Chu·∫©n Relz Hub Toggle (ESP Survivors)
    VisualTab:Toggle("ESP Survivors", false, "Hi·ªán v·ªã tr√≠ c·ªßa ng∆∞·ªùi s·ªëng s√≥t", function(v)
        if v then
            startESPWhite()
        else
            stopESPWhite()
        end
    end)

    -- üü• Chu·∫©n Relz Hub Toggle (ESP Killers)
    VisualTab:Toggle("ESP Killers", false, "Hi·ªán v·ªã tr√≠ c·ªßa k·∫ª gi·∫øt ng∆∞·ªùi", function(v)
        if v then
            startESPRed()
        else
            stopESPRed()
        end
    end)
end






do
    -- === ESP Generator (Highlight) ===
    local highlights, progressConns = {}, {}
    local espLoop
    local espEnabled = false
    local genAddedConn, genRemovedConn

    -- L·∫•y generators trong map
    local function getGenerators()
        local list = {}
        local mapRoot = workspace:FindFirstChild("Map")
        local ingame = mapRoot and mapRoot:FindFirstChild("Ingame")
        local mapFolder = ingame and ingame:FindFirstChild("Map")

        for _, obj in ipairs((mapFolder or ingame or mapRoot or workspace):GetDescendants()) do
            if obj:IsA("Model") and obj.Name == "Generator" then
                if not obj.PrimaryPart then
                    local part = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
                    if part then
                        pcall(function() obj.PrimaryPart = part end)
                    end
                end
                table.insert(list, obj)
            end
        end
        return list
    end

    local function isCompleted(gen)
        local p = gen:FindFirstChild("Progress")
        return p and tonumber(p.Value) and p.Value >= 100
    end

    local function ensureHighlight(gen)
        if highlights[gen] then
            highlights[gen].Enabled = true
            return
        end
        local h = Instance.new("Highlight")
        h.Adornee = gen
        h.FillColor = Color3.fromRGB(255, 255, 255)
        h.OutlineColor = Color3.fromRGB(255, 255, 255)
        h.FillTransparency = 0.5
        h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        h.Parent = gen
        highlights[gen] = h
    end

    local function cleanupModel(gen)
        if progressConns[gen] then
            progressConns[gen]:Disconnect()
            progressConns[gen] = nil
        end
        if highlights[gen] then
            highlights[gen]:Destroy()
            highlights[gen] = nil
        end
    end

    local function watchProgress(gen)
        if progressConns[gen] then return end
        local p = gen:FindFirstChild("Progress")
        if not p then return end
        progressConns[gen] = p.Changed:Connect(function()
            if not espEnabled then return end
            if isCompleted(gen) then
                if highlights[gen] then highlights[gen].Enabled = false end
            else
                ensureHighlight(gen)
            end
        end)
    end

    local function startESPGen()
        if espEnabled then return end
        espEnabled = true

        -- Loop c·∫≠p nh·∫≠t m·ªói 0.5s
        espLoop = task.spawn(function()
            while espEnabled do
                for _, gen in ipairs(getGenerators()) do
                    if isCompleted(gen) then
                        if highlights[gen] then highlights[gen].Enabled = false end
                    else
                        ensureHighlight(gen)
                    end
                    watchProgress(gen)
                end
                -- cleanup generator b·ªã xo√°
                for gen, _ in pairs(highlights) do
                    if not gen:IsDescendantOf(workspace) then
                        cleanupModel(gen)
                    end
                end
                task.wait(0.5)
            end
        end)

        -- K·∫øt n·ªëi spawn/remove
        genAddedConn = workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("Model") and obj.Name == "Generator" then
                task.defer(function()
                    if isCompleted(obj) then
                        if highlights[obj] then highlights[obj].Enabled = false end
                    else
                        ensureHighlight(obj)
                    end
                    watchProgress(obj)
                end)
            end
        end)

        genRemovedConn = workspace.DescendantRemoving:Connect(function(obj)
            if highlights[obj] or progressConns[obj] then
                cleanupModel(obj)
            end
        end)
    end

    local function stopESPGen()
        espEnabled = false
        if espLoop then espLoop = nil end
        if genAddedConn then genAddedConn:Disconnect(); genAddedConn = nil end
        if genRemovedConn then genRemovedConn:Disconnect(); genRemovedConn = nil end
        for gen, _ in pairs(progressConns) do
            cleanupModel(gen)
        end
    end

    -- ‚úÖ Toggle Fluent chu·∫©n
    _G.ESPGeneratorEnabled = _G.ESPGeneratorEnabled or false

    VisualTab:Toggle("ESP Generator", _G.ESPGeneratorEnabled, "Hi·ªán v·ªã tr√≠ c√°c m√°y ph√°t ƒëi·ªán", function(state)
        _G.ESPGeneratorEnabled = state
        if state then
            startESPGen()
        else
            stopESPGen()
        end
    end)
end




do
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera

    local itemsDraw = {}
    local conItemsAdded, conItemsRemoved, conItemsLoop

    local function getToolPart(tool)
        return tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
    end

    local function createItemESP(tool)
        if itemsDraw[tool] then return end
        local part = getToolPart(tool)
        if not part then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = Color3.fromRGB(255, 215, 0)

        local hl = Instance.new("Highlight")
        hl.Name = "ItemESP_Highlight"
        hl.Adornee = part
        hl.FillColor = Color3.fromRGB(255, 215, 0)
        hl.OutlineColor = Color3.fromRGB(255, 215, 0)
        hl.FillTransparency = 0.7
        hl.OutlineTransparency = 0
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        hl.Enabled = true
        hl.Parent = tool

        itemsDraw[tool] = {text = text, highlight = hl, part = part}
    end

    local function removeItemESP(tool)
        local data = itemsDraw[tool]
        if not data then return end
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        itemsDraw[tool] = nil
    end

    local function isInIngameFolder(inst)
        local map = workspace:FindFirstChild("Map")
        local ingame = map and map:FindFirstChild("Ingame")
        return ingame and inst:IsDescendantOf(ingame)
    end

    local function scanInitialItems()
        local map = workspace:FindFirstChild("Map")
        local ingame = map and map:FindFirstChild("Ingame")
        if not ingame then return end
        for _, obj in ipairs(ingame:GetDescendants()) do
            if obj:IsA("Tool") then
                createItemESP(obj)
            end
        end
    end

    local function startESPItems()
        if conItemsLoop then return end

        scanInitialItems()

        -- Theo d√µi tool m·ªõi th√™m
        conItemsAdded = workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("Tool") and isInIngameFolder(obj) then
                createItemESP(obj)
            end
        end)

        conItemsRemoved = workspace.DescendantRemoving:Connect(function(obj)
            if itemsDraw[obj] then
                removeItemESP(obj)
            end
        end)

        -- C·∫≠p nh·∫≠t v·ªã tr√≠ text m·ªói frame
        conItemsLoop = RunService.RenderStepped:Connect(function()
            for tool, data in pairs(itemsDraw) do
                local part = data.part
                if not (tool.Parent and part and part.Parent) or not isInIngameFolder(tool) then
                    data.text.Visible = false
                else
                    local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 2, 0))
                    local dist = (part.Position - Camera.CFrame.Position).Magnitude
                    data.text.Text = string.format("%s [%.0fm]", tool.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                    if data.highlight then
                        data.highlight.Adornee = part
                        data.highlight.Enabled = true
                    end
                end
            end
        end)
    end

    local function stopESPItems()
        if conItemsAdded then conItemsAdded:Disconnect(); conItemsAdded = nil end
        if conItemsRemoved then conItemsRemoved:Disconnect(); conItemsRemoved = nil end
        if conItemsLoop then conItemsLoop:Disconnect(); conItemsLoop = nil end
        for tool, _ in pairs(itemsDraw) do
            removeItemESP(tool)
        end
        itemsDraw = {}
    end

    -- ‚úÖ Toggle Fluent chu·∫©n
    _G.ESPItemsEnabled = _G.ESPItemsEnabled or false

    VisualTab:Toggle("ESP Items", _G.ESPItemsEnabled, "Hi·ªán v·ªã tr√≠ c√°c v·∫≠t ph·∫©m", function(enabled)
        _G.ESPItemsEnabled = enabled
        if enabled then
            startESPItems()
        else
            stopESPItems()
        end
    end)
end

---------------------------------------------------------------------------------
-- Misc
---------------------------------------------------------------------------------

-- FullBright Toggle
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end
    game:GetService("Lighting").Ambient = Color3.fromRGB(200, 200, 200)
    game:GetService("Lighting").Brightness = 4
    game:GetService("Lighting").GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() fullBrightLoop=nil end
    local Lighting = game:GetService("Lighting")
    Lighting.Ambient = Color3.fromRGB(128,128,128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

MiscTab:Toggle("Full Bright", fullBrightEnabled, "Gi√∫p Tr·ªùi S√°ng h∆°n x200 l·∫ßn", function(value)
    fullBrightEnabled = value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

-- Remove Fog Toggle
local fogEnabled = false
local fogLoop

local function removeFog()
    local Lighting = game:GetService("Lighting")
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000
    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1,1,1)
    end
end

local function restoreFog()
    local Lighting = game:GetService("Lighting")
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000
    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200,200,200)
    end
end

MiscTab:Toggle("Remove Fog", fogEnabled, "Lo·∫°i b·ªè s∆∞∆°ng m√π quanh b·∫£n ƒë·ªì", function(value)
    fogEnabled = value
    if fogEnabled then
        removeFog()
        if fogLoop then fogLoop:Disconnect() end
        fogLoop = game:GetService("RunService").Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop=nil end
        restoreFog()
    end
end)


MiscTab:Seperator("Bypass");

do
local antiAFKCons = {}

-- Ch·ªâ t·∫°o toggle n·∫øu executor c√≥ getconnections
if getconnections then
    MiscTab:Toggle("Anti-AFK", true, "Ch·ªëng b·ªã kick khi AFK qu√° l√¢u", function(state)
        local idleCons = getconnections(game.Players.LocalPlayer.Idled)
        
        if state then
            -- L∆∞u & disable
            for _, c in ipairs(idleCons) do
                antiAFKCons[c] = true
                c:Disable()
            end
            print("[AntiAFK] ƒê√£ b·∫≠t, b·∫°n s·∫Ω kh√¥ng b·ªã kick AFK.")
        else
            -- Enable l·∫°i
            for c,_ in pairs(antiAFKCons) do
                if c and c.Enable then
                    pcall(function() c:Enable() end)
                end
            end
            antiAFKCons = {}
            print("[AntiAFK] ƒê√£ t·∫Øt, Roblox s·∫Ω x·ª≠ l√Ω AFK b√¨nh th∆∞·ªùng.")
        end
    end)
else
    warn("[AntiAFK] Executor kh√¥ng h·ªó tr·ª£ getconnections, toggle b·ªã v√¥ hi·ªáu.")
end
end




do
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local LocalizationService = game:GetService("LocalizationService")

    shared.AntiBanSafe = shared.AntiBanSafe or {running = false, hooks = {}}
    local data = shared.AntiBanSafe

    local oldNamecall, oldIndex
    local protectionThread

    local function safe(func, ...)
        local ok, res = pcall(func, ...)
        if ok then return res end
    end

    -- Ch·∫∑n flags report nh·∫π nh√†ng
    local function disableReportFlags()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "False")
                setfflag("AbuseReportScreenshotPercentage", "0")
                setfflag("AbuseReportVideo", "False")
                setfflag("AbuseReportVideoPercentage", "0")
            end)
        end
    end

    local function setFlagsOn()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "True")
                setfflag("AbuseReportScreenshotPercentage", "100")
            end)
        end
    end

    -- Hook requests ch·ªâ ch·∫∑n URL ch·ª©a "abuse"
    local function hookRequests()
        if data.hooks.requestHooked then return end
        local oldRequest = (syn and syn.request) or request or http_request
        if typeof(oldRequest) == "function" and typeof(hookfunction) == "function" then
            hookfunction(oldRequest, function(req)
                if req and req.Url and tostring(req.Url):lower():find("abuse") then
                    return {StatusCode = 200, Body = "Blocked"}
                end
                return oldRequest(req)
            end)
            data.hooks.requestHooked = true
        end
    end

    -- Bypass kick/ban v√† GetCountryRegionForPlayerAsync
    local function safeBypass()
        if getrawmetatable and hookmetamethod and newcclosure then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            oldNamecall = oldNamecall or mt.__namecall
            oldIndex = oldIndex or mt.__index

            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = {...}

                if (method == "Kick" or method == "Ban") and self == LocalPlayer then return nil end
                if (method == "FireServer" or method == "InvokeServer") and args[1] then
                    local msg = tostring(args[1]):lower()
                    if msg:find("kick") or msg:find("ban") then return nil end
                end
                if self == LocalizationService and method == "GetCountryRegionForPlayerAsync" then
                    local success, result = pcall(function()
                        return LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer)
                    end)
                    if success then return result else return "US" end
                end

                return oldNamecall(self, ...)
            end)

            mt.__index = newcclosure(function(t, k)
                local key = tostring(k):lower()
                if key == "kick" or key == "ban" then return function() return nil end end
                return oldIndex(t, k)
            end)

            setreadonly(mt, true)
        end
    end

    -- Restore hooks khi toggle off
    local function restoreHooks()
        if getrawmetatable then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            if oldNamecall then mt.__namecall = oldNamecall end
            if oldIndex then mt.__index = oldIndex end
            setreadonly(mt, true)
            oldNamecall, oldIndex = nil, nil
        end
    end

    -- B·∫≠t Anti-Ban Safe
    local function startAntiBanSafe()
        if data.running then return end
        data.running = true
        safe(hookRequests)
        safe(safeBypass)

        protectionThread = task.spawn(function()
            while data.running do
                safe(disableReportFlags)
                task.wait(0.25) -- thread ch·∫°y nh·∫π, kh√¥ng lag GUI
            end
        end)
        print("[Anti-Ban Safe] üõ°Ô∏è ENABLED!")
    end

    -- T·∫Øt Anti-Ban Safe
    local function stopAntiBanSafe()
        data.running = false
        if protectionThread then protectionThread = nil end
        restoreHooks()
        setFlagsOn()
        print("[Anti-Ban Safe] ‚ö†Ô∏è DISABLED!")
    end

    -- ‚úÖ Toggle Fluent GUI
    MiscTab:Toggle("Anti Ban V3", true, "Ch·ªëng b·ªã banned khi s·ª≠ d·ª•ng hack", function(state)
        if state then
            startAntiBanSafe()
        else
            stopAntiBanSafe()
        end
    end)
end


MiscTab:Seperator("Cammera");



local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

-- Flag b·∫≠t/t·∫Øt
local ActiveRemoveAll = true

-- Danh s√°ch t√™n hi·ªáu ·ª©ng th∆∞·ªùng g·∫∑p
local effectNames = {
    "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
    "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
    "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
    "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
}

-- Danh s√°ch class hi·ªáu ·ª©ng trong Lighting
local effectClasses = {
    "BlurEffect",
    "BloomEffect",
    "SunRaysEffect",
    "DepthOfFieldEffect",
    "ColorCorrectionEffect"
}

-- üåü H√†m xo√° t·∫•t c·∫£ (effects + popups)
local function removeAll()
    -- Xo√° hi·ªáu ·ª©ng trong Lighting
    for _, obj in pairs(Lighting:GetDescendants()) do
        if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
            obj:Destroy()
        end
    end

    -- Xo√° GUI overlay
    for _, obj in pairs(PlayerGui:GetDescendants()) do
        if table.find(effectNames, obj.Name) then
            obj:Destroy()
        elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
                if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
                    obj:Destroy()
                end
            end
        end
    end

    -- Xo√° popup 1x1x1x1
    local temp = PlayerGui:FindFirstChild("TemporaryUI")
    if temp then
        local popup = temp:FindFirstChild("1x1x1x1Popup")
        if popup then
            popup:Destroy()
            warn("[Remover] 1x1x1x1Popup removed")
        end
    end
end

-- ‚úÖ Toggle d·∫°ng n√∫t inline
MiscTab:Toggle("Remove Effects", ActiveRemoveAll, "X√≥a b·ªè m·ªôt s·ªë hi·ªáu ·ª©ng  b·∫•t l·ª£i", function(value)
    ActiveRemoveAll = value
    if ActiveRemoveAll then
        task.spawn(function()
            while ActiveRemoveAll do
                removeAll()
                task.wait(0.5)
            end
        end)
    end
end)





local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- ‚úÖ Toggle Infinite Zoom
MiscTab:Toggle("Infinite Zoom", false, "Gi√∫p b·∫°n ph√≥ng to cammera v√¥ h·∫°n", function(value)
    if value then
        LP.CameraMaxZoomDistance = math.huge
        LP.CameraMinZoomDistance = 0
        warn("[Camera] Infinite zoom enabled")
    else
        LP.CameraMaxZoomDistance = 128 -- gi√° tr·ªã m·∫∑c ƒë·ªãnh Roblox
        LP.CameraMinZoomDistance = 0.5 -- gi√° tr·ªã m·∫∑c ƒë·ªãnh Roblox
        warn("[Camera] Zoom reset to default")
    end
end)





MiscTab:Seperator("Show");


local RunService = game:GetService("RunService")
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- Update FPS
        fpsText.Text = "FPS: " .. tostring(fpsCounter)
        fpsText.Visible = showFPS

        -- Update Ping
        local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
        local ping = pingStat and math.floor(pingStat:GetValue()) or 0
        msText.Text = "Ping: " .. ping .. " ms"

        if ping <= 60 then
            msText.Color = Color3.fromRGB(0, 255, 0)
        elseif ping <= 120 then
            msText.Color = Color3.fromRGB(255, 165, 0)
        else
            msText.Color = Color3.fromRGB(255, 0, 0)
        end
        msText.Visible = showPing

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ‚úÖ Toggle: Show FPS
MiscTab:Toggle("Show FPS", showFPS, "Hi·ªán Fps hi·ªán t·∫°i c·ªßa b·∫°n", function(value)
    showFPS = value
    fpsText.Visible = value
end)

-- ‚úÖ Toggle: Show Ping
MiscTab:Toggle("Show Ping", showPing, "Hi·ªán Ping hi·ªán t·∫°i c·ªßa b·∫°n", function(value)
    showPing = value
    msText.Visible = value
end)







MiscTab:Seperator("Fix Lag");

-- L∆∞u d·ªØ li·ªáu g·ªëc
local originalLighting = {}
local originalParts = {}

-- Bi·∫øn qu·∫£n l√Ω tr·∫°ng th√°i
local FPSBoostEnabled = false
local autoThread
local connection

-- H√†m l∆∞u Lighting g·ªëc
local function saveLighting()
    originalLighting.QualityLevel = settings().Rendering.QualityLevel
    originalLighting.GlobalShadows = game.Lighting.GlobalShadows
    originalLighting.FogEnd = game.Lighting.FogEnd
    originalLighting.Brightness = game.Lighting.Brightness
    originalLighting.PostEffects = {}
    for _, v in ipairs(game.Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            originalLighting.PostEffects[v] = v.Enabled
        end
    end
end

-- H√†m kh√¥i ph·ª•c Lighting
local function restoreLighting()
    if not originalLighting.QualityLevel then return end
    settings().Rendering.QualityLevel = originalLighting.QualityLevel
    game.Lighting.GlobalShadows = originalLighting.GlobalShadows
    game.Lighting.FogEnd = originalLighting.FogEnd
    game.Lighting.Brightness = originalLighting.Brightness
    for effect, state in pairs(originalLighting.PostEffects) do
        if effect and effect.Parent == game.Lighting then
            effect.Enabled = state
        end
    end
end

-- H√†m gi·∫£m ƒë·ªì h·ªça tri·ªát ƒë·ªÉ
local function simplifyModel(obj)
    if not FPSBoostEnabled then return end  -- ƒë·∫£m b·∫£o ch·ªâ gi·∫£m khi b·∫≠t

    if obj:IsA("BasePart") then
        if not originalParts[obj] then
            originalParts[obj] = {
                Material = obj.Material,
                Color = obj.Color,
                Reflectance = obj.Reflectance,
                CastShadow = obj.CastShadow
            }
        end
        obj.Material = Enum.Material.SmoothPlastic
        obj.Color = Color3.fromRGB(163, 162, 165)
        obj.Reflectance = 0
        obj.CastShadow = false
    elseif obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
        obj:Destroy()
    elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") 
        or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end
end

-- H√†m kh√¥i ph·ª•c BasePart
local function restoreParts()
    for part, data in pairs(originalParts) do
        if part and part.Parent then
            part.Material = data.Material
            part.Color = data.Color
            part.Reflectance = data.Reflectance
            part.CastShadow = data.CastShadow
        end
    end
    originalParts = {} -- reset
end

-- ==============================
-- Inline Toggle ki·ªÉu MainTab
-- ==============================
MiscTab:Toggle("FPS Boost", false, "Gi·∫£m ƒë·ªì h·ªça tr√≤ ch∆°i", function(state)
    FPSBoostEnabled = state

    if state then
        print("üîÑ Auto Reduce ON")

        -- L∆∞u lighting g·ªëc
        saveLighting()

        -- Gi·∫£m ƒë·ªì h·ªça lighting khi b·∫≠t
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        game.Lighting.GlobalShadows = false
        game.Lighting.FogEnd = 9e9
        game.Lighting.Brightness = 1
        for _, v in ipairs(game.Lighting:GetChildren()) do
            if v:IsA("PostEffect") then
                v.Enabled = false
            end
        end

        -- üî• Gi·∫£m ngay 1 l·∫ßn ƒë·∫ßu ti√™n
        for _, obj in ipairs(workspace:GetDescendants()) do
            simplifyModel(obj)
        end

        -- N·∫øu c√≥ object spawn th√™m th√¨ c≈©ng x·ª≠ l√Ω
        connection = workspace.DescendantAdded:Connect(function(obj)
            simplifyModel(obj)
        end)

        -- Sau ƒë√≥ auto l·∫∑p m·ªói 10s
        autoThread = task.spawn(function()
            while FPSBoostEnabled do
                task.wait(10)
                for _, obj in ipairs(workspace:GetDescendants()) do
                    simplifyModel(obj)
                end
            end
        end)

    else
        print("‚èπ Auto Reduce OFF")
        FPSBoostEnabled = false

        if connection then
            connection:Disconnect()
            connection = nil
        end

        -- Kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc
        restoreLighting()
        restoreParts()
        print("‚úÖ ƒê√£ kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc")
    end
end)




-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- ======= DANH S√ÅCH BLOCK ANIMATION =======
local blockedAnimations = {
    ["127802146383565"] = true,
    ["82691533602949"] = true,
    ["123764169071995"] = true,
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local BlockAnimEnabled = false
local blockConnections = {}

-- ======= H√ÄM =======
local function hookHumanoid(humanoid)
    if not humanoid then return end
    local conn = humanoid.AnimationPlayed:Connect(function(track)
        local id = track.Animation.AnimationId:match("%d+")
        if BlockAnimEnabled and blockedAnimations[id] then
            track:Stop()
        end
    end)
    table.insert(blockConnections, conn)
end

local function setBlockAnimations(enabled)
    BlockAnimEnabled = enabled

    -- clear c≈©
    for _, conn in pairs(blockConnections) do
        conn:Disconnect()
    end
    table.clear(blockConnections)

    if enabled then
        -- nh√¢n v·∫≠t hi·ªán t·∫°i
        if LocalPlayer.Character then
            hookHumanoid(LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"))
        end
        -- respawn
        local connChar = LocalPlayer.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid")
            hookHumanoid(char:FindFirstChildWhichIsA("Humanoid"))
        end)
        table.insert(blockConnections, connChar)
    end
end

-- ======= TOGGLE INLINE KI·ªÇU AUTO FARM =======
MiscTab:Toggle("Block Animations", BlockAnimEnabled, "Lo·∫°i b·ªè ho·∫°t ·∫£nh s·ª≠a m√°y ph√°t ƒëi·ªán", function(value)
    setBlockAnimations(value)
end)






