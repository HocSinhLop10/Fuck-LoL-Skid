--[[  
 _   _    _   _   _____     _       ___     _   _   _   _   ____   
| | | |  | | | | |_   _|   / \     / _ \   | | | | | | | | | __ )  
| |_| |  | | | |   | |    / _ \   | | | |  | |_| | | | | | |  _ \  
|  _  |  | | | |   | |   / ___ \  | |_| |  |  _  | | |_| | | |_) | 
\_| |_/   \___/    \_/  /_/   \_\  \___/   \_| |_/  \___/  |____/
                        Hutao Hub
]]

---------------------------------------------------------------------------------
-- ‚öôÔ∏è Load GUI g·ªëc
---------------------------------------------------------------------------------

local Update = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/New-Gui/refs/heads/main/Hutao-Hub-V2.lua"))()
local Library = Update:Window(" ")

local AboutTab = Library:Tab("About", "rbxassetid://10723426722")
local FarmTab = Library:Tab("Farm", "rbxassetid://10723345749")
local MainTab = Library:Tab("Main", "rbxassetid://10723407389")
local PlayerTab = Library:Tab("Player", "rbxassetid://10747372167")
local VisualTab = Library:Tab("Visual", "rbxassetid://10723346959")
local MiscTab = Library:Tab("Misc", "rbxassetid://10723424838")
local SettingsTab = Library:Tab("Setting", "rbxassetid://10734950309")

---------------------------------------------------------------------------------
-- üß© Thay ch·ªØ + ·∫£nh
---------------------------------------------------------------------------------

local OLD_TEXTS = {"relz hub |", "RELZ HUB |", "Relz Hub |"}
local NEW_TEXT = "Hutao Hub [Free] | Forsaken | Version 5.0.0"
local OLD_IMG = "13940080072"
local NEW_IMG = "rbxassetid://90508203972003"

local function FixObject(obj)
	local lower, find, gsub = string.lower, string.find, string.gsub
	if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
		for _, v in ipairs(OLD_TEXTS) do
			if obj.Text and find(lower(obj.Text), lower(v)) then
				obj.Text = gsub(obj.Text, v, NEW_TEXT)
			end
		end
	elseif obj:IsA("StringValue") or obj:IsA("ValueBase") then
		if typeof(obj.Value) == "string" then
			for _, v in ipairs(OLD_TEXTS) do
				if find(lower(obj.Value), lower(v)) then
					obj.Value = gsub(obj.Value, v, NEW_TEXT)
				end
			end
		end
	elseif obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
		if obj.Image and find(obj.Image, OLD_IMG) then
			obj.Image = NEW_IMG
		end
	elseif obj:IsA("Decal") or obj:IsA("Texture") then
		if obj.Texture and find(obj.Texture, OLD_IMG) then
			obj.Texture = NEW_IMG
		end
	end
end

for _, obj in ipairs(game:GetDescendants()) do FixObject(obj) end
game.DescendantAdded:Connect(FixObject)

---------------------------------------------------------------------------------
-- üß† Ph√°t hi·ªán v√† ‚Äúc·ª©u‚Äù n√∫t toggle ·∫©n/hi·ªán GUI kh·ªèi b·ªã che
---------------------------------------------------------------------------------

local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

local function ProtectToggleButtons(container)
	for _, obj in ipairs(container:GetDescendants()) do
		if obj:IsA("TextButton") or obj:IsA("ImageButton") then
			local nameLower = string.lower(obj.Name)
			if nameLower:find("toggle") or nameLower:find("hide") or nameLower:find("open") or nameLower:find("show") then
				-- Di chuy·ªÉn n√∫t ra ngo√†i GUI b·ªã che
				obj.Parent = CoreGui
				obj.ZIndex = 99999
				obj.Active = true
				obj.Draggable = true
				obj.AutoButtonColor = true

				-- N·∫øu c√≥ frame n·ªÅn ƒëen, v√¥ hi·ªáu h√≥a
				local bg = obj:FindFirstAncestorWhichIsA("Frame")
				if bg and bg.BackgroundColor3 == Color3.new(0, 0, 0) and bg.BackgroundTransparency < 0.5 then
					bg.BackgroundTransparency = 1
				end
			end
		end
	end
end

-- Qu√©t c·∫£ CoreGui + PlayerGui
for _, gui in ipairs(CoreGui:GetChildren()) do ProtectToggleButtons(gui) end
for _, gui in ipairs(playerGui:GetChildren()) do ProtectToggleButtons(gui) end

-- T·ª± c·∫≠p nh·∫≠t khi GUI m·ªõi ƒë∆∞·ª£c th√™m v√†o
CoreGui.ChildAdded:Connect(ProtectToggleButtons)
playerGui.ChildAdded:Connect(ProtectToggleButtons)

---------------------------------------------------------------------------------
-- ‚ú® TƒÉng ƒë·ªô s√°ng ·∫£nh
---------------------------------------------------------------------------------

task.spawn(function()
	while true do
		for _, img in ipairs(CoreGui:GetDescendants()) do
			if img:IsA("ImageLabel") or img:IsA("ImageButton") then
				if img.Image == NEW_IMG then
					img.ImageColor3 = Color3.fromRGB(255, 255, 255)
					img.ImageTransparency = 0.05
					img.ZIndex = 9999
				end
			end
		end
		task.wait(2)
	end
end)

---------------------------------------------------------------------------------
-- üèÜ Anti Afk
---------------------------------------------------------------------------------
local antiAFKCons = {}

-- Ki·ªÉm tra getconnections c√≥ t·ªìn t·∫°i kh√¥ng
if getconnections then
    local idleCons = getconnections(game.Players.LocalPlayer.Idled)

    -- L∆∞u & disable c√°c connection ƒë·ªÉ kh√¥ng b·ªã kick AFK
    for _, c in ipairs(idleCons) do
        antiAFKCons[c] = true
        c:Disable()
    end

    print("[AntiAFK] ƒê√£ t·ª± ƒë·ªông b·∫≠t, b·∫°n s·∫Ω kh√¥ng b·ªã kick AFK.")
else
    warn("[AntiAFK] Executor kh√¥ng h·ªó tr·ª£ getconnections, script kh√¥ng th·ªÉ ch·∫°y.")
end
---------------------------------------------------------------------------------
-- ü™ô Anti Ban
---------------------------------------------------------------------------------
do
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local LocalizationService = game:GetService("LocalizationService")

    shared.AntiBanSafe = shared.AntiBanSafe or {running = false, hooks = {}}
    local data = shared.AntiBanSafe

    local oldNamecall, oldIndex
    local protectionThread

    local function safe(func, ...)
        local ok, res = pcall(func, ...)
        if ok then return res end
    end

    -- Disable screenshot/video flags khi b·∫≠t protection
    local function disableReportFlags()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "False")
                setfflag("AbuseReportScreenshotPercentage", "0")
                setfflag("AbuseReportEnabled", "False")
                setfflag("ReportAbuseMenu", "False")
                setfflag("EnableAbuseReportScreenshot", "False")
                setfflag("AbuseReportVideo", "False")
                setfflag("AbuseReportVideoPercentage", "0")
                setfflag("VideoCaptureEnabled", "False")
                setfflag("RecordVideo", "False")
            end)
        end
    end

    -- Restore flag v·ªÅ b√¨nh th∆∞·ªùng khi t·∫Øt protection
    local function setFlagsOn()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "True")
                setfflag("AbuseReportScreenshotPercentage", "100")
            end)
        end
    end

    -- Hook requests (block report)
    local function hookRequests()
        if data.hooks.requestHooked then return end
        local oldRequest = (syn and syn.request) or request or http_request
        if typeof(oldRequest) == "function" and typeof(hookfunction) == "function" then
            hookfunction(oldRequest, function(req)
                if req and req.Url and tostring(req.Url):lower():find("abuse") then
                    return {StatusCode = 200, Body = "Blocked"}
                end
                return oldRequest(req)
            end)
            data.hooks.requestHooked = true
        end
    end

    -- Hook FindFirstChild (block GUI video/screenshot)
    local function hookFindFirstChild()
        if data.hooks.findHooked then return end
        local oldFind = workspace.FindFirstChild
        if typeof(oldFind) == "function" and typeof(hookfunction) == "function" then
            hookfunction(oldFind, function(self, name, ...)
                if name and tostring(name):lower():find("screenshot") then return nil end
                if name and tostring(name):lower():find("video") then return nil end
                return oldFind(self, name, ...)
            end)
            data.hooks.findHooked = true
        end
    end

    -- Safe bypass (__namecall)
    local function safeBypass()
        if getrawmetatable and hookmetamethod and newcclosure then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            oldNamecall = oldNamecall or mt.__namecall
            oldIndex = oldIndex or mt.__index

            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = {...}

                if (method == "Kick" or method == "Ban") and self == LocalPlayer then return nil end
                if (method == "FireServer" or method == "InvokeServer") and args[1] then
                    local msg = tostring(args[1]):lower()
                    if msg:find("kick") or msg:find("ban") then return nil end
                end
                if self == LocalizationService and method == "GetCountryRegionForPlayerAsync" then
                    local success, result = pcall(function()
                        return LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer)
                    end)
                    if success then return result else return "US" end
                end

                return oldNamecall(self, ...)
            end)

            mt.__index = newcclosure(function(t, k)
                local key = tostring(k):lower()
                if key:find("kick") or key:find("ban") then return function() return nil end end
                return oldIndex(t, k)
            end)

            setreadonly(mt, true)
        end
    end

    -- Restore hooks
    local function restoreHooks()
        if getrawmetatable then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            if oldNamecall then mt.__namecall = oldNamecall end
            if oldIndex then mt.__index = oldIndex end
            setreadonly(mt, true)
            oldNamecall, oldIndex = nil, nil
        end
    end

    -- Start protection
    local function startAntiBanSafe()
        if data.running then return end
        data.running = true

        safe(hookRequests)
        safe(hookFindFirstChild)
        safe(safeBypass)

        -- Disable screenshot/video flags li√™n t·ª•c
        protectionThread = task.spawn(function()
            while data.running do
                safe(disableReportFlags)
                task.wait(0.2)
            end
        end)

        print("[Anti-Ban Safe] üõ°Ô∏è ENABLED!")
    end

    -- T·ª± ƒë·ªông b·∫≠t AntiBanV3 ngay khi ch·∫°y script
    startAntiBanSafe()
end
---------------------------------------------------------------------------------
-- ü™Ñ Ch·ª©c NƒÉng
---------------------------------------------------------------------------------

do
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = Players.LocalPlayer

    local Active = false
    local loopRunning = false
    local CurrentTarget = nil
    local lastAttack = 0

    local KillersList = {
        ["Slasher"] = true,
        ["1x1x1x1"] = true,
        ["c00lkidd"] = true,
        ["Noli"] = true,
        ["JohnDoe"] = true,
        ["Quest666"] = true,
    }

    local PriorityList = {
        ["0206octavio"] = true
    }

    local SkillList = {
        "Slash", "Stab", "Punch",
        "VoidRush", "Nova",
        "CorruptEnergy", "Behead", "GashingWound",
        "MassInfection", "CorruptNature", "WalkspeedOverride", "PizzaDelivery",
        "UnstableEye", "Entanglement",
        "DigitalFootprint", "404Error",
        "RagingPace"
    }

    local SkillRemotes = {}

    local function findSkillRemoteFromButton(button)
        for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                for _, v in pairs(getupvalues(f)) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        return v
                    end
                end
            end
        end
        return nil
    end

    local function initSkillButtons()
        local gui = LocalPlayer:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        if not container then return end

        for _, child in ipairs(container:GetChildren()) do
            if child:IsA("ImageButton") then
                local remote = findSkillRemoteFromButton(child)
                if remote then
                    SkillRemotes[child.Name] = remote
                    warn("[Skill] Found RemoteEvent for:", child.Name, remote:GetFullName())
                end
            end
        end
    end

    initSkillButtons()
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        initSkillButtons()
    end)

    local function GetPriorityTarget()
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                if PriorityList[survivor.Name] then
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        return survivor
                    end
                end
            end
        end
        return nil
    end

    local function GetClosestSurvivor()
        local priorityTarget = GetPriorityTarget()
        if priorityTarget then return priorityTarget end

        local localChar = LocalPlayer.Character
        if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        local closest, minDist = nil, math.huge
        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            local humanoid = survivor:FindFirstChildOfClass("Humanoid")
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                local dist = (localChar.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    closest = survivor
                end
            end
        end
        return closest
    end

    local function KillTarget(target)
        pcall(function()
            if not target then return end
            local localChar = LocalPlayer.Character
            if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end

            local root = localChar.HumanoidRootPart
            local targetRoot = target:FindFirstChild("HumanoidRootPart")
            if not targetRoot then return end

            if tick() - lastAttack >= 0.05 then
                lastAttack = tick()

                for _, skillName in ipairs(SkillList) do
                    local offset = targetRoot.CFrame.LookVector * -2
                    root.CFrame = targetRoot.CFrame + offset

                    local remote = SkillRemotes[skillName]
                    if remote then
                        remote:FireServer(true)
                        task.wait(0.005)
                        remote:FireServer(false)
                    else
                        local gui = LocalPlayer:FindFirstChild("PlayerGui")
                        local mainUI = gui and gui:FindFirstChild("MainUI")
                        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
                        if container then
                            local button = container:FindFirstChild(skillName)
                            if button and button:IsA("ImageButton") then
                                for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
                                    if conn.Function then
                                        pcall(conn.Function)
                                    end
                                end
                                pcall(function() button:Activate() end)
                            end
                        end

                        local net = ReplicatedStorage:FindFirstChild("Modules")
                                    and ReplicatedStorage.Modules:FindFirstChild("Network")
                                    and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
                        if net and typeof(net.FireServer) == "function" then
                            net:FireServer("UseActorAbility", skillName)
                        end
                    end

                    task.wait(0.01)
                end
            end
        end)
    end

    local function StartLoop()
        if loopRunning then return end
        loopRunning = true
        task.spawn(function()
            while Active do
                local char = LocalPlayer.Character
                if not (char and KillersList[char.Name]) then
                    CurrentTarget = nil
                    task.wait(0.5)
                    continue
                end

                if not CurrentTarget 
                   or not CurrentTarget.Parent 
                   or not CurrentTarget:FindFirstChildOfClass("Humanoid") 
                   or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
                    CurrentTarget = GetClosestSurvivor()
                end
                if CurrentTarget then
                    KillTarget(CurrentTarget)
                end
                task.wait(0.01)
            end
            loopRunning = false
        end)
    end

    -- üü¢ N√∫t d·∫°ng code1
    FarmTab:Toggle("Killers Farm V2", Active, "T·ª± ƒë·ªông gi·∫øt ng∆∞·ªùi s·ªëng s√≥t", function(Value)
        Active = Value
        if Active then
            StartLoop()
        end
    end)
end



local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local solveGeneratorCooldown = false
local genDelay = 0.75
local currentCharacter
local Spectators = {}
local isInGame, Survivor = false, false

-- üü• Killer nguy hi·ªÉm
local DangerousKillers = {
    ["Slasher"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- üü¢ Ki·ªÉm tra killer g·∫ßn generator
local function isKillerNearGenerator(generatorPos, distance)
    local killersFolder = workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return false end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            if DangerousKillers[killer.Name] then
                local dist = (killer.HumanoidRootPart.Position - generatorPos).Magnitude
                if dist <= distance then
                    return true
                end
            end
        end
    end
    return false
end

-- üü¢ T√¨m generator ch∆∞a xong
local function getUnfinishedGenerators()
    local list = {}
    local map = workspace:FindFirstChild("Map") 
        and workspace.Map:FindFirstChild("Ingame") 
        and workspace.Map.Ingame:FindFirstChild("Map")
    if map then
        for _, gen in ipairs(map:GetChildren()) do
            if gen.Name == "Generator" 
                and gen:FindFirstChild("Progress") 
                and gen.Progress.Value < 100 then
                table.insert(list, gen)
            end
        end
    end

    genDelay = (#list == 1) and 1.5 or 0.75
    return list
end

-- üü¢ H√†m s·ª≠a 1 generator
local function fixOneGenerator(gen)
    if solveGeneratorCooldown then return end
    if not currentCharacter or not currentCharacter:FindFirstChild("HumanoidRootPart") then return end

    local genCFrame = gen:GetPivot()
    local goalPos = (genCFrame * CFrame.new(0, 0, -6)).Position

    if isKillerNearGenerator(goalPos, 45) then
        print("‚ö†Ô∏è B·ªè qua generator v√¨ killer g·∫ßn!")
        return
    end

    -- Teleport t·ªõi gen (1 l·∫ßn)
    currentCharacter:PivotTo(CFrame.new(goalPos))
    task.wait(0.25)

    -- Chu·∫©n b·ªã prompt
    local prompt = gen:FindFirstChild("Main") and gen.Main:FindFirstChild("Prompt")
    if prompt then
        prompt.HoldDuration = 0
        prompt.RequiresLineOfSight = false
        prompt.MaxActivationDistance = 99999
    end

    -- ·∫§n m·ªü gen 3 l·∫ßn c·ª±c nhanh (gi·ªëng b·∫£n g·ªëc)
    if prompt then
        pcall(function()
            for i = 1, 3 do
                prompt:InputHoldBegin()
                task.wait(0)
                prompt:InputHoldEnd()
            end
        end)
    end

    -- G·ª≠i t√≠n hi·ªáu s·ª≠a gen
    if gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
        pcall(function()
            gen.Remotes.RE:FireServer()
        end)
    end

    -- Cooldown tr√°nh spam
    solveGeneratorCooldown = true
    task.delay(genDelay, function()
        solveGeneratorCooldown = false
    end)
end

-- ‚úÖ Toggle ch√≠nh (Fluent style)
FarmTab:Toggle("Survivors Farm V2", _G.SurvivorsFarm or false, "T·ª± ƒë·ªông s·ª≠a m√°y ph√°t ƒëi·ªán", function(Value)
    _G.SurvivorsFarm = Value
    StopTween(_G.SurvivorsFarm)
end)

-- ‚úÖ V√≤ng l·∫∑p ch√≠nh
task.spawn(function()
    while task.wait(0.1) do
        if _G.SurvivorsFarm then
            -- c·∫≠p nh·∫≠t spectators
            Spectators = {}
            for _, v in ipairs(workspace:WaitForChild("Players"):WaitForChild("Spectating"):GetChildren()) do
                table.insert(Spectators, v.Name)
            end
            isInGame = not table.find(Spectators, LP.Name)

            -- ki·ªÉm tra survivor
            local survivorsFolder = workspace.Players:FindFirstChild("Survivors")
            Survivor = survivorsFolder 
                and (survivorsFolder:FindFirstChild(LP.Name) 
                or table.find(survivorsFolder:GetChildren(), LP.Character))

            -- n·∫øu l√† survivor v√† ƒëang trong game
            if Survivor and isInGame then
                local survivorsFolder = workspace.Players:WaitForChild("Survivors")
                for _, surv in ipairs(survivorsFolder:GetChildren()) do
                    if surv:GetAttribute("Username") == LP.Name then
                        currentCharacter = surv
                        break
                    end
                end

                -- t√¨m v√† s·ª≠a gen
                local gens = getUnfinishedGenerators()
                for _, gen in ipairs(gens) do
                    if not _G.SurvivorsFarm then break end
                    fixOneGenerator(gen)
                    -- ƒë·ª£i cooldown tr∆∞·ªõc khi sang gen kh√°c
                    while solveGeneratorCooldown and _G.SurvivorsFarm do
                        task.wait(0.05)
                    end
                end
            end
        end
    end
end)


FarmTab:Seperator("Generator");

do
    local solveGeneratorCooldown = false
    _G.AutoFinishGen = _G.AutoFinishGen or false
    local genDelay = 2 -- m·∫∑c ƒë·ªãnh 2s

    -- üß≠ H√†m t√¨m generator g·∫ßn nh·∫•t
    local function getClosestGenerator()
        local char = game.Players.LocalPlayer.Character
        if not char or not char.PrimaryPart then return nil end

        local root = char.PrimaryPart
        local closest, shortestDist = nil, math.huge

        local mapContainer = workspace:FindFirstChild("Map")
        if mapContainer then
            local ingame = mapContainer:FindFirstChild("Ingame")
            if ingame then
                local map = ingame:FindFirstChild("Map")
                if map then
                    for _, obj in ipairs(map:GetChildren()) do
                        if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                            local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                            if dist < shortestDist then
                                closest = obj
                                shortestDist = dist
                            end
                        end
                    end
                end
            end
        end
        return closest
    end

    -- üß© N√∫t Finish generator th·ªß c√¥ng
    FarmTab:Button("Finish Generator", function()
        if solveGeneratorCooldown then 
            print("‚è≥ Please wait before trying again!") 
            return
        end
        if _G.AutoFinishGen then
            print("‚ùå Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(genDelay, function()
                solveGeneratorCooldown = false
            end)
        else
            print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y generator kh·∫£ d·ª•ng!")
        end
    end)

    -- üîÅ Toggle Auto Finish Generator
    FarmTab:Toggle("Auto Finish Generator", _G.AutoFinishGen, "T·ª± ƒë·ªông ho√†n th√†nh m√°y ph√°t ƒëi·ªán", function(state)
        _G.AutoFinishGen = state

        if state then
            if solveGeneratorCooldown then
                print("‚ö†Ô∏è Please wait cooldown before enabling Auto Finish!") 
                _G.AutoFinishGen = false
                return
            end

            task.spawn(function()
                while _G.AutoFinishGen do
                    local gen = getClosestGenerator()
                    if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                        gen.Remotes.RE:FireServer()
                    end
                    solveGeneratorCooldown = true
                    task.wait(genDelay)
                    solveGeneratorCooldown = false
                end
            end)
        else
            solveGeneratorCooldown = false
        end
    end)

    -- üéöÔ∏è Slider ch·ªânh delay (chu·∫©n Fluent)
    FarmTab:Slider("Generator Delay", 2, 10, genDelay, 0.1, "Delay s·ª≠a m√°y ph√°t ƒëi·ªán", function(value)
        genDelay = value
        print("‚è± Delay set to:", genDelay)
    end)
end

FarmTab:Seperator("Item");

do
    local Players = game:GetService("Players")
    local LP = Players.LocalPlayer
    local pickDelay = 0.2 -- delay m·∫∑c ƒë·ªãnh
    _G.PickupItem = _G.PickupItem or false

    -- üß≠ H√†m nh·∫∑t item g·∫ßn nh·∫•t
    local function pickUpNearest()
        local map = workspace:FindFirstChild("Map")
                    and workspace.Map:FindFirstChild("Ingame")
                    and workspace.Map.Ingame:FindFirstChild("Map")

        if not map or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then return end

        local oldCFrame = LP.Character.HumanoidRootPart.CFrame
        for _, item in ipairs(map:GetChildren()) do
            if item:IsA("Tool") and item:FindFirstChild("ItemRoot")
               and item.ItemRoot:FindFirstChild("ProximityPrompt") then
                LP.Character.HumanoidRootPart.CFrame = item.ItemRoot.CFrame
                task.wait(0.3)
                fireproximityprompt(item.ItemRoot.ProximityPrompt)
                task.wait(0.4)
                LP.Character.HumanoidRootPart.CFrame = oldCFrame
                break
            end
        end
    end

    -- üß© N√∫t nh·∫∑t item 1 l·∫ßn (chu·∫©n Fluent)
    FarmTab:Button("Pick Up Item", function()
        pickUpNearest()
    end)

    -- üîÅ Toggle auto nh·∫∑t item (chu·∫©n Fluent)
    FarmTab:Toggle("Auto Pick Up Item", _G.PickupItem, "T·ª± ƒë·ªông nh·∫∑t v·∫≠t ph·∫©m g·∫ßn nh·∫•t", function(state)
        _G.PickupItem = state
        if not state then return end

        task.spawn(function()
            while _G.PickupItem do
                pickUpNearest()
                task.wait(pickDelay)
            end
        end)
    end)
end


---------------------------------------------------------------------------------
-- Main
---------------------------------------------------------------------------------



do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local enabled = false
    local cooldown = false
    local lastTarget = nil
    local maxDistance = 5

    local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli", "Quest666" }
    local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

    -- Slash button + remote
    local slashButton, slashRemote, slashConnections = nil, nil, {}

    local function findSlashRemote()
        if slashRemote then return slashRemote end
        if not slashButton then return nil end
        for _, conn in ipairs(getconnections(slashButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                for _, v in pairs(getupvalues(f)) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        slashRemote = v
                        warn("[AutoSlash] Found Slash Remote:", v:GetFullName())
                        return slashRemote
                    end
                end
            end
        end
        return nil
    end

    local function initSlashButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        slashButton = container and container:FindFirstChild("Slash")
        if slashButton and slashButton:IsA("ImageButton") then
            slashConnections = getconnections(slashButton.MouseButton1Click)
            findSlashRemote()
        end
    end

    initSlashButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initSlashButton()
    end)

    local function useSlash()
        if slashRemote then
            pcall(function()
                slashRemote:FireServer(true)
                task.delay(0.05, function()
                    slashRemote:FireServer(false)
                end)
            end)
        elseif slashButton then
            for _, conn in ipairs(slashConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() slashButton:Activate() end)
        end
    end

    -- Toggle ki·ªÉu MainTab
    MiscTab:Toggle("Auto Slash", enabled, "T·ª± ƒë·ªông d·ªãch chuy·ªÉn v√† t·∫•n c√¥ng", function(val)
        enabled = val
    end)

    -- Slider ki·ªÉu SeaTab
    MiscTab:Slider("Slash Distance", 1, 50, maxDistance, function(v)
        maxDistance = v
    end)

    -- Helper
    local function isBehindTarget(hrp, targetHRP)
        local direction = targetHRP.CFrame.LookVector
        local toPlayer = (hrp.Position - targetHRP.Position)
        local distance = toPlayer.Magnitude
        local isBehind = toPlayer:Dot(direction) < -0.5
        return distance <= maxDistance and isBehind
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if not enabled or cooldown then return end

        local char = lp.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
        local hrp = char.HumanoidRootPart

        for _, name in ipairs(killerNames) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("HumanoidRootPart") then
                local kHRP = killer.HumanoidRootPart

                if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
                    cooldown = true
                    lastTarget = killer

                    -- Teleport ra sau l∆∞ng
                    local backPos = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                    hrp.CFrame = CFrame.new(backPos, kHRP.Position)

                    -- Gi·ªØ v·ªã tr√≠ + spam Slash 1 gi√¢y
                    local start = tick()
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not (char and char.Parent and kHRP and kHRP.Parent) then
                            if connection then connection:Disconnect() end
                            return
                        end
                        if tick() - start >= 1 then
                            if connection then connection:Disconnect() end
                            task.delay(2, function()
                                cooldown = false
                                lastTarget = nil
                            end)
                            return
                        end

                        local back = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                        hrp.CFrame = CFrame.new(back, kHRP.Position)

                        -- G·ªçi skill Slash qua UI Remote
                        useSlash()
                    end)

                    break
                end
            end
        end
    end)
end





do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local healEnabled = false
    local healHPThreshold = 50
    local healDistance = 50

    -- Heal button + remote
    local healButton, healRemote, healConnections = nil, nil, {}

    -- T√¨m RemoteEvent t·ª´ button Heal
    local function findHealRemote()
        if healRemote then return healRemote end
        if not healButton then return nil end
        for _, conn in ipairs(getconnections(healButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                local upvals = getupvalues(f)
                for _, v in pairs(upvals) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        healRemote = v
                        warn("[AutoHeal] Found Heal Remote:", v:GetFullName())
                        return healRemote
                    end
                end
            end
        end
        return nil
    end

    local function initHealButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        healButton = container and container:FindFirstChild("FriedChicken")
        if healButton and healButton:IsA("ImageButton") then
            healConnections = getconnections(healButton.MouseButton1Click)
            findHealRemote()
        end
    end

    initHealButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initHealButton()
    end)

    local function useHeal()
        if healRemote then
            pcall(function()
                healRemote:FireServer(true)
                task.delay(0.05, function()
                    healRemote:FireServer(false)
                end)
            end)
        elseif healButton then
            for _, conn in ipairs(healConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() healButton:Activate() end)
        end
    end

    -- Toggle + slider UI ki·ªÉu Fluent
    MiscTab:Toggle("Auto Heal", healEnabled, "T·ª± ƒë·ªông h·ªìi m√°u khi HP th·∫•p v√† kh√¥ng c√≥ k·∫ª g·∫ßn", function(val)
        healEnabled = val
    end)

    MiscTab:Slider("Heal HP", 1, 100, healHPThreshold, function(v)
        healHPThreshold = v
    end)

    MiscTab:Slider("Heal Distance", 1, 150, healDistance, function(v)
        healDistance = v
    end)

    -- Helpers -------------------------------------------------------------
    local function getPlayersFolders()
        local pf = workspace:FindFirstChild("Players")
        if not pf then return nil, nil, nil end
        return pf, pf:FindFirstChild("Killers"), pf:FindFirstChild("Survivors")
    end

    local function belongsToMe(m)
        if not (m and m:IsA("Model")) then return false end
        if m:GetAttribute("Username") == lp.Name then return true end
        local UsernameSV = m:FindFirstChild("Username")
        if UsernameSV and typeof(UsernameSV.Value) == "string" and UsernameSV.Value == lp.Name then return true end
        local Owner = m:FindFirstChild("Owner") or m:FindFirstChild("Player")
        if Owner and Owner.Value == lp then return true end
        local uidAttr = m:GetAttribute("UserId")
        if uidAttr and tonumber(uidAttr) == lp.UserId then return true end
        if m.Name == lp.Name then return true end
        return false
    end

    local function getMyShedletsky()
        local pf, killersFolder, survivorsFolder = getPlayersFolders()
        local candidates = {}

        local function scan(container)
            if not container then return end
            for _, d in ipairs(container:GetDescendants()) do
                if d:IsA("Model") and d.Name == "Shedletsky" and d:FindFirstChild("Humanoid") and d:FindFirstChild("HumanoidRootPart") then
                    if belongsToMe(d) then table.insert(candidates, d) end
                end
            end
        end

        scan(killersFolder)
        scan(survivorsFolder)
        scan(workspace)

        if #candidates == 0 then return nil, nil, nil end

        local basePos
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            basePos = lp.Character.HumanoidRootPart.Position
        end

        local best, bestDist = candidates[1], math.huge
        if basePos then
            for _, m in ipairs(candidates) do
                local hrp = m:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local d = (hrp.Position - basePos).Magnitude
                    if d < bestDist then best, bestDist = m, d end
                end
            end
        end

        local hum = best:FindFirstChildOfClass("Humanoid")
        local hrp = best:FindFirstChild("HumanoidRootPart")
        return best, hum, hrp
    end

    local function getNearestKillerDist(fromHRP, myModel)
        local _, killersFolder = getPlayersFolders()
        if not (killersFolder and fromHRP) then return math.huge end
        local nearest = math.huge
        for _, k in ipairs(killersFolder:GetChildren()) do
            if k ~= myModel then
                local khrp = k:FindFirstChild("HumanoidRootPart")
                if khrp then
                    local d = (fromHRP.Position - khrp.Position).Magnitude
                    if d < nearest then nearest = d end
                end
            end
        end
        return nearest
    end

    -- Main loop ----------------------------------------------------------
    RunService.Heartbeat:Connect(function()
        if not healEnabled then return end

        local myModel, myHumanoid, myHRP = getMyShedletsky()
        if not (myModel and myHumanoid and myHRP) then return end
        if myHumanoid.Health <= 0 then return end

        local nearestDist = getNearestKillerDist(myHRP, myModel)

        if myHumanoid.Health <= healHPThreshold and nearestDist >= healDistance then
            useHeal()
        end
    end)
end




---------------------------------------------------------------------------------
-- Player
---------------------------------------------------------------------------------

do
    -- ======= D·ªäCH V·ª§ =======
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer

    -- ======= WHITELIST =======
    local AllowedPlayers = {
        ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
        ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
        ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true,
        ["Dusekkar"] = true, ["Veeronica"] = true,
    }

    local AllowedKillers = {
        ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
        ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true,
    }

    -- ======= BI·∫æN TR·∫†NG TH√ÅI =======
    local AimlockPlayerEnabled = false
    local AimlockKillerEnabled = false
    local CurrentTarget = nil
    local lastHumanoidAutoRotate = nil

    -- ======= H√ÄM H·ªñ TR·ª¢ =======
    local function IsAllowed(model, list)
        return list[model.Name] == true
    end

    local function GetModelFromPlayer(plr, list)
        if not plr.Character then return nil end
        if IsAllowed(plr.Character, list) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
            return plr.Character
        end
        for _, model in ipairs(workspace:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
                if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                    if IsAllowed(model, list) then
                        return model
                    end
                end
            end
        end
        return nil
    end

    local function GetClosestTarget(list)
        local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return nil end
        local closest, dist = nil, math.huge

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local model = GetModelFromPlayer(plr, list)
                if model and model.PrimaryPart then
                    local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                        if distance < dist then
                            dist = distance
                            closest = model
                        end
                    end
                end
            end
        end
        return closest
    end

    local function ValidateTarget(target)
        if not target then return false end
        local humanoid = target:FindFirstChildWhichIsA("Humanoid")
        return humanoid and humanoid.Health > 0 and target.PrimaryPart ~= nil
    end

    -- reset khi respawn
    LocalPlayer.CharacterAdded:Connect(function(char)
        CurrentTarget = nil
        if lastHumanoidAutoRotate ~= nil then
            local hum = char:FindFirstChildWhichIsA("Humanoid")
            if hum then
                hum.AutoRotate = lastHumanoidAutoRotate
            end
            lastHumanoidAutoRotate = nil
        end
    end)

    -- ======= AIMBOT LOOP =======
    RunService.RenderStepped:Connect(function()
        local myChar = LocalPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local humanoid = myChar and myChar:FindFirstChildWhichIsA("Humanoid")

        if not myRoot then return end

        -- toggle AutoRotate
        if (AimlockPlayerEnabled or AimlockKillerEnabled) and humanoid then
            if lastHumanoidAutoRotate == nil then
                lastHumanoidAutoRotate = humanoid.AutoRotate
            end
            humanoid.AutoRotate = false
        elseif humanoid and lastHumanoidAutoRotate ~= nil then
            humanoid.AutoRotate = lastHumanoidAutoRotate
            lastHumanoidAutoRotate = nil
        end

        -- h∆∞·ªõng nh√¨n target
        local function faceTarget(target)
            if not target or not target.PrimaryPart then return end
            local pos = myRoot.Position
            local targetPos = target.PrimaryPart.Position
            local dir = Vector3.new(targetPos.X, pos.Y, targetPos.Z) - pos
            if dir.Magnitude == 0 then return end

            local lookVector = dir.Unit
            local up = Vector3.yAxis
            local rightVector = lookVector:Cross(up)
            if rightVector.Magnitude == 0 then
                rightVector = Vector3.new(1, 0, 0)
            else
                rightVector = rightVector.Unit
            end

            myRoot.CFrame = CFrame.fromMatrix(pos, rightVector, up)
        end

        if AimlockPlayerEnabled then
            if not ValidateTarget(CurrentTarget) then
                CurrentTarget = GetClosestTarget(AllowedPlayers)
            end
            if ValidateTarget(CurrentTarget) then
                faceTarget(CurrentTarget)
            end
        elseif AimlockKillerEnabled then
            if not ValidateTarget(CurrentTarget) then
                CurrentTarget = GetClosestTarget(AllowedKillers)
            end
            if ValidateTarget(CurrentTarget) then
                faceTarget(CurrentTarget)
            end
        else
            CurrentTarget = nil
        end
    end)

    -- ======= FLUENT TOGGLES (chu·∫©n d·∫°ng code1) =======

    PlayerTab:Toggle("Aimbot Survivor", AimlockPlayerEnabled, "T·ª± ƒë·ªông kh√≥a h∆∞·ªõng nh√¨n v√†o Player", function(value)
        AimlockPlayerEnabled = value
        if value then
            AimlockKillerEnabled = false
            CurrentTarget = nil
        end
    end)

    PlayerTab:Toggle("Aimbot Killer", AimlockKillerEnabled, "T·ª± ƒë·ªông kh√≥a h∆∞·ªõng nh√¨n v√†o Killer", function(value)
        AimlockKillerEnabled = value
        if value then
            AimlockPlayerEnabled = false
            CurrentTarget = nil
        end
    end)
end




PlayerTab:Seperator("Cheats");

local ActiveNoStun = false
local noStunLoop

PlayerTab:Toggle("No Stun", _G.NoStun or false, "Ch·∫∑n b·ªã stun khi b·ªã t·∫•n c√¥ng", function(value)
    _G.NoStun = value
    ActiveNoStun = value

    if value then
        -- N·∫øu c√≥ loop c≈© th√¨ d·ª´ng
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end

        -- T·∫°o loop m·ªõi li√™n t·ª•c ƒë·∫£m b·∫£o HumanoidRootPart kh√¥ng b·ªã anchored
        noStunLoop = task.spawn(function()
            while ActiveNoStun do
                local character = game.Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
                task.wait(0.1) -- nh·∫π, tr√°nh lag
            end
        end)
    else
        -- T·∫Øt loop khi toggle off
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end
    end
end)





do
    local InfStaminaEnabled = false  
    local staminaLoop  
    local StaminaModule  

    -- Th·ª≠ l·∫•y module an to√†n
    pcall(function()  
        local ReplicatedStorage = game:GetService("ReplicatedStorage")  
        local path = ReplicatedStorage:FindFirstChild("Systems")  
            and ReplicatedStorage.Systems:FindFirstChild("Character")  
            and ReplicatedStorage.Systems.Character:FindFirstChild("Game")  
            and ReplicatedStorage.Systems.Character.Game:FindFirstChild("Sprinting")  

        if path then  
            StaminaModule = require(path)  
        end  
    end)  

    -- H√†m h·ªìi stamina an to√†n
    local function restoreStamina()  
        if not StaminaModule then return end  

        local maxStamina = StaminaModule.MaxStamina or 100  
        if StaminaModule.Stamina then  
            if typeof(StaminaModule.SetStamina) == "function" then  
                StaminaModule:SetStamina(maxStamina)  
            elseif typeof(StaminaModule.UpdateStamina) == "function" then  
                StaminaModule:UpdateStamina(maxStamina)  
            else  
                StaminaModule.Stamina = maxStamina  
            end  
        end  
    end  

    -- Ch·ªâ t·∫°o toggle n·∫øu module t·ªìn t·∫°i
    if StaminaModule then  
        PlayerTab:Toggle("Infinite Stamina", InfStaminaEnabled, "V√¥ h·∫°n stamina", function(value)
            InfStaminaEnabled = value

            -- N·∫øu module c√≥ thu·ªôc t√≠nh StaminaLossDisabled th√¨ set lu√¥n
            if StaminaModule.StaminaLossDisabled ~= nil then
                StaminaModule.StaminaLossDisabled = value
            end

            if value then
                restoreStamina()
                if not staminaLoop then
                    staminaLoop = task.spawn(function()
                        while InfStaminaEnabled do
                            task.wait(0.01)
                            restoreStamina()
                        end
                        staminaLoop = nil
                    end)
                end
            end
        end)
    else
        warn("[InfStamina] Sprinting module not found, toggle disabled.")
    end
end





PlayerTab:Seperator("Animation");

do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local player = Players.LocalPlayer

    local sprintModule
    pcall(function()
        sprintModule = require(ReplicatedStorage:WaitForChild("Systems").Character.Game.Sprinting)
    end)

    local KillersData = {
        ["Shasher"] = {
            ["Default"] = {Idle="rbxassetid://116050994905421", Walk="rbxassetid://93622022596108", Run="rbxassetid://93054787145505"},
            ["Pursuer"] = {Idle="rbxassetid://94895464960972", Walk="rbxassetid://100206079439305", Run="rbxassetid://138660433982140"},
            ["subject_0"] = {Idle="rbxassetid://14301056458", Walk="rbxassetid://122325883800612", Run="rbxassetid://97248175252805"}
        },
        ["Coolkidd"] = {["Default"] = {Idle="rbxassetid://18885903667", Walk="rbxassetid://18885906143", Run="rbxassetid://96571077893813"}},
        ["John Doe"] = {
            ["Default"] = {Idle="rbxassetid://105880087711722", Walk="rbxassetid://81193817424328", Run="rbxassetid://132653655520682"},
            ["Shadow"] = {Idle="rbxassetid://00000000001", Walk="rbxassetid://00000000002", Run="rbxassetid://00000000003"}
        },
        ["Noli"] = {["Default"] = {Idle="rbxassetid://93841120533318", Walk="rbxassetid://109700476007435", Run="rbxassetid://117451341682452"}},
        ["1x1x1x1"] = {
            ["Default"] = {Idle="rbxassetid://138754221537146", Walk="rbxassetid://131235528875091", Run="rbxassetid://106485518413331"},
            ["Hacklord [Old]"] = {Idle="rbxassetid://82241652784826", Walk="rbxassetid://119242164490314", Run="rbxassetid://92430101129682"},
            ["Hacklord [New]"] = {Idle="rbxassetid://106131211773069", Walk="rbxassetid://119112338263474", Run="rbxassetid://85339002634979"}
        },
        ["Herobrine"] = {["Default"] = {Idle="rbxassetid://107799240559806", Walk="rbxassetid://89380107485006", Run="rbxassetid://134157363854022"}},
        ["Gubby"] = {["Default"] = {Idle="rbxassetid://88333702239259", Walk="rbxassetid://115244584291581", Run="rbxassetid://115244584291581"}},
        ["Sancho"] = {["Default"] = {Idle="rbxassetid://115073581864188", Walk="rbxassetid://95213748170889", Run="rbxassetid://75409814098993"}},
        ["Erlking"] = {["Default"] = {Idle="rbxassetid://93727662665079", Walk="rbxassetid://97625643261790", Run="rbxassetid://119357938208454"}},
        ["Sukuna"] = {["Default"] = {Idle="rbxassetid://115268929362938", Walk="rbxassetid://123678890237669", Run="rbxassetid://132086389849889", Music="rbxassetid://73595818073606"}}
    }

    local enabled = false
    local selectedKiller = "Shasher"
    local selectedSkin = "Default"
    local character, humanoid, animator
    local idleAnim, walkAnim, runAnim
    local idleTrack, walkTrack, runTrack
    local _isSprinting = false
    local musicSound
    local runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn
    local heartbeatAccumulator = 0
    local HEARTBEAT_CHECK_INTERVAL = 0.12

    -- ==============================
    local function stopAndClearTracks()
        for _, track in ipairs({idleTrack, walkTrack, runTrack}) do
            if track then pcall(function() track:Stop() end) end
        end
        idleTrack, walkTrack, runTrack = nil, nil, nil
    end

    local function stopMusic()
        if musicSound then
            pcall(function() musicSound:Stop() musicSound:Destroy() end)
            musicSound = nil
        end
    end

    local function playMusicIfSukuna(set)
        stopMusic()
        if selectedKiller=="Sukuna" and set and set.Music then
            local sound = Instance.new("Sound")
            sound.SoundId = set.Music
            sound.Looped = true
            sound.Volume = 2
            sound.Parent = workspace
            sound:Play()
            musicSound = sound
        end
    end

    local function loadAnimObjects(killer, skin)
        local killerTable = KillersData[killer]
        if not killerTable then return end
        local set = killerTable[skin or "Default"] or killerTable["Default"]
        if not set then return end

        idleAnim = Instance.new("Animation")
        walkAnim = Instance.new("Animation")
        runAnim = Instance.new("Animation")
        idleAnim.AnimationId, walkAnim.AnimationId, runAnim.AnimationId = set.Idle, set.Walk, set.Run
        playMusicIfSukuna(set)
    end

    local function playAnim(animObj, trackType)
        if not animator then return end
        if trackType~="Idle" and idleTrack then pcall(function() idleTrack:Stop() end) idleTrack=nil end
        if trackType~="Walk" and walkTrack then pcall(function() walkTrack:Stop() end) walkTrack=nil end
        if trackType~="Run" and runTrack then pcall(function() runTrack:Stop() end) runTrack=nil end

        local track
        if trackType=="Idle" and not idleTrack then idleTrack=animator:LoadAnimation(idleAnim) track=idleTrack
        elseif trackType=="Walk" and not walkTrack then walkTrack=animator:LoadAnimation(walkAnim) track=walkTrack
        elseif trackType=="Run" and not runTrack then runTrack=animator:LoadAnimation(runAnim) track=runTrack
        else track=(trackType=="Idle" and idleTrack) or (trackType=="Walk" and walkTrack) or runTrack end

        if track and not track.IsPlaying then pcall(function() track:Play() end) end
    end

    local function updateMovementState()
        if not enabled or not character then return end
        local moving=false
        if humanoid and humanoid.MoveDirection then
            moving = humanoid.MoveDirection.Magnitude>0
            if not moving then
                local root=character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
                if root and root.Velocity.Magnitude>1 then moving=true end
            end
        end
        if moving then
            local sprintingNow=(sprintModule and sprintModule.IsSprinting) or _isSprinting
            if sprintingNow then playAnim(runAnim,"Run") else playAnim(walkAnim,"Walk") end
        else
            playAnim(idleAnim,"Idle")
        end
    end

    local function setupMovementListeners()
        if inputBeganConn then inputBeganConn:Disconnect() end
        if inputEndedConn then inputEndedConn:Disconnect() end
        if runningConn then runningConn:Disconnect() end
        if heartbeatConn then heartbeatConn:Disconnect() end

        inputBeganConn=UserInputService.InputBegan:Connect(function(input,gp)
            if gp then return end
            if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=true end
        end)
        inputEndedConn=UserInputService.InputEnded:Connect(function(input,gp)
            if gp then return end
            if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=false end
        end)

        if humanoid and humanoid.Running then
            runningConn=humanoid.Running:Connect(function(speed)
                if not enabled then return end
                if speed>0 then updateMovementState() else playAnim(idleAnim,"Idle") end
            end)
        else
            heartbeatAccumulator=0
            heartbeatConn=RunService.Heartbeat:Connect(function(dt)
                if not enabled or not character then return end
                heartbeatAccumulator+=dt
                if heartbeatAccumulator>=HEARTBEAT_CHECK_INTERVAL then
                    heartbeatAccumulator=0
                    updateMovementState()
                end
            end)
        end
    end

    local function onCharacterBound(char)
        stopAndClearTracks()
        stopMusic()
        character=char
        humanoid=char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
        if humanoid then
            animator=humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator",humanoid)
        end
        if enabled then
            loadAnimObjects(selectedKiller, selectedSkin)
            setupMovementListeners()
            updateMovementState()
        end
    end

    player.CharacterAdded:Connect(onCharacterBound)
    if player.Character then onCharacterBound(player.Character) end

    -- =========================
    -- H·ª£p nh·∫•t Dropdown Killer + Skin
    -- =========================
    local options = {}
    for k, skins in pairs(KillersData) do
        for s,_ in pairs(skins) do
            table.insert(options, k.." | "..s)
        end
    end
    table.sort(options)

    PlayerTab:Dropdown("Choose Killer & Skin", options, selectedKiller.." | "..selectedSkin, function(value)
        local split = string.split(value," | ")
        selectedKiller = split[1] or "Shasher"
        selectedSkin = split[2] or "Default"
        if enabled and player.Character then
            loadAnimObjects(selectedKiller, selectedSkin)
            stopAndClearTracks()
            updateMovementState()
        else
            stopMusic()
        end
    end)

    PlayerTab:Toggle("Fake Killers", false, "M·ªü kh√≥a animation c·ªßa c√°c killers", function(value)
        enabled = value
        if enabled and player.Character then
            loadAnimObjects(selectedKiller, selectedSkin)
            onCharacterBound(player.Character)
        else
            stopAndClearTracks()
            stopMusic()
        end
    end)
end




PlayerTab:Seperator("Hitbox");

repeat task.wait() until game:IsLoaded()

-- üîß Bi·∫øn c·∫•u h√¨nh to√†n c·ª•c
_G.ForsakenReachEnabled = _G.ForsakenReachEnabled or false
_G.NearestDist = _G.NearestDist or 120

-- üß≠ H√†m Fluent Toggle / Slider t·ª± ch·∫ø
PlayerTab:Toggle("Hitbox Devil", _G.ForsakenReachEnabled, "TƒÉng kho·∫£ng c√°ch hitbox", function(state)
    _G.ForsakenReachEnabled = state
    -- n·∫øu v·ª´a b·∫≠t m√† ƒëang trong combat ‚Üí k√≠ch ho·∫°t ngay
    if state then
        task.spawn(function()
            task.wait(0.1)
            pcall(ForsakenReachLogic)
        end)
    end
end)

PlayerTab:Slider("Distance", 10, 1000, _G.NearestDist, 1, "Kho·∫£ng c√°ch nh·∫≠n di·ªán m·ª•c ti√™u", function(value)
    _G.NearestDist = value
end)

-- ‚ö° Services setup
local Players = game:GetService('Players')
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

Player.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

local RNG = Random.new()

-- ‚öîÔ∏è AttackAnimations (gi·ªØ nguy√™n)
local AttackAnimations = { -- r√∫t g·ªçn v√≠ d·ª•
    'rbxassetid://131430497821198',
    'rbxassetid://83829782357897',
    'rbxassetid://126830014841198',
    'rbxassetid://126355327951215',
    'rbxassetid://121086746534252',
    'rbxassetid://105458270463374',
    'rbxassetid://127172483138092',
    'rbxassetid://18885919947',
    'rbxassetid://18885909645',
    'rbxassetid://87259391926321',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://86545133269813',
    'rbxassetid://89448354637442',
    'rbxassetid://90499469533503',
    'rbxassetid://116618003477002',
    'rbxassetid://106086955212611',
    'rbxassetid://107640065977686',
    'rbxassetid://77124578197357',
    'rbxassetid://101771617803133',
    'rbxassetid://134958187822107',
    'rbxassetid://111313169447787',
    'rbxassetid://71685573690338',
    'rbxassetid://71685573690338',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://136007065400978',
    'rbxassetid://136007065400978',
    'rbxassetid://86096387000557',
    'rbxassetid://86096387000557',
    'rbxassetid://108807732150251',
    'rbxassetid://138040001965654',
    'rbxassetid://73502073176819',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://97623143664485',
    'rbxassetid://97623143664485',
    'rbxassetid://86709774283672',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://140703210927645',
    'rbxassetid://96173857867228',
    'rbxassetid://121255898612475',
    'rbxassetid://98031287364865',
    'rbxassetid://119462383658044',
    'rbxassetid://77448521277146',
    'rbxassetid://77448521277146',
    'rbxassetid://103741352379819',
    'rbxassetid://119462383658044',
    'rbxassetid://131696603025265',
    'rbxassetid://122503338277352',
    'rbxassetid://97648548303678',
    'rbxassetid://94162446513587',
    'rbxassetid://84426150435898',
    'rbxassetid://93069721274110',
    'rbxassetid://114620047310688',
    'rbxassetid://97433060861952',
    'rbxassetid://82183356141401',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://70447634862911',
    'rbxassetid://92173139187970',
    'rbxassetid://106847695270773',
    'rbxassetid://125403313786645',
    'rbxassetid://81639435858902',
    'rbxassetid://137314737492715',
    'rbxassetid://120112897026015',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://126681776859538',
    'rbxassetid://129976080405072',
    'rbxassetid://109667959938617',
    'rbxassetid://74707328554358',
    'rbxassetid://133336594357903',
    'rbxassetid://86204001129974',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://124243639579224',
    'rbxassetid://70371667919898',
    'rbxassetid://131543461321709',
    'rbxassetid://136323728355613',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://106538427162796',
    'rbxassetid://109667959938617',
    'rbxassetid://126681776859538',
    'rbxassetid://129976080405072',
    'rbxassetid://110400453990786',
    'rbxassetid://83685305553364',
    'rbxassetid://126171487400618'
}

-- üßç‚Äç‚ôÇÔ∏è Danh s√°ch Killers / Survivors (gi·ªØ nguy√™n)
local Killers = { ["Slasher"] = true, ["1x1x1x1"] = true, ["Noli"] = true }
local Survivors = { ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true }

-- üåÄ H√†m ch√≠nh (ƒë·∫∑t tr∆∞·ªõc v√≤ng loop ƒë·ªÉ callback ·ªü tr√™n d√πng ƒë∆∞·ª£c)
function ForsakenReachLogic()
    if not _G.ForsakenReachEnabled or not HumanoidRootPart then
        return
    end

    local Playing = false
    for _, v in Humanoid:GetPlayingAnimationTracks() do
        if table.find(AttackAnimations, v.Animation.AnimationId)
        and (v.TimePosition / v.Length < 0.75) then
            Playing = true
            break
        end
    end
    if not Playing then return end

    local Target = nil
    local nearest = _G.NearestDist

    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj ~= Character then
            local hrp = obj:FindFirstChild("HumanoidRootPart")
            local hum = obj:FindFirstChild("Humanoid")
            if hrp and hum and hum.Health > 0 then
                local dist = (hrp.Position - HumanoidRootPart.Position).Magnitude
                if dist < nearest then
                    nearest = dist
                    Target = obj
                end
            end
        end
    end

    if Target then
        local OldVel = HumanoidRootPart.Velocity
        local NeededVel = (Target.HumanoidRootPart.Position - HumanoidRootPart.Position) / (Player:GetNetworkPing() * 2)
        HumanoidRootPart.Velocity = NeededVel
        game:GetService("RunService").RenderStepped:Wait()
        HumanoidRootPart.Velocity = OldVel
    end
end

-- üîÅ V√≤ng l·∫∑p ch√≠nh
task.spawn(function()
    while task.wait() do
        pcall(ForsakenReachLogic)
    end
end)


PlayerTab:Seperator("Walk Speed");


do
    -- === Teleport Speed Setup ===
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")
    local HRP = Character:WaitForChild("HumanoidRootPart")

    -- ‚öôÔ∏è C·∫•u h√¨nh
    local defaultSpeed = 40
    local maxSpeed = 300

    _G.TeleportSpeedEnabled = _G.TeleportSpeedEnabled or false
    _G.TeleportSpeedValue = _G.TeleportSpeedValue or defaultSpeed

    -- üîÅ C·∫≠p nh·∫≠t l·∫°i khi respawn
    LocalPlayer.CharacterAdded:Connect(function(char)
        Character = char
        Humanoid = Character:WaitForChild("Humanoid")
        HRP = Character:WaitForChild("HumanoidRootPart")
    end)

    -- üåÄ Loop teleport (ƒë·ªçc gi√° tr·ªã global m·ªói frame)
    RunService.Heartbeat:Connect(function(dt)
        if _G.TeleportSpeedEnabled and Humanoid and HRP then
            if Humanoid.MoveDirection.Magnitude > 0 then
                local moveDir = Humanoid.MoveDirection.Unit
                HRP.CFrame = HRP.CFrame + (moveDir * (_G.TeleportSpeedValue * dt))
            end
        end
    end)

    -- === GUI Fluent Custom ===

    -- üîò Toggle b·∫≠t/t·∫Øt teleport
    PlayerTab:Toggle("Teleport Speed", _G.TeleportSpeedEnabled, "ƒêi Si√™u Nhanh C√≥ Th·ªÉ Bay Ra Ngo√†i Map", function(state)
        _G.TeleportSpeedEnabled = state
    end)

    -- üéöÔ∏è Slider ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô (chu·∫©n Fluent)
    PlayerTab:Slider("Teleport Speed Value", 1, maxSpeed, _G.TeleportSpeedValue, function(v)
        _G.TeleportSpeedValue = v
    end)
end


---------------------------------------------------------------------------------
-- Visual
---------------------------------------------------------------------------------

do
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera

    local allowedModelsClone = {
        ["1x1x1x1Zombie"] = true,
        ["PizzaDeliveryRig"] = true,
        ["Mafia1"] = true,
        ["Mafia2"] = true,
        ["Mafia3"] = true,
        ["Mafia4"] = true,
    }

    local drawingsClone = {}
    local espConnectionClone, addedConnClone, removedConnClone

    local function createOrRepairESP(model, drawings, color)
        if not model then return end
        local data = drawings[model]

        if not data then
            local hrp = model:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color

            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model

            drawings[model] = { text = text, highlight = highlight }
            return
        end

        if not data.text then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color
            data.text = text
        end

        if not data.highlight or not data.highlight.Parent then
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model
            data.highlight = highlight
        else
            data.highlight.Adornee = model
            data.highlight.Enabled = true
            data.highlight.FillColor = color
            data.highlight.OutlineColor = color
        end
    end

    local function removeESP(model, drawings)
        local data = drawings[model]
        if data then
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        drawings[model] = nil
    end

    local function scanWorkspaceForAllowed(allowedList, drawings, color)
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
                createOrRepairESP(obj, drawings, color)
            end
        end
    end

    local function startESPClone()
        if espConnectionClone then return end

        local COLOR = Color3.fromRGB(0, 255, 0)
        scanWorkspaceForAllowed(allowedModelsClone, drawingsClone, COLOR)

        espConnectionClone = RunService.RenderStepped:Connect(function()
            for model, data in pairs(drawingsClone) do
                createOrRepairESP(model, drawingsClone, COLOR)
                data = drawingsClone[model]

                if model.Parent and model:FindFirstChild("HumanoidRootPart") then
                    local hrp = model.HumanoidRootPart
                    local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                    local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                    if data.text then
                        data.text.Text = string.format("%s [%.0fm]", model.Name, dist)
                        data.text.Position = Vector2.new(pos.X, pos.Y)
                        data.text.Visible = onScreen
                    end

                    if data.highlight then
                        data.highlight.Enabled = true
                    end
                else
                    if data.text then data.text.Visible = false end
                    if data.highlight then data.highlight.Enabled = false end
                end
            end
        end)

        addedConnClone = workspace.DescendantAdded:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and allowedModelsClone[model.Name] then
                createOrRepairESP(model, drawingsClone, COLOR)
            end
        end)

        removedConnClone = workspace.DescendantRemoving:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and drawingsClone[model] then
                removeESP(model, drawingsClone)
            end
        end)
    end

    local function stopESPClone()
        if espConnectionClone then espConnectionClone:Disconnect() end
        if addedConnClone then addedConnClone:Disconnect() end
        if removedConnClone then removedConnClone:Disconnect() end
        for _, data in pairs(drawingsClone) do
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        table.clear(drawingsClone)
        espConnectionClone, addedConnClone, removedConnClone = nil, nil, nil
    end

    _G.ESPCloneEnabled = _G.ESPCloneEnabled or false

    VisualTab:Toggle("ESP Clone", _G.ESPCloneEnabled, "Hi·ªán v·ªã tr√≠ c·ªßa nh√¢n b·∫£n", function(state)
        _G.ESPCloneEnabled = state
        if state then
            startESPClone()
        else
            stopESPClone()
        end
    end)
end






do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera

    local LocalPlayer = Players.LocalPlayer
    local drawingsESP = {}
    local espConnection, addedConn, removingConn

    -- üé® M√†u xanh l∆°
    local ESP_COLOR = Color3.fromRGB(0, 255, 255)

    -- üìå T·∫°o ho·∫∑c s·ª≠a ESP cho Player
    local function createOrRepairESP(player)
        if not player.Character then return end
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local data = drawingsESP[player]
        if not data then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = ESP_COLOR

            local highlight = Instance.new("Highlight")
            highlight.Adornee = player.Character
            highlight.FillColor = ESP_COLOR
            highlight.OutlineColor = ESP_COLOR
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = player.Character

            drawingsESP[player] = { text = text, highlight = highlight }
            return
        end

        if not data.text then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = ESP_COLOR
            data.text = text
        end

        if (not data.highlight) or (not data.highlight.Parent) then
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
            local highlight = Instance.new("Highlight")
            highlight.Adornee = player.Character
            highlight.FillColor = ESP_COLOR
            highlight.OutlineColor = ESP_COLOR
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = player.Character
            data.highlight = highlight
        else
            data.highlight.Adornee = player.Character
            data.highlight.Enabled = true
            data.highlight.FillColor = ESP_COLOR
            data.highlight.OutlineColor = ESP_COLOR
        end
    end

    -- üìå Xo√° ESP
    local function removeESP(player)
        local data = drawingsESP[player]
        if data then
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        drawingsESP[player] = nil
    end

    -- üìå Qu√©t to√†n b·ªô Player hi·ªán t·∫°i
    local function scanAllPlayers()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                createOrRepairESP(player)
            end
        end
    end

    -- üî• B·∫≠t ESP
    local function startESP()
        if espConnection then return end

        scanAllPlayers()

        espConnection = RunService.RenderStepped:Connect(function()
            for player, data in pairs(drawingsESP) do
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = player.Character.HumanoidRootPart
                    createOrRepairESP(player)
                    data = drawingsESP[player]

                    local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                    local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                    if data.text then
                        data.text.Text = string.format("%s [%.0fm]", player.Name, dist)
                        data.text.Position = Vector2.new(pos.X, pos.Y)
                        data.text.Visible = onScreen
                    end

                    if data.highlight then
                        data.highlight.Enabled = true
                    end
                else
                    if data.text then data.text.Visible = false end
                    if data.highlight then data.highlight.Enabled = false end
                end
            end
        end)

        addedConn = Players.PlayerAdded:Connect(function(player)
            if player ~= LocalPlayer then
                player.CharacterAdded:Connect(function()
                    task.wait(1)
                    createOrRepairESP(player)
                end)
            end
        end)

        removingConn = Players.PlayerRemoving:Connect(function(player)
            removeESP(player)
        end)
    end

    -- üõë T·∫Øt ESP
    local function stopESP()
        if espConnection then espConnection:Disconnect() end
        if addedConn then addedConn:Disconnect() end
        if removingConn then removingConn:Disconnect() end

        for _, data in pairs(drawingsESP) do
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        table.clear(drawingsESP)
        espConnection, addedConn, removingConn = nil, nil, nil
    end

    -- üß© Toggle ki·ªÉu Fluent
    _G.ESPPlayer = _G.ESPPlayer or false

    PlayerTab:Toggle("ESP Player", _G.ESPPlayer, "Hi·ªán v·ªã tr√≠ c·ªßa ng∆∞·ªùi ch∆°i", function(value)
        _G.ESPPlayer = value
        if value then
            startESP()
        else
            stopESP()
        end
    end)
end





-- ‚úÖ ESP Model (Survivors & Killers) - Chu·∫©n Relz Hub
do
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    local Players = game:GetService("Players")

    -- Danh s√°ch model
    local allowedModelsWhite = {
        ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
        ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true, ["Veeronica"] = true,
        ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true,
    }

    local allowedModelsRed = {
        ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
        ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true
    }

    -- Containers
    local drawingsWhite, drawingsRed = {}, {}
    local conWhiteLoop, conWhiteAdded, conWhiteRemoved
    local conRedLoop, conRedAdded, conRedRemoved

    -- Check model c√≥ ph·∫£i player ƒëi·ªÅu khi·ªÉn kh√¥ng
    local function isControlledByPlayer(model)
        if model:FindFirstChildOfClass("Humanoid") then
            local plr = Players:GetPlayerFromCharacter(model)
            return plr ~= nil
        end
        return false
    end

    -- Utility t·∫°o/repair ESP
    local function createOrRepairESP(model, drawings, color)
        if not model then return end

        local data = drawings[model]
        if not data then
            local hrp = model:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color

            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model

            drawings[model] = { text = text, highlight = highlight }
            return
        end

        -- Repair n·∫øu m·∫•t
        if not data.text then
            local text = Drawing.new("Text")
            text.Size = 14
            text.Center = true
            text.Outline = true
            text.Visible = false
            text.Color = color
            data.text = text
        end
        if not (data.highlight and data.highlight.Parent) then
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
            local highlight = Instance.new("Highlight")
            highlight.Adornee = model
            highlight.FillColor = color
            highlight.OutlineColor = color
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.Parent = model
            data.highlight = highlight
        end
    end

    local function removeESP(model, drawings)
        local data = drawings[model]
        if data then
            pcall(function() if data.text then data.text:Remove() end end)
            pcall(function() if data.highlight then data.highlight:Destroy() end end)
        end
        drawings[model] = nil
    end

    -- Loop ESP update
    local function updateESP(drawings, color)
        for model, data in pairs(drawings) do
            if model.Parent and model:FindFirstChild("HumanoidRootPart") then
                createOrRepairESP(model, drawings, color)
                data = drawings[model]

                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    local displayName = model.Name
                    if model.Name == "Noli" and not isControlledByPlayer(model) then
                        displayName = "Noli Fake"
                    end

                    data.text.Text = string.format("%s [%.0fm]", displayName, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end

                if data.highlight then
                    data.highlight.Adornee = model
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end

    -- === White ESP ===
    local function startESPWhite()
        if conWhiteLoop then return end
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and allowedModelsWhite[obj.Name] then
                createOrRepairESP(obj, drawingsWhite, Color3.fromRGB(255, 255, 255))
            end
        end

        conWhiteLoop = RunService.Heartbeat:Connect(function()
            updateESP(drawingsWhite, Color3.fromRGB(255, 255, 255))
        end)

        conWhiteAdded = workspace.DescendantAdded:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and allowedModelsWhite[model.Name] then
                createOrRepairESP(model, drawingsWhite, Color3.fromRGB(255, 255, 255))
            end
        end)
        conWhiteRemoved = workspace.DescendantRemoving:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and drawingsWhite[model] then
                removeESP(model, drawingsWhite)
            end
        end)
    end

    local function stopESPWhite()
        if conWhiteLoop then conWhiteLoop:Disconnect(); conWhiteLoop = nil end
        if conWhiteAdded then conWhiteAdded:Disconnect(); conWhiteAdded = nil end
        if conWhiteRemoved then conWhiteRemoved:Disconnect(); conWhiteRemoved = nil end
        for _, d in pairs(drawingsWhite) do
            pcall(function() if d.text then d.text:Remove() end end)
            pcall(function() if d.highlight then d.highlight:Destroy() end end)
        end
        drawingsWhite = {}
    end

    -- === Red ESP ===
    local function startESPRed()
        if conRedLoop then return end
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and allowedModelsRed[obj.Name] then
                createOrRepairESP(obj, drawingsRed, Color3.fromRGB(255, 0, 0))
            end
        end

        conRedLoop = RunService.Heartbeat:Connect(function()
            updateESP(drawingsRed, Color3.fromRGB(255, 0, 0))
        end)

        conRedAdded = workspace.DescendantAdded:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and allowedModelsRed[model.Name] then
                createOrRepairESP(model, drawingsRed, Color3.fromRGB(255, 0, 0))
            end
        end)
        conRedRemoved = workspace.DescendantRemoving:Connect(function(obj)
            local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
            if model and drawingsRed[model] then
                removeESP(model, drawingsRed)
            end
        end)
    end

    local function stopESPRed()
        if conRedLoop then conRedLoop:Disconnect(); conRedLoop = nil end
        if conRedAdded then conRedAdded:Disconnect(); conRedAdded = nil end
        if conRedRemoved then conRedRemoved:Disconnect(); conRedRemoved = nil end
        for _, d in pairs(drawingsRed) do
            pcall(function() if d.text then d.text:Remove() end end)
            pcall(function() if d.highlight then d.highlight:Destroy() end end)
        end
        drawingsRed = {}
    end

    -- üü© Chu·∫©n Relz Hub Toggle (ESP Survivors)
    VisualTab:Toggle("ESP Survivors", false, "Hi·ªán v·ªã tr√≠ c·ªßa ng∆∞·ªùi s·ªëng s√≥t", function(v)
        if v then
            startESPWhite()
        else
            stopESPWhite()
        end
    end)

    -- üü• Chu·∫©n Relz Hub Toggle (ESP Killers)
    VisualTab:Toggle("ESP Killers", false, "Hi·ªán v·ªã tr√≠ c·ªßa k·∫ª gi·∫øt ng∆∞·ªùi", function(v)
        if v then
            startESPRed()
        else
            stopESPRed()
        end
    end)
end






do
    -- === ESP Generator (Highlight) ===
    local highlights, progressConns = {}, {}
    local espLoop
    local espEnabled = false
    local genAddedConn, genRemovedConn

    -- L·∫•y generators trong map
    local function getGenerators()
        local list = {}
        local mapRoot = workspace:FindFirstChild("Map")
        local ingame = mapRoot and mapRoot:FindFirstChild("Ingame")
        local mapFolder = ingame and ingame:FindFirstChild("Map")

        for _, obj in ipairs((mapFolder or ingame or mapRoot or workspace):GetDescendants()) do
            if obj:IsA("Model") and obj.Name == "Generator" then
                if not obj.PrimaryPart then
                    local part = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
                    if part then
                        pcall(function() obj.PrimaryPart = part end)
                    end
                end
                table.insert(list, obj)
            end
        end
        return list
    end

    local function isCompleted(gen)
        local p = gen:FindFirstChild("Progress")
        return p and tonumber(p.Value) and p.Value >= 100
    end

    local function ensureHighlight(gen)
        if highlights[gen] then
            highlights[gen].Enabled = true
            return
        end
        local h = Instance.new("Highlight")
        h.Adornee = gen
        h.FillColor = Color3.fromRGB(255, 255, 255)
        h.OutlineColor = Color3.fromRGB(255, 255, 255)
        h.FillTransparency = 0.5
        h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        h.Parent = gen
        highlights[gen] = h
    end

    local function cleanupModel(gen)
        if progressConns[gen] then
            progressConns[gen]:Disconnect()
            progressConns[gen] = nil
        end
        if highlights[gen] then
            highlights[gen]:Destroy()
            highlights[gen] = nil
        end
    end

    local function watchProgress(gen)
        if progressConns[gen] then return end
        local p = gen:FindFirstChild("Progress")
        if not p then return end
        progressConns[gen] = p.Changed:Connect(function()
            if not espEnabled then return end
            if isCompleted(gen) then
                if highlights[gen] then highlights[gen].Enabled = false end
            else
                ensureHighlight(gen)
            end
        end)
    end

    local function startESPGen()
        if espEnabled then return end
        espEnabled = true

        -- Loop c·∫≠p nh·∫≠t m·ªói 0.5s
        espLoop = task.spawn(function()
            while espEnabled do
                for _, gen in ipairs(getGenerators()) do
                    if isCompleted(gen) then
                        if highlights[gen] then highlights[gen].Enabled = false end
                    else
                        ensureHighlight(gen)
                    end
                    watchProgress(gen)
                end
                -- cleanup generator b·ªã xo√°
                for gen, _ in pairs(highlights) do
                    if not gen:IsDescendantOf(workspace) then
                        cleanupModel(gen)
                    end
                end
                task.wait(0.5)
            end
        end)

        -- K·∫øt n·ªëi spawn/remove
        genAddedConn = workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("Model") and obj.Name == "Generator" then
                task.defer(function()
                    if isCompleted(obj) then
                        if highlights[obj] then highlights[obj].Enabled = false end
                    else
                        ensureHighlight(obj)
                    end
                    watchProgress(obj)
                end)
            end
        end)

        genRemovedConn = workspace.DescendantRemoving:Connect(function(obj)
            if highlights[obj] or progressConns[obj] then
                cleanupModel(obj)
            end
        end)
    end

    local function stopESPGen()
        espEnabled = false
        if espLoop then espLoop = nil end
        if genAddedConn then genAddedConn:Disconnect(); genAddedConn = nil end
        if genRemovedConn then genRemovedConn:Disconnect(); genRemovedConn = nil end
        for gen, _ in pairs(progressConns) do
            cleanupModel(gen)
        end
    end

    -- ‚úÖ Toggle Fluent chu·∫©n
    _G.ESPGeneratorEnabled = _G.ESPGeneratorEnabled or false

    VisualTab:Toggle("ESP Generator", _G.ESPGeneratorEnabled, "Hi·ªán v·ªã tr√≠ c√°c m√°y ph√°t ƒëi·ªán", function(state)
        _G.ESPGeneratorEnabled = state
        if state then
            startESPGen()
        else
            stopESPGen()
        end
    end)
end




ldo
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera

    local itemsDraw = {}
    local conItemsAdded, conItemsRemoved, conItemsLoop

    local function getToolPart(tool)
        return tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
    end

    local function createItemESP(tool)
        if itemsDraw[tool] then return end
        local part = getToolPart(tool)
        if not part then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = Color3.fromRGB(255, 215, 0)

        local hl = Instance.new("Highlight")
        hl.Name = "ItemESP_Highlight"
        hl.Adornee = part
        hl.FillColor = Color3.fromRGB(255, 215, 0)
        hl.OutlineColor = Color3.fromRGB(255, 215, 0)
        hl.FillTransparency = 0.7
        hl.OutlineTransparency = 0
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        hl.Enabled = true
        hl.Parent = tool

        itemsDraw[tool] = {text = text, highlight = hl, part = part}
    end

    local function removeItemESP(tool)
        local data = itemsDraw[tool]
        if not data then return end
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        itemsDraw[tool] = nil
    end

    local function isInIngameFolder(inst)
        local map = workspace:FindFirstChild("Map")
        local ingame = map and map:FindFirstChild("Ingame")
        return ingame and inst:IsDescendantOf(ingame)
    end

    local function scanInitialItems()
        local map = workspace:FindFirstChild("Map")
        local ingame = map and map:FindFirstChild("Ingame")
        if not ingame then return end
        for _, obj in ipairs(ingame:GetDescendants()) do
            if obj:IsA("Tool") then
                createItemESP(obj)
            end
        end
    end

    local function startESPItems()
        if conItemsLoop then return end

        scanInitialItems()

        -- Theo d√µi tool m·ªõi th√™m
        conItemsAdded = workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("Tool") and isInIngameFolder(obj) then
                createItemESP(obj)
            end
        end)

        conItemsRemoved = workspace.DescendantRemoving:Connect(function(obj)
            if itemsDraw[obj] then
                removeItemESP(obj)
            end
        end)

        -- C·∫≠p nh·∫≠t v·ªã tr√≠ text m·ªói frame
        conItemsLoop = RunService.RenderStepped:Connect(function()
            for tool, data in pairs(itemsDraw) do
                local part = data.part
                if not (tool.Parent and part and part.Parent) or not isInIngameFolder(tool) then
                    data.text.Visible = false
                else
                    local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 2, 0))
                    local dist = (part.Position - Camera.CFrame.Position).Magnitude
                    data.text.Text = string.format("%s [%.0fm]", tool.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                    if data.highlight then
                        data.highlight.Adornee = part
                        data.highlight.Enabled = true
                    end
                end
            end
        end)
    end

    local function stopESPItems()
        if conItemsAdded then conItemsAdded:Disconnect(); conItemsAdded = nil end
        if conItemsRemoved then conItemsRemoved:Disconnect(); conItemsRemoved = nil end
        if conItemsLoop then conItemsLoop:Disconnect(); conItemsLoop = nil end
        for tool, _ in pairs(itemsDraw) do
            removeItemESP(tool)
        end
        itemsDraw = {}
    end

    -- ‚úÖ Toggle Fluent chu·∫©n
    _G.ESPItemsEnabled = _G.ESPItemsEnabled or false

    VisualTab:Toggle("ESP Items", _G.ESPItemsEnabled, "Hi·ªán v·ªã tr√≠ c√°c v·∫≠t ph·∫©m", function(enabled)
        _G.ESPItemsEnabled = enabled
        if enabled then
            startESPItems()
        else
            stopESPItems()
        end
    end)
end

---------------------------------------------------------------------------------
-- Misc
---------------------------------------------------------------------------------

-- FullBright Toggle
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end
    game:GetService("Lighting").Ambient = Color3.fromRGB(200, 200, 200)
    game:GetService("Lighting").Brightness = 4
    game:GetService("Lighting").GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() fullBrightLoop=nil end
    local Lighting = game:GetService("Lighting")
    Lighting.Ambient = Color3.fromRGB(128,128,128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

MiscTab:Toggle("Full Bright", fullBrightEnabled, "Gi√∫p Tr·ªùi S√°ng h∆°n x200 l·∫ßn", function(value)
    fullBrightEnabled = value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

-- Remove Fog Toggle
local fogEnabled = false
local fogLoop

local function removeFog()
    local Lighting = game:GetService("Lighting")
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000
    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1,1,1)
    end
end

local function restoreFog()
    local Lighting = game:GetService("Lighting")
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000
    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200,200,200)
    end
end

MiscTab:Toggle("Remove Fog", fogEnabled, "Lo·∫°i b·ªè s∆∞∆°ng m√π quanh b·∫£n ƒë·ªì", function(value)
    fogEnabled = value
    if fogEnabled then
        removeFog()
        if fogLoop then fogLoop:Disconnect() end
        fogLoop = game:GetService("RunService").Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop=nil end
        restoreFog()
    end
end)




MainTab:Seperator("Cammera");



local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

-- Flag b·∫≠t/t·∫Øt
local ActiveRemoveAll = true

-- Danh s√°ch t√™n hi·ªáu ·ª©ng th∆∞·ªùng g·∫∑p
local effectNames = {
    "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
    "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
    "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
    "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
}

-- Danh s√°ch class hi·ªáu ·ª©ng trong Lighting
local effectClasses = {
    "BlurEffect",
    "BloomEffect",
    "SunRaysEffect",
    "DepthOfFieldEffect",
    "ColorCorrectionEffect"
}

-- üåü H√†m xo√° t·∫•t c·∫£ (effects + popups)
local function removeAll()
    -- Xo√° hi·ªáu ·ª©ng trong Lighting
    for _, obj in pairs(Lighting:GetDescendants()) do
        if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
            obj:Destroy()
        end
    end

    -- Xo√° GUI overlay
    for _, obj in pairs(PlayerGui:GetDescendants()) do
        if table.find(effectNames, obj.Name) then
            obj:Destroy()
        elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
                if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
                    obj:Destroy()
                end
            end
        end
    end

    -- Xo√° popup 1x1x1x1
    local temp = PlayerGui:FindFirstChild("TemporaryUI")
    if temp then
        local popup = temp:FindFirstChild("1x1x1x1Popup")
        if popup then
            popup:Destroy()
            warn("[Remover] 1x1x1x1Popup removed")
        end
    end
end

-- ‚úÖ Toggle d·∫°ng n√∫t inline
MiscTab:Toggle("Remove Effects", ActiveRemoveAll, "X√≥a b·ªè m·ªôt s·ªë hi·ªáu ·ª©ng  b·∫•t l·ª£i", function(value)
    ActiveRemoveAll = value
    if ActiveRemoveAll then
        task.spawn(function()
            while ActiveRemoveAll do
                removeAll()
                task.wait(0.5)
            end
        end)
    end
end)





local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- ‚úÖ Toggle Infinite Zoom
MiscTab:Toggle("Infinite Zoom", false, "Gi√∫p b·∫°n ph√≥ng to cammera v√¥ h·∫°n", function(value)
    if value then
        LP.CameraMaxZoomDistance = math.huge
        LP.CameraMinZoomDistance = 0
        warn("[Camera] Infinite zoom enabled")
    else
        LP.CameraMaxZoomDistance = 128 -- gi√° tr·ªã m·∫∑c ƒë·ªãnh Roblox
        LP.CameraMinZoomDistance = 0.5 -- gi√° tr·ªã m·∫∑c ƒë·ªãnh Roblox
        warn("[Camera] Zoom reset to default")
    end
end)





MainTab:Seperator("Show");


local RunService = game:GetService("RunService")
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- Update FPS
        fpsText.Text = "FPS: " .. tostring(fpsCounter)
        fpsText.Visible = showFPS

        -- Update Ping
        local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
        local ping = pingStat and math.floor(pingStat:GetValue()) or 0
        msText.Text = "Ping: " .. ping .. " ms"

        if ping <= 60 then
            msText.Color = Color3.fromRGB(0, 255, 0)
        elseif ping <= 120 then
            msText.Color = Color3.fromRGB(255, 165, 0)
        else
            msText.Color = Color3.fromRGB(255, 0, 0)
        end
        msText.Visible = showPing

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ‚úÖ Toggle: Show FPS
MiscTab:Toggle("Show FPS", showFPS, "Hi·ªán Fps hi·ªán t·∫°i c·ªßa b·∫°n", function(value)
    showFPS = value
    fpsText.Visible = value
end)

-- ‚úÖ Toggle: Show Ping
MiscTab:Toggle("Show Ping", showPing, "Hi·ªán Ping hi·ªán t·∫°i c·ªßa b·∫°n", function(value)
    showPing = value
    msText.Visible = value
end)



do
-- LocalScript: Custom mirror of Roblox chat (view + send + collapse)
-- Place in StarterPlayerScripts ho·∫∑c StarterGui

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- === CONFIG ===
local USE_RICHTEXT = true

-- === ScreenGui ===
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CustomChatGUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- === Frame ch√≠nh ===
local chatFrame = Instance.new("Frame")
chatFrame.Name = "ChatFrame"
chatFrame.Size = UDim2.fromScale(0.32, 0.42)
chatFrame.AnchorPoint = Vector2.new(0.5, 0.5)
chatFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
chatFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
chatFrame.BackgroundTransparency = 0.25
chatFrame.BorderSizePixel = 0
chatFrame.Active = true
chatFrame.ClipsDescendants = true
chatFrame.Parent = screenGui

local sizeConstraint = Instance.new("UISizeConstraint")
sizeConstraint.MaxSize = Vector2.new(660, 480)
sizeConstraint.MinSize = Vector2.new(260, 32)
sizeConstraint.Parent = chatFrame

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 12)
uiCorner.Parent = chatFrame

-- === Thanh ti√™u ƒë·ªÅ ===
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 28)
titleBar.BackgroundTransparency = 1
titleBar.Parent = chatFrame

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, -40, 1, 0)
title.Position = UDim2.new(0, 6, 0, 0)
title.Font = Enum.Font.SourceSansSemibold
title.TextSize = 18
title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(240, 240, 240)
title.Text = "Khung chat ·∫£o"
title.Parent = titleBar

-- N√∫t thu g·ªçn
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "ToggleBtn"
toggleBtn.Size = UDim2.new(0, 28, 0, 24)
toggleBtn.Position = UDim2.new(1, -32, 0.5, -12)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleBtn.Text = "-"
toggleBtn.Font = Enum.Font.SourceSansBold
toggleBtn.TextSize = 20
toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
toggleBtn.Parent = titleBar

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 6)
toggleCorner.Parent = toggleBtn

-- Vi·ªÅn m·ªèng
local stroke = Instance.new("UIStroke")
stroke.Thickness = 1
stroke.Transparency = 0.6
stroke.Color = Color3.fromRGB(255,255,255)
stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
stroke.Parent = chatFrame

-- === ScrollingFrame ===
local scroll = Instance.new("ScrollingFrame")
scroll.Name = "Messages"
scroll.Size = UDim2.new(1, -10, 1, -72)
scroll.Position = UDim2.new(0, 5, 0, 34)
scroll.BackgroundTransparency = 1
scroll.BorderSizePixel = 0
scroll.ScrollBarThickness = 6
scroll.ScrollingDirection = Enum.ScrollingDirection.Y
scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
scroll.CanvasSize = UDim2.new(0,0,0,0)
scroll.Parent = chatFrame

local padding = Instance.new("UIPadding")
padding.PaddingTop = UDim.new(0, 4)
padding.PaddingBottom = UDim.new(0, 6)
padding.PaddingLeft = UDim.new(0, 6)
padding.PaddingRight = UDim.new(0, 6)
padding.Parent = scroll

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 4)
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Parent = scroll

layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
	scroll.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 8)
end)

-- === Input bar ===
local inputBar = Instance.new("Frame")
inputBar.Name = "InputBar"
inputBar.Size = UDim2.new(1, -10, 0, 32)
inputBar.Position = UDim2.new(0, 5, 1, -36)
inputBar.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
inputBar.BackgroundTransparency = 0.2
inputBar.BorderSizePixel = 0
inputBar.Parent = chatFrame

local inputCorner = Instance.new("UICorner")
inputCorner.CornerRadius = UDim.new(0, 8)
inputCorner.Parent = inputBar

local textBox = Instance.new("TextBox")
textBox.Name = "ChatInput"
textBox.Size = UDim2.new(1, -50, 1, 0)
textBox.Position = UDim2.new(0, 6, 0, 0)
textBox.BackgroundTransparency = 1
textBox.Font = Enum.Font.SourceSans
textBox.TextSize = 18
textBox.TextXAlignment = Enum.TextXAlignment.Left
textBox.PlaceholderText = "Nh·∫≠p tin nh·∫Øn..."
textBox.TextColor3 = Color3.fromRGB(255,255,255)
textBox.Parent = inputBar

local sendBtn = Instance.new("TextButton")
sendBtn.Name = "SendBtn"
sendBtn.Size = UDim2.new(0, 44, 1, 0)
sendBtn.Position = UDim2.new(1, -44, 0, 0)
sendBtn.BackgroundColor3 = Color3.fromRGB(50, 120, 255)
sendBtn.Text = "‚û§"
sendBtn.Font = Enum.Font.SourceSansBold
sendBtn.TextSize = 20
sendBtn.TextColor3 = Color3.fromRGB(255,255,255)
sendBtn.Parent = inputBar

local sendCorner = Instance.new("UICorner")
sendCorner.CornerRadius = UDim.new(0, 8)
sendCorner.Parent = sendBtn

-- === Collapse logic ===
local collapsed = false
local fullHeight = chatFrame.Size

toggleBtn.MouseButton1Click:Connect(function()
	collapsed = not collapsed
	if collapsed then
		scroll.Visible = false
		inputBar.Visible = false
		chatFrame.Size = UDim2.new(chatFrame.Size.X.Scale, chatFrame.Size.X.Offset, 0, 32)
		toggleBtn.Text = "+"
	else
		scroll.Visible = true
		inputBar.Visible = true
		chatFrame.Size = fullHeight
		toggleBtn.Text = "-"
	end
end)

-- === Helper: strip tag ===
local function stripTags(str)
	return (str:gsub("<[^>]->", ""))
end

-- === Add message ===
local function addMessage(text, speaker)
	local msg = Instance.new("TextLabel")
	msg.Name = "Msg"
	msg.BackgroundTransparency = 1
	msg.TextXAlignment = Enum.TextXAlignment.Left
	msg.TextWrapped = true
	msg.RichText = USE_RICHTEXT
	msg.Font = Enum.Font.SourceSans
	msg.TextSize = 18
	msg.TextColor3 = Color3.fromRGB(255, 255, 255)
	msg.AutomaticSize = Enum.AutomaticSize.Y
	msg.Size = UDim2.new(1, 0, 0, 0)

	if not USE_RICHTEXT then
		text = stripTags(text or "")
	end

	msg.Text = string.format("[%s]: %s", speaker or "H·ªá th·ªëng", text or "")
	msg.Parent = scroll

	task.defer(function()
		scroll.CanvasPosition = Vector2.new(0, 1e7)
	end)
end

-- === K√©o/th·∫£ ===
do
	local dragging, dragInput, dragStart, startPos
	local function update(input)
		local delta = input.Position - dragStart
		chatFrame.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
	titleBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = chatFrame.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	titleBar.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			update(input)
		end
	end)
end

-- === Nh·∫≠n chat ===
local function hookTextChatService()
	TextChatService.MessageReceived:Connect(function(message)
		local text = message and message.Text or ""
		local speaker = "H·ªá th·ªëng"
		if message then
			if message.PrefixText and #message.PrefixText > 0 then
				speaker = message.PrefixText:gsub(":%s*$","")
			elseif message.TextSource then
				local p = Players:GetPlayerByUserId(message.TextSource.UserId)
				speaker = (p and p.DisplayName) or "Ng∆∞·ªùi ch∆°i"
			end
		end
		addMessage(text, speaker)
	end)
end

local function hookLegacyChat()
	local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	if not chatEvents then return end
	local onMsg = chatEvents:FindFirstChild("OnMessageDoneFiltering")
	if not onMsg then return end
	onMsg.OnClientEvent:Connect(function(data)
		addMessage(data.Message, data.FromSpeaker or "H·ªá th·ªëng")
	end)
end

-- === G·ª≠i chat ===
local function sendChat(text)
	if not text or text == "" then return end
	if TextChatService and TextChatService.ChatInputBarConfiguration then
		local channel = TextChatService.ChatInputBarConfiguration.TargetTextChannel
		if channel then
			channel:SendAsync(text)
			return
		end
	end
	local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	if chatEvents then
		local sayMsg = chatEvents:FindFirstChild("SayMessageRequest")
		if sayMsg then
			sayMsg:FireServer(text, "All")
			return
		end
	end
end

sendBtn.MouseButton1Click:Connect(function()
	sendChat(textBox.Text)
	textBox.Text = ""
end)
textBox.FocusLost:Connect(function(enterPressed)
	if enterPressed then
		sendChat(textBox.Text)
		textBox.Text = ""
	end
end)

-- Hook
local okNew = false
pcall(function()
	if TextChatService and TextChatService.MessageReceived then
		okNew = true
		hookTextChatService()
	end
end)
if not okNew then
	hookLegacyChat()
end

-- === üìå Toggle Fluent UI ki·ªÉu inline ===
Misc:Toggle("Show Chat", screenGui.Enabled, "Hi·ªán m·ªôt khung chat ·∫£o", function(value)
	screenGui.Enabled = value
end)
end




MainTab:Seperator("Fix Lag");

-- L∆∞u d·ªØ li·ªáu g·ªëc
local originalLighting = {}
local originalParts = {}

-- H√†m l∆∞u Lighting g·ªëc
local function saveLighting()
    originalLighting.QualityLevel = settings().Rendering.QualityLevel
    originalLighting.GlobalShadows = game.Lighting.GlobalShadows
    originalLighting.FogEnd = game.Lighting.FogEnd
    originalLighting.Brightness = game.Lighting.Brightness
    originalLighting.PostEffects = {}
    for _, v in ipairs(game.Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            originalLighting.PostEffects[v] = v.Enabled
        end
    end
end

-- H√†m kh√¥i ph·ª•c Lighting
local function restoreLighting()
    if not originalLighting.QualityLevel then return end
    settings().Rendering.QualityLevel = originalLighting.QualityLevel
    game.Lighting.GlobalShadows = originalLighting.GlobalShadows
    game.Lighting.FogEnd = originalLighting.FogEnd
    game.Lighting.Brightness = originalLighting.Brightness
    for effect, state in pairs(originalLighting.PostEffects) do
        if effect and effect.Parent == game.Lighting then
            effect.Enabled = state
        end
    end
end

-- H√†m gi·∫£m ƒë·ªì h·ªça tri·ªát ƒë·ªÉ
local function simplifyModel(obj)
    if obj:IsA("BasePart") then
        if not originalParts[obj] then
            originalParts[obj] = {
                Material = obj.Material,
                Color = obj.Color,
                Reflectance = obj.Reflectance,
                CastShadow = obj.CastShadow
            }
        end
        obj.Material = Enum.Material.SmoothPlastic
        obj.Color = Color3.fromRGB(163, 162, 165)
        obj.Reflectance = 0
        obj.CastShadow = false
    elseif obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
        obj:Destroy()
    elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") 
        or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end
end

-- H√†m kh√¥i ph·ª•c BasePart
local function restoreParts()
    for part, data in pairs(originalParts) do
        if part and part.Parent then
            part.Material = data.Material
            part.Color = data.Color
            part.Reflectance = data.Reflectance
            part.CastShadow = data.CastShadow
        end
    end
    originalParts = {} -- reset
end

-- ==============================
-- Inline Toggle ki·ªÉu MainTab
-- ==============================
local autoThread
local connection

MiscTab:Toggle("FPS Boost", false, "Gi·∫£m ƒë·ªì h·ªça tr√≤ ch∆°i", function(state)
    if state then
        print("üîÑ Auto Reduce ON")

        -- L∆∞u lighting g·ªëc
        saveLighting()

        -- Gi·∫£m ƒë·ªì h·ªça lighting khi b·∫≠t
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        game.Lighting.GlobalShadows = false
        game.Lighting.FogEnd = 9e9
        game.Lighting.Brightness = 1
        for _, v in ipairs(game.Lighting:GetChildren()) do
            if v:IsA("PostEffect") then
                v.Enabled = false
            end
        end

        -- üî• Gi·∫£m ngay 1 l·∫ßn ƒë·∫ßu ti√™n
        for _, obj in ipairs(workspace:GetDescendants()) do
            simplifyModel(obj)
        end

        -- N·∫øu c√≥ object spawn th√™m th√¨ c≈©ng x·ª≠ l√Ω
        connection = workspace.DescendantAdded:Connect(simplifyModel)

        -- Sau ƒë√≥ auto l·∫∑p m·ªói 10s
        autoThread = task.spawn(function()
            while state do
                task.wait(10)
                for _, obj in ipairs(workspace:GetDescendants()) do
                    simplifyModel(obj)
                end
            end
        end)

    else
        print("‚èπ Auto Reduce OFF")
        if connection then
            connection:Disconnect()
            connection = nil
        end

        -- Kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc
        restoreLighting()
        restoreParts()
        print("‚úÖ ƒê√£ kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc")
    end
end)




-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- ======= DANH S√ÅCH BLOCK ANIMATION =======
local blockedAnimations = {
    ["127802146383565"] = true,
    ["82691533602949"] = true,
    ["123764169071995"] = true,
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local BlockAnimEnabled = false
local blockConnections = {}

-- ======= H√ÄM =======
local function hookHumanoid(humanoid)
    if not humanoid then return end
    local conn = humanoid.AnimationPlayed:Connect(function(track)
        local id = track.Animation.AnimationId:match("%d+")
        if BlockAnimEnabled and blockedAnimations[id] then
            track:Stop()
        end
    end)
    table.insert(blockConnections, conn)
end

local function setBlockAnimations(enabled)
    BlockAnimEnabled = enabled

    -- clear c≈©
    for _, conn in pairs(blockConnections) do
        conn:Disconnect()
    end
    table.clear(blockConnections)

    if enabled then
        -- nh√¢n v·∫≠t hi·ªán t·∫°i
        if LocalPlayer.Character then
            hookHumanoid(LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"))
        end
        -- respawn
        local connChar = LocalPlayer.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid")
            hookHumanoid(char:FindFirstChildWhichIsA("Humanoid"))
        end)
        table.insert(blockConnections, connChar)
    end
end

-- ======= TOGGLE INLINE KI·ªÇU AUTO FARM =======
MiscTab:Toggle("Block Animations", BlockAnimEnabled, "Lo·∫°i b·ªè ho·∫°t ·∫£nh s·ª≠a m√°y ph√°t ƒëi·ªán", function(value)
    setBlockAnimations(value)
end)






